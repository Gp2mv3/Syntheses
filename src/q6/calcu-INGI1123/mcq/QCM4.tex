\begin{mcqs}
  \mcq{L'ensemble HALT est récursivement énumérable}{1}
  {Voir QCM3.}
  \mcq{Une fonction calculable peut être calculée par une infinité de programmes}{1}
  {Voir QCM3.}
  \mcq{Le complément de l'ensemble $K$ est récursivement énumérable}{0}
  {Le complément de $K$ est co-récursivement énumérable. Si $K$ était récursivement énumérable et co-récursivement énumérable il serait énumarable.}
  \mcq{Il existe des ensembles non récursivement énumérables}{1}
  {Le complément de $K$}
  \mcq{Tout ensemble est récursivement énumérable ou co-récursivement énumérable}{0}
  {Chaque ensemble récursivement énumérable a un programme qui la décide donc il y a un nombre énumérable d'ensembles énumérables.
  Il y a au plus 2 fois plus d'ensembles récursivement énumérables ou co-récursivement énumérables que d'ensemble énumérables
  donc il y a un nombre énumérables d'ensemble récursivement énumérable ou co-récursivement énumérable.
  Hors il y a un un nombre non-énumérable de sous ensembles de $\mathbb{N}$.}
  \mcq{Soit la fonction $f(i) = 1$ si $\varphi_{i}(i) \neq \bot$, $f(i) = 0$ sinon. La fonction $f$ est calculable.}{0}
  {Sinon, on pourrait décider HALT.}
  \mcq{Soit la fonction $f(i) = 1$ si $\varphi_{i}(i) \neq \bot$, $f(i) = 0$ sinon. Le domaine de $f$ est récursif.}{1}
  {Nous travaillons avec un entier en input et en output, donc la fonction est $\mathbb{N} \rightarrow \mathbb{N}$.
  Le domaine est les input tels que l'output n'est pas $\bot$.
  Or $f$ ne renvoit jamais $\bot$ donc son domaine est $\mathbb{N}$ qui est récursif.}
  \mcq{Soit la fonction $f(i) = 1$ si $\varphi_{i}(i) \neq \bot$, $f(i) = 0$ sinon. L'image de $f$ est un ensemble récursif.}{1}
  {$\{0,1\}$ ne contient que deux entiers et est donc récursif}
  \mcq{$\varphi_{i}(i)$ dénote la fonction numéro $i$ (selon l'énumération choisie pour les fonctions)}{0}
  {$i$ est un numéro de programme}
  \mcq{Il existe un langage de programmation (non-trivial) dans lequel la fonction HALT est calculable}{1}
  {Mini-Java}
  \mcq{Il existe un langage de programmation (non-trivial) dans lequel on peut programmer la fonction HALT ainsi que l'interpréteur de ce langage.}{0}
  {Hoare-Allison}
  \mcq{Si un langage de programmation (non-trivial) permet de programmer son interpréteur, alors la fonction HALT est calculable dans ce langage}{0}
  {Mini-Java}
  \mcq{Il n'existe pas de langage de programmation (non-trivial) dans lequel toutes les fonctions calculées sont totales}{0}
  {La version mini-Java en est la preuve.}
  \mcq{Il n'existe pas de langage de programmation ne permettant de calculer que toutes les fonctions totales calculables}{1}
  {Théorème de Hoare-Allison}
  \mcq{Il existe une fonction totale calculable qui n'est l'extension d'aucune fonction partielle calculable}{0}
  {C'est très facile de créer une fonction partielle à partir d'une fonction totale.
  Il suffit de remplacer le retour d'une valeur par $\bot$. La fonction totale serait alors extension de la fonction partielle.}
  \mcq{Il existe une fonction partielle calculable telle qu'aucune fonction totale calculable n'est une extension de cette fonction partielle}{1}
  {Considérons le tableau avec à la ligne $i$, $\phi_i(0), \phi_i(1), \ldots$.
  Prenons la diagonale $\mathrm{diag}(k) = \phi_k(k)$.
  Considérons $\mathrm{diag_mod}(k) = \phi_k(k)+1$.
  S'il existe un extension totale calculable $d_m$, soit $p$ le numéro d'un programme qui la calcule.
  Alors, on a un soucis en $d,d$.
  Si $\mathrm{diag}(d) = \bot$, $\phi_d(d) \neq \bot$ car $d$ est totale et donc $\mathrm{diag}(d) \neq \phi_d(d)$.
  Si $\mathrm{diag}(d) \neq \bot$, $\phi_d(d) = \mathrm{diag}(d) + 1 \neq \mathrm{diag}(d)$.}
\end{mcqs}
