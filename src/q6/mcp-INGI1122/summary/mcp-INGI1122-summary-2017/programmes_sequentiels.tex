\section{Programmes séquentiels}
\subsection{Affectations}
\textbf{\textit{Affectation} : V:=E;}\\ V une variable et E une expression.\\ 
Affectation simultanée: $V_1,...,V_n := E_1,...,E_n$;\\

$\bullet$\textbf{Axiome l'affectation :\\ $\quad$ [Q[V:=E]] V:=E;[Q]}\\
La notation [Q[V:=E] définit la condition [Q] où toutes les occurrences de V sont remplacées par E.\\
\textit{ou}\\
\textbf{[Q[E]]V:=E;[Q[V]]}\\

$\bullet$\textbf{Prouver et construire}:
La construction de l'affectation se fait autour de la conservation de l'invariant avant et après l'affectation.
\vspace{5mm}
\subsection{Séquences}
\textbf{\textit{Composition séquentielle} S1 S2},\\
elle est associative : \{S1 S2\} S3 = S1 \{S2 S3\} = S1 S2 S3\\

$\bullet$\textbf{Règle}:
Si [P]S1[R] et [R]S2[Q], Alors [P] S1 S2 [Q]\\
La preuve en arrière part de Q pour calculer ensuite R et puis P. La preuve en avant fait le chemin inverse.\\

$\bullet$\textbf{Prouver et construire}:
Pour construire une séquence, on invente R, S1 ou S2 et on calcule ensuite les deux autres.\\

$\bullet$\textbf{Axiome de l'instruction vide :  [Q] \{\}[ Q ]}\\
Avec la règle de conséquence:\\
Si [P] $\Rightarrow$ Q alors [P][Q]\\
Si [P]$\Rightarrow$ [Q] alors [P] [Q] \{\} [Q] \textit{ou} [P] \{\} [P] [Q] \textit{ou} [P] \{\} [Q]\\
Aussi \{\}S = S = S\{\}
\vspace{5mm}
\subsection{Conditionnelles}
\textbf{\textit{Conditionnelle} : if C\{S1\} else \{S2\}}, avec if C \{S1\} $\equiv$ if C \{S1\} else \{\} \\

$\bullet$\textbf{Règle}:\\
- Règle de la conditionnelle en \textbf{avant} :\\
.[P] if C then S1 else S2 fi [Q] \\si et seulement si  [P $ \wedge$ C] S1 [Q] et [P $\wedge$ $\neg$C] S2 [Q]\\\vspace{2,5mm}\\
- Règle de la conditionnelle en \textbf{arrière} :\\
Si [P1] S1 [Q] et [P2] S2 [Q] \\ Alors [(C $\Rightarrow$ P1) $\wedge$ ($\neg$C $\Rightarrow$P2)] if C \{S1\} else \{S2\} [Q]
\subsection{Itérations}
\textbf{\textit{Itération}: while C \{S\}}\\
Deux nouvelles assertions sont nécessaires : l'invariant pour la correction partielle et le variant pour la terminaison.\\

$\bullet$\textbf{Invariant et variant}:\\

Pour la correction \textbf{partielle}, on utilise l'invariant \textbf{I}.\\
Si [I $\wedge$ C] S [I] \\Alors [I] while C \{S\} [I $\wedge$ $\neg$C]\\
Pour prouver [P] while C \{S\} [Q], il faut trouver un invariant I tel que :\\
P $\Rightarrow$ I et (I$\wedge$ $\neg$C) $\Rightarrow$ Q\\

Pour la correction \textbf{totale}, on utilise, en plus de l'invariant, le variant \textbf{V}\\
Si I $\Rightarrow$ V $\geq$ 0 \\ et [I $\wedge$ C $\wedge$ V = $v_0$] S [I $\wedge$ V < $v_0$] \\Alors [I] while C \{S\} [I $\wedge$ $\neg$C]