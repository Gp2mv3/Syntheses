\section{Algorithmes}


\subsection{Principes de conception d'algorithmes}
On appelle un \textbf{algorithme} une procédure définie pour accomplir une certaine tâche ou résoudre un certain problème. Ce problème peut être décrit soit en termes concrets (une base de données, des clients ...) soit en termes abstraits (une liste, une permutation ...). \\
Pour concevoir un bon algorithme, il faut être capable d'utiliser les structures fondamentales (ensembles, points, chaînes, graphes etc)ainsi que les structures récursives (sous-ensemble, sous-arbre, sous-chaîne ...). \\
%Il faut également pouvoir se poser les questions suivantes: a-t-on bien compris le problème posé et le résultat attendu? Est-ce possible de trouver un algorithme simple? Est-ce que  le problème est connu, déjà résolu? Y a-t-il
Il y a des principes généraux applicables à la conception d'algorithmes, et ceux-ci seront décrits dans les sections suivantes.




\subsection{Décomposition en sous-problèmes}
Le premier principe applicable à la conception d'algorithmes est la \textbf{décomposition en sous-problèmes}. Le but est simple: diviser les problèmes difficiles à résoudre en plusieurs petits sous-problèmes faciles à résoudre.
\begin{lstlisting}
procedure Probleme(x)pre... post... {
	var x1 := Subprob1(x);
	var x2 := Subprob2(x,x1);
	return solution(x,x1,x2)
}
\end{lstlisting}

Il est nécessaire de d'abord spécifier les sous-problèmes. Ensuite, on programme et prouve Prob sur base des spécifications des Subprob, indépendamment de leur code. Enfin, on programme et prouve chaque Subprob sur base de ses spécifications, indépendamment du code de Prob et des autres Subprob.


\subsection{Diviser pour régner}
Le principe est simple: on décompose un problème en sous-problèmes plus petits qu'on résoud ensuite. Enfin, on combine les solutions des sous-problèmes en une solution du problème initial. Pour ce faire on utilise la récursion. Cette méthode est utile	si le gain sur la réduction	en problèmes plus petits est supérieur au travail supplémentaire pour la décomposition et combinaison. \\
Les exemples d'algorithmes connus et efficaces qui implémentent cette méthode sont nombreux: recherche dichotomique, mergeSort, quickSort, ... \\
Cette méthode est très efficace lorsque les sous-problèmes sont indépendants, elle donnera en revanche des résultats beaucoup moins satisfaisants lorsqu'ils ne le sont pas (exemple: fibonnaci). En effet, à cause de la récursion elle devra effectuer plusieurs fois les mêmes calculs ce qui peut donner lieu à des complexités exponentielles...


\subsection{Programmation dynamique}
La programmation dynamique se base sur un principe fondamental, appelé le principe d'optimalité de Bellman: toute solution optimale s'appuie elle-même sur des sous-problèmes résolus localement de façon optimale. On débute par les solutions des sous-problèmes les plus petits pour ensuite déduire progressivement les solutions de l'ensemble. \\
La programmation dynamique est très efficace lorsque les sous-problèmes comportent les mêmes parties communes (réaliser le même calcul par exemple), résout chaque sous-problème une seule fois et mémorise la réponse dans un tableau, évitant ainsi le recalcul. Il faut cependant trouver un compromis entre l'espace mémoire utilisé et le temps. \\
Il existe deux approches de programmation dynamique: 
\begin{itemize}
	\item Bottom-up: consiste à calculer et mémoriser les solutions des sous-problèmes liés au problème principal, à partir du plus simple jusqu'au problème principal (bottom-up) en utilisant les solutions des sous-problèmes déjà calculés. Cette solution est peu naturelle, et risque de résoudre des sous-problèmes déjà résolus, mais réduit fortement le coût en espace car elle ne garde que les résultats nécessaires à la suite.
	\item Top-down: dans un algorithme récursif, consiste à mémoriser le résultat pour chaque sous-problème résolu ( = mémoïsation ) et retourner le résultat mémorisé pour les appels successifs au même problème. Cette solution résoud uniquement les sous-problèmes nécessaires, mais garde en mémoire tous les sous-problèmes résolus.
\end{itemize} 