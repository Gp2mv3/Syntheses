\documentclass[fr]{../../../../../../eplexam}
\usepackage{fancyvrb}
\definecolor{Zgris}{rgb}{1,1,1}
\newsavebox{\BBbox}
\newenvironment{DDbox}[1]{
\begin{lrbox}{\BBbox}\begin{minipage}{\linewidth}}
{\end{minipage}\end{lrbox}\noindent\colorbox{Zgris}{\usebox{\BBbox}} \\
[.1cm]}

\hypertitle{Méthodes de Conception de Programmes}{6}{INGI}{1122}{2019}{Juin}{Majeure}
{François De Keersmaeker}
{Charles Pecheur}

\section{Question 1 : Preuve de programme}

Voici le code d'une procédure retournant l'indice de l'élément maximum d'une séquence d'entiers :

\begin{DDbox}{\linewidth}
\begin{Verbatim}
	method maxInd(a: seq<int>) returns (result: int){
	  var max : int := 0;
	  var i : int := 1;
	  while (i < |a|){ //[1]
	    if (a[i] > a[maxi]){
	      maxi := i;
	    }
	    i := i+1;
	  }
	  return maxi;
	}
\end{Verbatim}
\end{DDbox}

\begin{enumerate}
	\item Donnez les \textbf{spécifications} de la procédure.
	\item Donnnez l'\textbf{invariant} et le \textbf{variant} de la boucle en [1].
	\item Prouvez la \textbf{correction partielle} (pas la terminaison) grâce à la méthode des assertions inductives.
\end{enumerate}

\nosolution

\section{Question 2 : Abstraction de données et récursion}
On représente un nombre entier à l'aide d'une séquence d'entiers, dont chaque élément est un chiffre décimal, avec les chiffres de poids faible en premier. Par exemple, le nombre 2019 est représenté par la séquence [9,1,0,2].

Une séquence d'entiers est définie par soit la séquence vide, soit un élément suivi d'une séquence suffixe :
\begin{center}
\texttt{seq<int> ::= [] | a + seq<int>}
\end{center}
La propriété suivante pourra être utile :
\[ n = (n \text{ div } k) \cdot k + n \text{ mod } k \]
pour tous entiers positifs $n$ et $k$.

\begin{enumerate}
	\item Donnez l'invariant de représentation $ok()$.
	\item Donnez la fonction d'abstraction $abs()$.
	\item \'Enoncez le principe de récursion sur les suffixes de séquence.
	\item Prouvez par récursion
	\[ ok(bn) \Rightarrow abs(bn) < 10^{\abs{bn}} \]
	qui signifie que si $bn$ est une représentation correcte, le nombre représenté est inférieur à 10 élevé à la longueur de la séquence.
	\item Spécifiez et implémentez une procédure \texttt{bignum(n: int): seq<int>} qui prend en argument un entier et qui retourne sa représentation sous forme de séquence. Utilisez $ok()$ et $abs()$ dans vos spécifications.
\end{enumerate}

\nosolution

\section{Question 3 : Design patterns}
On souhaite réaliser un programme permettant d'afficher des dessins, \texttt{Drawing}, à l'écran. Pour cela, on a deux types de \texttt{Drawing} : \texttt{Shape}, qui représente une forme de base, et \texttt{Group}, qui contient des \texttt{Shape} et d'autres \texttt{Group}. On emploie pour cela le patron \textit{Composite}. Pour réaliser les dessins, on utilise la méthode \texttt{draw(Display d)}, en se servant du patron \textit{Interpreter}. On se sert également de l'interface (et donc du patron) \textit{Visitor}. Plus précisément, on a une classe \texttt{FindVisitor} qui agit sur les \texttt{Drawing}, et qui retourne un \texttt{Drawing} en fonction du résultat d'une condition sur les \texttt{Drawing}. Pour cette condition, on utilise le patron \textit{Strategy}, avec la classe \texttt{Condition} qui donne un booléen sur les \texttt{Drawing}.

Donner le squelette (en Java) du programme, en n'oubliant pas :
\begin{itemize}
	\item Les classes et interfaces \texttt{Drawing}, \texttt{Shape} et \texttt{Group}, ainsi que toutes les fonctions liées au patron \textit{Composite}.
	\item La fonction \texttt{draw(Display d)} dans chacune de ces classes.
	\item Les interfaces ou classes \texttt{Visitor} et \texttt{FindVisitor} et toutes les méthodes liées au patron \textit{Visitor}.
	\item L'interface \texttt{Condition} et ce qui est nécessaire pour l'utiliser avec le \texttt{FindVisitor}.
\end{itemize}

\nosolution

\end{document}
