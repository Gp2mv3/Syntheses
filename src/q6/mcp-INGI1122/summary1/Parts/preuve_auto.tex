\section{Preuve automatique de programmes}

\subsection{Preuve automatique}
\subsubsection{Chemin simple}
On peut décomposer automatiquement tout programme en chemins simples consitués d'affectations, d'assomptions (assume) et d'assertions (assert). On peut également calculer automatiquement la WP sur un chemin simple. La preuve automatique fonctionne donc bien pour des chemins simples, mais un prouveur d'assertions est nécessaire.

\subsubsection{Boucles}
Aucun logiciel n'est encore capable de trouver l'invariant et le variant d'une boucle, il faut donc qu'ils soient fournis par le programmeur. Une fois ces deux expressions trouvées, le logiciel peut décomposer ces boucles en chemins simples: la preuve automatique fonctionne.

\subsubsection{Programme complet}
Comme pour les boucles, le programmeur doit fournir les spécifications (pré/post, effets, variants). Le prouveur automatique peut ensuite faire son travail par décomposition en chemins simples. 

\subsubsection{Etapes d'une preuve automatique de programme}
\begin{enumerate}

	\item Le programmeur spécifie les pré/post-conditions, les invariants, les variants et les effets
	\item Le prouveur de programmes: 
		\begin{itemize}
			\item considère chaque procédure séparément
			\item décompose en chemins simples [P] S [Q]
			\item calcule $Q_0$ = wp(S,Q) pour chaque chemin simple
		\end{itemize}
	\item Le prouveur dd'assertions prouve P $\Rightarrow Q_0$ 
\end{enumerate}

Le prouveur de programme la correction partielle sur toutes les procédures (par assertions inductives, chemins simples)
 et la décroissance des variants spécifiés (sur les boucles et/ou procédures). Si des variants sont spécifiés sur toutes les boucles et procédures récursives, alors on prouve la correction totale.
 
\subsubsection{Prouveur d'assertions}
Entrée: une assertion P[V] avec des variables V \\
Sortie: "valide" si $\forall V : P[V]$; "invalide"  si le programme trouve un contre-exemple $v*$.
