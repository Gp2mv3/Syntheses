\documentclass[fr]{../../../../../../eplexam}

\hypertitle{Logique et structure discrètes}{5}{INGI}{1101}{2020}{Janvier}{Majeure}
{Augustin d'Oultremont \and Stanislas Gorremans}
{Peter Van Roy}

\section{Bases de la Logique}
    \begin{enumerate}
        \item Définissez le schéma de la preuve par contradiction et justifiez-le en raisonnant sur les interprétations.
        \item L'algorithme de preuve pour la logique des prédicats est complet et adéquat. Définissez ces 2 concepts. Par contre, l'algorithme n'est pas décidable, il n'est que semi-décidable. Définissez ce concept.
        \item Vous allez définir la sémantique de la logique des prédicats en 2 étapes. D'abord, définissez une grammaire de la syntaxe de la logique des prédicats.
        \item Ensuite, définissez le concept d'interprétation d'une formule en logique des prédicats.
        \item Enfin, définissez le concept de modèle d'un ensemble de formules.
    \end{enumerate}
	
	\begin{solution}
		\begin{enumerate}
		\item
			On suppose que les prémisses $p, ..., q$ n'ont pas de problème,
			c'est-à-dire qu'on ne peut pas prouver une contradiction à partir de ces propositions.
			Ensuite, on ajoute $r$ aux prémisses.
			S'il est possible de prouver $s$ et aussi de prouver $\lnot s$, cela signifie qu'il y a une erreur dans les prémisses.
			On suppose que c'est l'ajout $r$ qui est fautif.
			On justifie qu'il n'y a aucune contradiction dans $p, ... ,q$ car on part du principe qu'il existe un modèle de $p,...q$.
			On écrit ce schéma ainsi:
				\begin{center}
					\begin{tabular}{c}
		      		$p,...,q,r \vdash s$ \\
		      		$p,...,q,r \vdash \lnot s$\\
		      		\hline
		      		$p,...,q \vdash \lnot r$\\
		   			\end{tabular}\\
				\end{center}

		\item
			\begin{itemize}
			\item L'algorithme est {\em adéquat} (``{\em consistent}''): Si $B\vdash T$ alors $B \models T$\\
			Si l'algorithme trouve une preuve de $T$ avec les axiomes $B$ alors $T$ sera vraie dans tous les modèles de $B$.
			\item L'algorithme est {\em complet} (``{\em complete}''): Si $B \models T$ alors $B\vdash T$\\
			Si $T$ est vrai dans tous les modèles de $B$ alors l'algorithme trouvera une preuve de $T$ avec les axiomes $B$.
			\item L'algorithme est {\em semi-décidable}:
			\begin{itemize}
			\item Si $B \models T$ alors l'algorithme trouve une preuve. 
			\item Si $B \not\models T$ il peut tourner en rond indéfiniment.
			\end{itemize}
			Si $T$ est vrai dans tous les modèles, l'algorithme trouvera une preuve, mais si $T$ n'est pas
			vrai dans tous les modèles, l'algorithme peut tourner en rond et ne jamais se terminer.
			Le problème est donc que quand l'algorithme prend trop de temps à trouver une preuve,
			à un certain moment on doit l'arrêter et l'on n'est jamais certain du résultat.
			On ne peut jamais être sûr que l'algorithme n'aurait pas trouvé une preuve si on l'avait laissé tourner plus longtemps.
			Il est donc semi-décidable, car il ne s'arrête que si une preuve existe.
			Si il était décidable, il s'arrêterait toujours.
			\end{itemize}
		
		\item 
			\begin{tabular}{|c|c|c|}
			\hline
			Symboles logiques & quantificateurs & $\forall$ $\exists$ \\
			                  & connecteurs logiques & $\wedge$ $\vee$ $\neg$ $\Rightarrow$ $\Leftrightarrow$ \\
			                  & parenthèses & ( ) \\
			                  & variables & $x, y, z$ \\
			                  & & true, false\\
			\hline
			Symboles non logiques & symboles de prédicat & $P$ $Q$ $R$ (avec arité $\geq 0$) \\
			   		      & symboles de fonction & $f$ $g$ $h$ (avec arité $\geq 0$) \\
			   		      & symboles de constante & $a$ $b$ $c$ (si arité $= 0$) \\
			\hline
			\end{tabular}

			
			$<formule>::= \& <formule$ $atomique>$ \\
				  $ \&  \vert$ $\neg$ $<formule>$ \\
				  $ \&  \vert$ $<formule>$ $<connecteur>$ $<formule>$ \\
				   $ \&  \vert$ $\forall <var>.<formule>$ \\
				   $ \&  \vert$ $\exists <var>.<formule>$ \\
			$<formule$ $atomique>::=$ 
							  $\& $ true, false \\
							   $ \& \vert$$ $<predicat>(<terme>*)$ \\
			$<terme>::=$	  $\& $ $<constante>$ \\
							   $ \&$  \vert$ <var>$ \\
							   $ \&  $\vert$ <fonction>(<terme>*)$ \\
			$<connecteur$ $binaire>::=
							 $ \& $ $\wedge \vert \vee \vert \Rightarrow \vert \Leftrightarrow$ \\
		
		\item
			Une {\em interprétation} $I$ en logique des prédicats est une paire $I = (D_I, \mathrm{val}_I)$,
			avec un ensemble $D_I$ qui s'appelle le {\em domaine de discours} et une fonction $\mathrm{val}_I$ qui s'appelle
			la {\em fonction de valuation} qui renvoie un élément de $D_I$ pour chaque symbole.
			Nous avons donc pour chaque symbole $s$:
			\begin{itemize}
			\item Si $s$ est un symbole de prédicat,
			 $\mathrm{val}_{I}(s) = P_{I}$ une fonction $P_{I}:D_{I}^{n} \rightarrow (\mathrm{true},\mathrm{false})$.
			\item Si $s$ est un symbole de fonction,
			 $\mathrm{val}_I(s) = f_I$ une fonction $f_{I}:D_{I}^{n} \rightarrow D_{I}$ avec $n$ le nombre d'arguments.
			\item Si $s$ est une constante (une fonction avec zéro arguments),
			 $\mathrm{val}_I(s) = c$ un élément de $D_I$.
			\item Si $s$ est une variable,
			 $\mathrm{val}_{I}(x) = x_{I}$, un élément $D_{I}$.
			\end{itemize}
			Cela implique chaque fonction correspond à une vraie fonction, chaque prédicat
			correspond à un vrai prédicat, et chaque constante et chaque variable correspondent à une constante dans le domaine 			de discours.
		
		\item
			Un modèle d'un ensemble de formules est une interprétation qui rend toutes les formules vraies.
			Formellement, si on a un ensemble de formules $B = \{ p_1, \ldots, p_n \}$,
			une interprétation $I$ pour $B$ est un {\em modèle} si et seulement si:
			\begin{equation}
			\forall p_i \in B: \mathrm{VAL}_I(p_i) = T
			\end{equation}
		\end{enumerate}
	\end{solution}

\section{Langage logique Prolog}
    \begin{enumerate}
        \item Donnez le pseudocode de l'algorithme d'exécution de Prolog.
        \item Dans le pseudocode de la partie 1, l'algorithme doit faire des choix pendant son exécution. Un choix fait par l'algorithme peut s'avérer mauvais et il doit gérer cela. Expliquez comment l'algorithme fait la gestion des choix. Il n'est pas nécessaire de donner un pseudocode dans votre explication.
        \item Considérez le programme Prolog suivant qui somme les éléments d'une liste:
        
        $$sum([], S, S). sum([X|L], S1, S) :- S2 is X+S1, sum(L, S2, S).$$
        
        avec la requête $|? sum([5,6], 0, S).$ Quelle est la forme normale conjonctive (FNC) de ce programme?
        \item Quelle est la résolvante initiale correspondant à cette requête?
        \item Faire 2 résolutions ou renommages.
        \item Faire encore 3 résolutions. Pour la dernière résolution, il faut choisir la première clause. Vous devez alors arriver à une résolution vide. Montrer comment la dernière substitution donne la solution.
    \end{enumerate}
    
	\begin{solution}
	\begin{enumerate}
	\item
		
		$r :=\ <G>$ … résolvante initiale (séquence initiale contient $G$) \\
		… pendant l'exécution $r= <A_1,A_2,...,A_m>$ (séquence de littéraux \footnote{Attention, $<A_1,A_2,...,A_m>$ représente $\neg A_1\vee \neg A_2\vee \neg ...\vee \neg A_m$})\\
		$While$ r est non vide et il y a encore des choix
			\begin{itemize}
				\item Choisir le premier littéral $A_{1}$ dans $r$.
				\item Choisir une clause $Ax_{1}=(A \leftarrow B_{1},...,B_{k})$ dans $P$. D’abord on prend la première clause, puis la suivante jusqu’à ce qu’on trouve une clause unifiable avec $A_{1}$. Si aucune clause n’est unifiable on revient sur le dernier choix (backtrack).
				\item Nouvelle résolvante $r := <B_{1},..., B_{k}, A_{2},...,A_{m}> \sigma$
				\item Nouveau but $G := G \sigma$
			\end{itemize}
		
		$if$ r est vide \\
		Le résultat est OUI. Le résultat de l'exécution est le tout dernier $G$.
		Si on le souhaite, on peut faire un retour en arrière pour que
		l'algorithme calcule d'autres solutions.\\
		$elseif$ On épuise les choix sans que $r$ soit vide Le résultat est NON. \\ On n’a pas prouvé $G$. (Attention : $G$ est peut-être vrai, mais les heuristiques ne suffisent pas pour le prouver.)
	\item
		Il est important de comprendre comment cet algorithme gère les choix des clauses.
		L'algorithme fait parfois du retour en arrière (qui s'appelle {\em backtrack} en anglais) pour changer un choix.
		Chaque fois que l'on choisit une clause à unifier avec le début de la résolvante,
		cela marque un endroit où l'on peut faire un retour en arrière.
		Pour faire le retour en arrière,
		il remet ses structures de données internes ($r$ et $G$) à l'état avant le choix
		et il recommence son exécution à l'endroit du dernier choix.
		S'il n'y a plus de clauses possibles à ce choix,
		on revient à l'avant-dernier choix, et ainsi de suite.
		La gestion des choix est donc {\em récursive}.
		Il y a donc une {\em pile} de choix qui est gérée par l'algorithme.
		Pour simplifier la présentation, la gestion de cette pile n'est pas montrée dans la définition de l'algorithme.
		
		Si on arrive au tout premier choix qui a été fait quand on a commencé la boucle et il n'y a plus de clauses unifiables,
		alors on sort de la boucle avec une résolvante qui n'est pas vide. Et dans ce cas l'algorithme n'a pas trouvé de solution.
		Il y a donc deux manières de sortir de la boucle: (1) $r$ est vide, ou (2) il n'y a plus de choix.
		La première manière correspond à une exécution réussie.
		La deuxième manière correspond à un échec (``failure'').
		Attention, cet échec fait partie de l'algorithme d'exécution, il n'y a rien d'anormal à ce que l'algorithme sorte avec un échec.
	\item
		$$ sum( [], s, s) \land sum([x|l, s_1, s) \lor) \neg add(x, s_1, s_2) \lor \neg sum(l,s_2,s) $$
	\item
		$$G = < sum([5, 6], 0, s')> $$
	\item
		le premier littéral ne peut pas fonctionner, du coup on le passe
		$$ \sigma ={(x, 5), (l,[6]), (s_1, 0), (s',s)} $$
		$$ r=<add(5,0,s_2) \lor sum([6],s_2,s)>$$

		$$ \sigma ' = \sigma \cup {(s_2,5)} $$
		$$ r'=<sum([6],5,s)>$$
	\item
		on reprend la definition de sum et on fait un renommage $s_1=s_3, x=x_1, l=l_1, s_2=s_5$
		$$ \sigma '' = \sigma ' \cup {(s, s4), (x_1, 6), (l_1, nil), (s_3, 5) } $$
		$$ r'' = < add(6,5,s_5) \lor sum(nil, s_5, s_4)>$$

		$$\sigma '''= \sigma '' \cup {(s5,11)} $$
		$$ r''' = <sum (nil, 11, s_4)>$$

		on reprend la definition de sum et on fait un renommage $s=s_6$
		$$ \sigma '''' = \sigma ''' \cup {(s_6, 11), (s_4,s_6)}$$
		pour r toute la définition de sum sans le premier litéral, mais pas utile car r ne peut pas faire de pattern matching avec ce reste 

		On a donc $s=s_4=s_6=11$
	\end{enumerate}
	\end{solution}
    
\section{Mécanismes de similitude}
    \begin{enumerate}
        \item Définir le principe de similitude ainsi que 2 mécanismes.
        \item Expliquez la structure de Wikipédia pour montrer comment elle peut nous aider à faire cette comparaison.
        \item Donnez la similitude moyenne entre 2 rédacteurs Wikipédia trouvée par cette étude dans un graphe en fonction d'un paramètre significatif. Définissez ce paramètre. Définissez la formule qui donne la similitude entre 2 rédacteurs.
        \item Expliquez le résultat de cette étude faite avec Wikipédia. Comment peut-on distinguer les 2 mécanismes de similitude dans cette étude?
    \end{enumerate}
	\begin{solution}
	\begin{enumerate}
	\item
		La notion sociologique de similitude s'observe par une augmentation du nombre de liens entre les noeuds. 
		Exemple: Les étudiants de l'UCL présentent une similitude par le fait qu'ils font partie de la même université. 
		
		Ce principe implique de nouveaux mécanismes dans la manière où nous allons représenter les graphes:
		
		\begin{tabular}{lcp{7cm}}
		Sélection & $\longrightarrow$ & \textit{local} (Chacun choisi ses amis) \\
		Influence sociale & $\longrightarrow$ & \textit{global/extérieur} (Induite par les gens que l'on fréquente)
		\end{tabular}
		
		Exemple de la propriété d'influence sociale :\\ Le fait d'être dans le même auditoire qu'un autre individu peut constituer un lien dans le graphe.

	\item
		\begin{itemize}
		\item On a des rédacteurs
		\item Un lien entre deux rédacteurs : ils communiquent par la "Talk page" (chaque article a une "Talk page"). Autrement dit, si un rédacteur B communique sur la page de A, alors il y a un lien.
		\item Les "points d'intérêts" ici sont les articles.
		\end{itemize}

	\item
		Quantification de la similitude:
			$$\displaystyle\frac{\mbox{nombre d'articles rédigés par A ET B}}{\mbox{nombre d'articles rédigés par A OU B}}$$
		Notons dès lors que la similitude ne peut pas être plus petite que 0 ni plus grand que 1. $0 \leq sim \leq 1$

	\item
		Le moment de rupture est le moment où le lien est créé.
		On compare la similitude avant et après cette rupture. C'est surtout la sélection qui joue avant, car chaque rédacteur choisit ce qu'il doit ajouter ou modifier par rapport à ce qu'a mis l'autre rédacteur. Après la rupture, c'est principalement l'influence sociale qui entre en jeu car les deux rédacteurs mettent leurs idées en commun.
		

	\end{enumerate}
		
	\end{solution}
\end{document}
