
\section{}

\subsection{Exercise 0 (Commitment scheme and batching)}
% This practical session was entirely corrected by the teaching assistants so, there is no need to correct the solutions.

By design secure public-key encryption schemes are perfectly binding commitment schemes (which are also computationally hiding, why?).
Then, if perfect hiding property is not a concern, do commitment schemes really consist of a new usefull cryptographic building block?
This exercise aims to build a perfectly hiding commitment scheme which supports a \emph{batching} property that encryption schemes
cannot achieve.

Let $p$ be a prime and let $g \in QR(p)$ be an element of prime order $q>2^l$.
We let $G$ denote the group generated by $g$ and we let $I$ denote the set of integers $\{1,\dots, q\}$.
Fix $n$ random values $g_1,\dots, g_n \in G$ and define the commitment function $\Com\colon I^n \mapsto G$ by
\[\Com(x_1,\dots, x_n\,; r) = g^r g_1^{x_1}g_2^{x_2}\cdots g_n^{x_n}\]
\begin{enumerate}
	\item Describe formally the commitment scheme. Discuss its efficiency and its correctness.
	\item Show that the scheme is computationally binding assuming that DLog is intractable in $G$.
	That is, show that an adversary computing two openings of a commitment $c$ for random
	$g,g_1,\dots, g_n \in G$ can be used to compute discrete-log in $G$.

	\emph{Hint:} given a pair $g, h \in G$ your goal is to find an $\alpha \in \mathbb{Z}_q$ such that $g^\alpha = h \mod p$.
	Choose $g_1,\dots, g_n \in G$ so that two valid openings will reveal $\alpha$.
	\item Show that the scheme results in a perfectly hiding commitment on several messages. Compare the size of the construction
	with respect to an encryption (viewed as a commitment) of all these messages.
\end{enumerate}


\begin{solution}
	\begin{enumerate}
		\item
		We define $\Pi\define\langle \Gen, \Com, \Open \rangle$ as:
		\begin{itemize}
			\item $\Gen(1^n, 1^l)$ sets $pk$ as $(p,q,g)$ where $q > 2^l$ ang $g$ has order $q$ modulo $p$ (since $\phi(p)$ is even, that means that $g \in QR(p)$).
			\item $\Com_{pk}(x_1, \ldots, x_n)$ provides $(c,d)$ where:
			\begin{itemize}
				\item $c \define g^r g_1^{x_1} g_2^{x_2} \cdots g_n^{x_n}$ (for a random $r \in \Z_q$)
				\item $d \define (r,x_1,\dots,x_n)$
			\end{itemize}
			\item $\Open_{pk}(c,d)$ outputs $(x_1, \dots, x_n)$ if it can recompute $c$ from $d$ and $pk$,
			or $\bot$ otherwise.
		\end{itemize}
		We can see that there are different possible $x_1, \dots, x_n$ that are valid.
		If we fix $x_2, \dots, x_n$,
		there is an $x_1$ such that $g_1^{x_1} = c / (g^r g_2^{x_2} \cdots g_n^{x_n})$
		so there is $q^n$ possible opening.
		However, it is not easy to find for a PPT algorithm.

		I should maybe have defined $d \define (r, x_1, \dots, x_n)$ because here it is weird because $\Open$ can have different outputs.
		\item %\textcolor{red}{Olivier : pas trop d'accord avec ce qu'ils disent.}

		For two random $g, h$, we need to find $x$ such that $g^x=h$.
		For this task, we have access to an adversary $\A_\Pi$ against our scheme $\Pi$ that can find $(c, d_0, d_1)$ with different $(c, d_0)$ and $(c, d_1)$ that have valid openings.

		Pick a random $j$ and set $g_{i} = h = g^x$ if $i=j$, or $g_i = g^{\alpha_i}$ for random $\alpha_i$ if $i\neq j$.
		We need to pick a random $j$ so that $\A_\Pi$ has no idea where we've put the $h$ (the adversary may also be adversarious against us!).
		From the point of view of $\A_\Pi$, everything looks like it should.
		From $c = g^rg_1^{x_1} \cdots g_n^{x_n} = g^{r'}g_1^{x_1'} \cdots g_n^{x_n'}$, and $d_0=(r, x_1, \dots, x_n)$ and $d_1=(r', x'_1, \dots, '_n)$ generated by $\A_\Pi$, we get
		\[ r + \alpha_1 x_1 + \dots + x x_j + \dots + \alpha_n x_n \equiv r' + \alpha_1 x_1' + \dots + x x_j' + \dots + \alpha_n x_n' \pmod{q} \]
		so we get
		\[ x \equiv \frac{ r' - r + \sum_{i=1\\i \neq j}^n (x_i' - x_i) \alpha_i}{x_j-x_j'} \pmod{q} \]
		We know that for at least one $i^*$, $x_i \neq x_i'$ so we have $\frac{1}{n}$ chance that $i^*=j$ and $x_{j} \not\equiv x_{j}' \pmod{q}$.
		If this is the case, we can find the inverse of $(x_{j} - x_{j}')$ and solve the $\DLog$ problem.

		\item
		As r is randomly selected in $\Z_q$ and g generates G, $g^rg_1^{x_1} \dots g_n^{x_n}$ could be any element of G, whatever the values of ($g_1,\dots,g_n$) and ($x_1,\dots,x_n$) so the commitment looks random and is thus perfectly hiding.

		The size is $n$ times smaller.
		However, there is a difference in the ``negligibility level'' of the two constructs.
		We may thus need a bigger group for this scheme than for a standard encryption scheme in $QR_p$.
	\end{enumerate}
\end{solution}



\subsection{Exercise 1 (Jan 2011 evaluation)}
% This practical session was entirely corrected by the teaching assistants so, there is no need to correct the solutions.

The Digital Signature Standard (DSS, also often called DSA) is one of
the most commonly used signature algorithms. Its three algorithms
$\Gen$, $\mathsf{Sign}$ and $\Vrfy$ work as follows.
\begin{itemize}
	\item $\Gen$: on input $1^n$, select prime integers $p$ and $q$ such
	that $|q|=n$, $q | (p-1)$ and $q^2 \not | \, (p-1)$, together with an
	integer $g$ that generates the subgroup of $\Z_p^*$ of prime
	order $q$. Also choose a hash function $H\colon \bset^* \mapsto
	\Z_q$. Then, select $x \pick \Z_q$ uniformly at
	random, and compute $y \define g^x \mod p$. The public key is $\langle H,
	p, q, g, y\rangle$, and the private key is $\langle x\rangle$.
	\item $\Sign$: in order to sign the message $m \in \{0,1\}^*$, choose
	$k \pick \Z_q^*$ uniformly at random and set $r \define [g^k
	\mod p] \mod q$. Then, compute $s \define (H(m) + xr) \cdot k^{-1} \mod
	q$, and output the signature $(r,s)$.
	\item $\Vrfy$: compute $u_1 \define H(m)\cdot s^{-1} \mod q$ and $u_2 \define r
	\cdot s^{-1} \mod q$, and output 1 if and only if $r = [g^{u_1} y^{u_2} \mod p] \mod q$.
\end{itemize}

\begin{enumerate}
	\item Show the correctness of the DSS algorithm.
	\item
	As randomness is an expensive resource, it is proposed to select
	the random value $k$ once and for all, and to sign all messages
	using that value of $k$. Is this variant of DSS secure?

	\emph{(Hint: see what you can deduce from the signature of two
		different messages.)}
\end{enumerate}


\begin{solution}
	\begin{enumerate}
		\item We show the correctness (if the signature is well formed, it is accepted).
		\begin{align*}
			[g^{u_1} y^{u_2} \mod p] \mod q = &[g^{H(m)\cdot s^{-1}} (g^x)^{r
				\cdot s^{-1}} \mod p] \mod q,\\
			= &[g^{(H(m)+rx)	\cdot s^{-1}} \mod p] \mod q,\\
			= &[g^{k} \mod p] \mod q,\\
			= &r .
		\end{align*}

		\item As the same $k$ was used for two signatures, we have the valid signatures $(r,s_1)$ where $s_1 \define (H(m_1) + xr) \cdot k^{-1} \mod
		q$ and $(r,s_2)$ where $s_1 \define (H(m_2) + xr) \cdot k^{-1} \mod
		q$. Now, we consider the quotient of $s_1$ divided by $s_2$ (the operations are modulo $q$), in order to cancel the part depending on $k$, note that we can do it with two signatures only because the same $k$ is reused:
		\[\frac{s_1}{s_2}=\frac{(H(m_1) + xr) \cdot k^{-1}}{(H(m_2) + xr) \cdot k^{-1}}=\frac{H(m_1) + xr}{H(m_2) + xr} .\]
		This is equivalent to: $s_1 (H(m_2) + xr)= s_2 (H(m_1) + xr)$, then:
		\[xr= \frac{s_1 H(m_2) - s_2 H(m_1)}{s_2-s_1}.\]
		Finally, dividing by $r$ we get $x$ which is the secret key. As with non negligible probability (when the denominators are non null we can perform the operations described below) we can get $x$ and sign any other message, this variant of DSS is non secure.
	\end{enumerate}

	Alternative solution:

	\begin{enumerate}
		\item
		$(r, s) = ([g^k \pmod{p}] \pmod{q}, [H(m) + xr]k^{-1} \pmod{q})$, then:
		$u_1 = H(m)s^{-1} \pmod{q}$,  $u_2 = rs^{-1} \pmod{q}$, $r = [g^{u_1} g^{u_2} \pmod{p}] \pmod{q}$, $y = g^x$

		\[\Rightarrow g^{u_1 + xu_2} = g^{s^{-1}(H(m) + rx)} = [g^k \pmod{p}] \pmod{q} = r\]

		\item
		$s = (H(m) + xr)k^{-1} \pmod{q}$, $s' = (H(m') + xr)k^{-1} \pmod{q}$ ($s \neq s'$ otherwise we have a collision).
		$s - s' = (H(m) - H(m'))k^{-1} \pmod{q}$, $k = \frac{H(m) - H(m')}{s - s'}$.
		$s = (H(m) + xr)k^{-1}$ so $\frac{sk - H(m)}{r} = x$ where x is the secret.
	\end{enumerate}
\end{solution}



\subsection{Exercise 2 (RSA permutation with modulus 221)}

Suppose we decide to use an RSA permutation with modulus $221$, we consider RSA encryption scheme, and RSA signature.
\begin{enumerate}
	\item What is the smallest non trivial public exponent $e$ than can be
	chosen?
	\item Can we choose $e=11$? What is the corresponding private exponent $d$? Give the public and private key of the corresponding RSA encryption scheme.
	\item Compute $c \define 219^e \pmod{221}$.
	\item Verify that $c^d = 219 \pmod{221}$ as expected.
	\item How Alice (owning the private key) could sign a message $m$? Sign the message $m=3$ (hint: $22^7= 61 \pmod{221}$).
	\item Is $160$ a valid signature for $m=218$?
	% \emph{Hint: use the square and multiply algorithm.}
\end{enumerate}


\begin{solution}
	We suggest you to use a calculator to do this exercise, the assistants said we could (pour faire taire les rageux).
	\begin{enumerate}
		\item

		First we have to find $\phi$(221). As 221 is not a prime, we must find $p$ and $q$ such that $221 = pq$. After a few try, we find $p = 13$ and $q = 17$. Wet get then $\phi(221) = (p-1)(q-1) = 192$.

		The searched smallest $e$ should respect the condition $gcd(192, e) = 1$. Again, after a few try, we find $e = 5$.
		\item \textbf{Could we choose $e = 11$ ?}

		Yeah, since 11 is a prime, then $gcd(192, 11) = 1$.

		\textbf{What is the corresponding private exponent d ?}
		\[ ed = 1 \pmod{192}\] \[11d = 1 \pmod 192\] \[d = \frac{192k + 1}{11}\]
		If we take k=2, we find $d = 35$.

		\textbf{Give the public and private key of the corresponding RSA encryption scheme}

		pk = $(221, 11)$
		sk = $(221, 35)$
		\item
		\begin{itemize}
			\item $219^{1} = -2 $
			\item $219^{2} = 4  $
			\item $219^{4} = 16 $
			\item $219^{5} = -32$
			\item $219^{10} = 140$
			\item $219^{11} = 162$
		\end{itemize}
		\item
		\begin{itemize}
			\item $162^{1} = -59 $
			\item $162^{2} = -55 $
			\item $162^{4} = -69 $
			\item $162^{5} = 93 $
			\item $162^{6} = 38 $
			\item $162^{7} = -32 $
			\item $162^{35} = -2 = 219 $
		\end{itemize}
		\item

		According the scheme described in the slides, $\Sign_{(N, d)}(m) \define [m^d mod N]$

		\textbf{Sign the message m = 3}
		\begin{itemize}
			\item $3^{1} = 3 $
			\item $3^{2} = 9 $
			\item $3^{4} = 81 $
			\item $3^{5} = 22 $
			\item $3^{35} = 61 $ (using the hint given)
		\end{itemize}
		\item
		Let's calculate (yipie)
		\begin{itemize}
			\item $218^{1} = -3 $
			\item $218^{2} = 9 $
			\item $218^{4} = 81 $
			\item $218^{5} = -22 $
			\item $218^{35} = -61 = 160$
		\end{itemize}
		Yes it is a valid signature
	\end{enumerate}
\end{solution}



% OK
\subsection{Exercise 3 (Derandomizing signatures)}

\copypaste{10}{2}



% OK
\subsection{Exercise 4}

Let $f$ be a one-way permutation on $\bset^\lambda$.
Consider the following signature scheme for messages in the set
$\{1,\dots,\,n\}$, where $n\in\mathsf{poly}(\lambda)$: \vspace{3mm}

\begin{enumerate}
	\item To generate keys, choose $x\pick \bset^\lambda$ at random
	and set $y \define f^n(x)$. The public key is $y$ and the private key is $x$.
	\item To sign message $i\in\{1,\dots,\,n\}$, output $f^{n-i}(x)$
	(where $f^0(x)\stackrel{\mbox{\small def}}{=}x$).
	\item To verify signature $\sigma$ on message $i$ with respect to
	public key $y$, check whether $y\stackrel{?}{=}f^i(\sigma)$.
\end{enumerate}

\begin{enumerate}
	\item Show that the above is not a one-time signature scheme. Given
	a signature on a message $i$, for what messages $j$ can an
	adversary output a forgery?
	\item Prove that no PPT adversary given a signature on $i$
	can output a forgery on any message $j>i$ except with negligible
	probability.
	\item Suggest how to modify the scheme so as to obtain a one-time
	signature scheme.

	\emph{Hint: include two values $y,\,y'$ in the public key.}
\end{enumerate}


\begin{solution}
	\begin{enumerate}
		\item
		A has $(i, \sigma(i))$ with $\sigma (i) = f^{n-i} (x)$. We know (because $f$ is a permutation function) that:
		\[f(\sigma(i)) = f^{n-i+1}(x) = f^{n-(i-1)}(x) = \sigma(i-1)\]
		Then it's possible to compute a valid forgery for every $j < i$. The scheme is then not a one time-signature.
		\item
		Need schema drawn at TP !! It's a lot simpler with it\dots

		$\Pr[\text{Success}_{\A_\sigma}] = \negl(\lambda)$, $\Pr[\text{Abort}] = \frac{n-k}{n}$, $\Pr[\text{Success}] = \frac{n-k}{n-m-1}$ then:
		\[\Pr[\text{Success}_{\A_{owf}}] = \negl(\lambda) \frac{n-k}{n} \frac{n-k}{n-m-1}\]

		If $\negl(\lambda)$ is not negligible, then the probability of success is not negligible.
		\item
		We have $s_k = (x, x')$, $p_k = (f^n(x), f^n(x'))$.
		Then $m \rightarrow \sigma = (f^{n-m}(x), f^m(x'))$.

	\end{enumerate}
\end{solution}



\subsection{Exercise X (Jan 2011 evaluation)}

Consider the following one-time signature scheme $\Pi \define \langle \Gen,
\Sign, \Vrfy\rangle$, parameterized by a PPT function $f\colon \bset^*
\mapsto \bset^*$.
\begin{itemize}
	\item $\Gen$: on input $1^n$, select $(x_0,x_1) \leftarrow
	\bset^n\times \bset^n$ uniformly at random, compute $(y_0,y_1) \define
	(f(x_0),f(x_1))$ and output the pair $(pk,sk) \define
	((y_0,y_1),(x_0,x_1))$.
	\item $\Sign$: the signature $\sigma$ of the bit $m$ is $x_m$.
	\item $\Vrfy$: on input $(m,\sigma)$, output 1 iff $y_m = f(\sigma)$.
\end{itemize}

Show that if $\Pi$ is existentially unforgeable under a single-message
attack, then $f$ is a one-way function.


\begin{solution}
	Two solution have been proposed. (Actually they are the same but with a different explanation)
	\begin{itemize}
		\item
		Let's show that if $f$ is not one way, then $\Pi$ is not existentially unforgeable.
		Let $\A$ be the inverter of $f$, we will build $\A'$ that builds an existential forgery with non-negligible probability.

		\begin{itemize}
			\item $\A'$ receives $pk = (y_0, y_1)$
			\item $\A'$ ask the signature of 0 and gets $\sigma$, he does not really care about it
			\item $\A'$ gives $y_0$ (or $y_1$) to $\A$ which outputs $x_0$ (or $x_1$) with non-negligible probability.
			\item $\A'$ outputs $(0,x_0)$ (or $(1, x_1)$)
		\end{itemize}
		Since $y_1$ is the image of a random $x_1$, we are exactly in the inverting experiment so $f(x_1') = y_1$
		with probability $\Pr[\Invert_{\A,f}(n) = 1]$.

		We know that
		\[
		\Pr[\Sigforgeone_{\A',\Pi}(n) = 1] = \Pr[\Invert_{\A,f}(n) = 1]
		\]
		\item
		Let assume that $f$ is not one way function $y = f(x)$.
		Then, we can recover $x$ with a non negligible probability $\epsilon_x (n)$.

		So, $(y_0, y_1) \Rightarrow (x_0, x_1)$ with probabilities $(\epsilon_{x_0} (n), \epsilon_{x_1} (n))$.
		We cannot compute a pre-image by asking the oracle. So I output $(0, x_0)$ and $(1, x_1)$ as a forgery.

		The probability $\Pr[\Sigforge_{\A,\Pi}(n)=1]= \Pr[f^{-1}(\cdot)_{Inv,f(\cdot)}(n)=1] \leq \epsilon(n)$. As $\Pi$ is supposed to be existentially unforgeable under a single-message attack, then $\epsilon(n)$ is negligible and this implies that f is a one-way function.
	\end{itemize}
\end{solution}


