
\section{}
\subsection{Exercise 0 (A variation of ElGamal in \texorpdfstring{$PKE$}{PKE})}
\copypaste{4}{4}

\subsection{Exercise 1 (Commitment scheme)}
\copypaste{4}{7}

\subsection{Exercise 2}
By design secure public-key encryption schemes are perfectly binding commitment schemes (which are also computationally hiding, why?). 
Then, if perfect hiding property is not a concern, do commitment schemes really consist of a new usefull cryptographic building block? 
This exercise aims to build a perfectly hiding commitment scheme which supports a \emph{batching} property that encryption schemes
cannot achieve. \medskip \\
Let $p$ be a prime and let $g \in QR(p)$ be an element of prime order $q>2^l$. 
We let $G$ denote the group generated by $g$ and we let $I$ denote the set of integers $\{1,\dots, q\}$. 
Fix $n$ random values $g_1,\dots, g_n \in G$ and define the commitment function $\Com : I^n \rightarrow G$ by 
$$\Com(x_1,\dots, x_n\,; r) = g^r g_1^{x_1}g_2^{x_2}\cdots g_n^{x_n}$$
\begin{enumerate}
  \item Describe formally the commitment scheme. Discuss its efficiency and its correctness.
	\item Show that the scheme is computationally binding assuming that DLog is intractable in $G$. 
	      That is, show that an adversary computing two openings of a commitment $c$ for random 
				$g,g_1,\dots, g_n \in G$ can be used to compute discrete-log in $G$.\\
				\emph{Hint:} given a pair $g, h \in G$ your goal is to find an $\alpha \in \mathbb{Z}_q$ such that $g^\alpha = h \mod p$. 
				             Choose $g_1,\dots, g_n \in G$ so that two valid openings will reveal $\alpha$.
	\item Show that the scheme results in a perfectly hiding commitment on several messages. Compare the size of the construction
	      with respect to an encryption (viewed as a commitment) of all these messages.
\end{enumerate}


\begin{solution}
  \begin{enumerate}
    \item
      We define $\langle \Gen, \Com, \Open \rangle$ as:
      \begin{itemize}
        \item $\Gen(1^n, 1^l)$ sets $pk$ as $(p,q,g)$ where $q > 2^l$ ang $g$ has order $q$ modulo $p$ (since $\phi(p)$ is even, that means that $g \in QR(p)$).
        \item $\Com_{pk}(x_1, \ldots, x_n)$ provides $(c,d)$ where:
          \begin{itemize}
            \item $c := g^r g_1^{x_1} g_2^{x_2} \cdots g_n^{x_n}$ (for a random $r \in \mathrm{Z}_q$)
            \item $d := r,x_1,...,x_n$
          \end{itemize}
        \item $\Open_{pk}(c,d)$ outputs $x_1, \ldots, x_n$ if it can recompute $c$ from $d$ and $pk$,
          or $\perp$ otherwise.
      \end{itemize}
      We can see that there are different possible $x_1, \ldots, x_n$ that are valid.
      If we fix $x_2, \ldots, x_n$,
      there is an $x_1$ such that $g_1^{x_1} = c / (g^r g_2^{x_2} \cdots g_n^{x_n})$
      so there is $q^n$ possible opening.
      However, it is not easy to find for a PPT algorithm.

      I should maybe have defined $d := (r, x_1, \ldots, x_n)$ because here it is weird because $\Open$ can have different outputs.
    \item %\textcolor{red}{Olivier : pas trop d'accord avec ce qu'ils disent.}
    
      For a random $\alpha$, we need to find it from $g^\alpha$.

      Pick a random $i^*$ and set $g_{i^*} = g^\alpha$ and for $i \neq i^*$, random $\alpha_i$ and $g_i = g^{\alpha_i}$.
      From $g^rg_1^{x_1} \cdots g_n^{x_n} = g^{r'}g_1^{x_1'} \cdots g_n^{x_n'}$ we get
      \[ r + \alpha_1 x_1 + \cdots + \alpha_n x_n \equiv r' + \alpha_1 x_1' + \cdots + \alpha_n x_n' \pmod{q} \]
      so we get
      \[ (x_{i^*} - x_{i^*}') \alpha \equiv r' - r + \sum_{i \neq i^*}^n (x_i' - x_i) \alpha_i \pmod{q} \]
      We know that at least one $x_i \neq x_i'$ so we have at least one chance out of $q$ that $x_{i^*} \not\equiv x_{i^*}' \pmod{q}$.
      If this is the case, we can find the inverse of $(x_{i^*} - x_{i^*}')$ and solve the $\DLog$ problem.
    \item
      As r is randomly selected in $\mathrm{Z}_q$ and g generates G, $g^rg_1^{x_1}...g_n^{x_n}$ could be any element of G, whatever the values of ($g_1,...,g_n$) and ($x_1,...,x_n$) so the commitment looks random and is thus perfectly hiding.

      The size is $n$ times smaller.
  \end{enumerate}
\end{solution}

\subsection{Exercise 3 (Zero knowledge Petersen)}
The Schnorr protocol, used to prove the knowledge of discrete
logarithm, is (honest-verifier) zero-knowledge. However, the value
$y=g^x \pmod{p}$ (for a safe prime $p=2q+1$) leaks some information
about the discrete logarithm $x$ (since for a given generator $g$ of
order $q$ there is exactly one such $x$ in $\mathbb{Z}_q$). On the
other hand, the Pedersen commitment is perfectly hiding and thus does
not reveal information about the committed value. The following
protocol attempts to merge the both properties i.e., to prove the
knowledge of a commited value under the Pedersen commitment scheme in
a zero-knowledge manner.
\\
\indent \emph{The protocol.} The public inputs of the proof are the prime $p$,
the Pedersen public key $(g, h)$, a security parameter $k$ and a
(hypothetic) commitment $c\in QR(p)$. The prover's private intputs are
$x$ and $r$ in $\mathbb{Z}_q$ s.t. $c=g^xh^r$ (mod $p$). The protocol executes as follows. 
\begin{itemize}
	\item The prover randomly chooses $y,s \in_R \mathbb{Z}_q$ and sends $d=g^yh^s  \pmod{p}$ to the verifier.
	\item The verifier randomly chooses $e\in_R \{0,1\}^k$ and sends it to the prover.
	\item The prover computes $z=y-ex$ and  $t=s-er$ modulo $q$ and sends it to the verifier.
	\item The verifier accepts the proof iff $d = c^e g^zh^t
          \pmod{p}$.
\end{itemize}
If the verifier accepts the proof, we say that the conversation $\langle d,e,(z,t) \rangle$ is valid.
%
\begin{enumerate}
	\item Prove the correctness property of this construction.
	\item Assume you are able to ``rewind'' an adversarial prover
          who tries to build a valid conversation. How can you use
          this faculty to extract an opening of $c$. Which property
          did you break ? Briefly discuss the soundness property of
          the protocol.

          	\item Show how a valid conversation $\langle
          d,e,(z,t) \rangle$ can be simulated from $c$, without the use of any
          private inputs. (Assume that the valid conversation involves
          honest parties.)
	\item Generalize the process to prove the knowledge of an opening to 
	        a multi-Pedersen commitment as in exercise 2.
\end{enumerate}

\begin{solution}
  \begin{enumerate}
      \item The conversation is correct if Pr[$d \neq c^eg^zh^t$] $\leq \epsilon(n)$. Let's evaluate this probability : 
      $$Pr[d \neq c^eg^zh^t] = Pr[g^yh^s \neq g^{xe+z}h^{re+t}]  = Pr[g^yh^s \neq g^{xe+z}h^{re+t}] = 0$$
      Then our construction is correct.
      \item When we get the conversation (d, e, (z,t)), we can "rewind" the conversation to submit another e' and get new z' and t'. Therefore we can obtain the private key (x,r) by doing those calculations :
      $$\begin{cases} z = y - ex \\ z' = y - e'x \end{cases} \Rightarrow x = \frac{z-z'}{e'-e}
      $$
      $$\begin{cases} t = s - er \\ t' = s - e'r \end{cases} \Rightarrow r = \frac{t-t'}{e'-e}
      $$
      We broke the zero-knowledge property since the verifier can extract the private key using such power. \newline
      According to the assistants, since it is not zero-knowledge, there is no point of discussing the soundness property.
      \item It is easy to show, with honest parties, how we can simulate from $c$ a new valid conversation : 
      \begin{enumerate}
          \item We pick e 
          \item We pick z and t
          \item We evaluate d as : $d = c^ez^zh^t$
      \end{enumerate}
      \item To generalize the process, we have : 
      \begin{itemize}
          \item pk = $g^x_1$, ..., $g^x_n$, h
          \item sk = $x_1$, ..., $x_n$, r
          \item c = $g^x_1 \cdot ... \cdot g^x_n \cdot h^r$
      \end{itemize}
  \end{enumerate}
\end{solution}

\subsection{Exercise 4}
\label{subsec:4b.4}
Let $f$ be a one-way permutation on $\{0,\,1\}^\lambda$. 
Consider the following signature scheme for messages in the set 
$\{1,\ldots,\,n\}$, where $n\in\mathsf{poly}(\lambda)$: \vspace{3mm}

\begin{enumerate}
	\item[\textbullet] To generate keys, choose $x\leftarrow \{0,\,1\}^\lambda$ at random
	      and set $y:=f^n(x)$. The public key is $y$ and the private key is $x$.
	\item[\textbullet] To sign message $i\in\{1,\ldots,\,n\}$, output $f^{n-i}(x)$
	      (where $f^0(x)\stackrel{\mbox{\small def}}{=}x$).
	\item[\textbullet] To verify signature $\sigma$ on message $i$ with respect to
	      public key $y$, check whether $y\stackrel{?}{=}f^i(\sigma)$. 
\end{enumerate}

\begin{enumerate}
	\item Show that the above is not a one-time signature scheme. Given
	      a signature on a message $i$, for what messages $j$ can an 
	      adversary output a forgery?
	\item Prove that no \texttt{PPT} adversary given a signature on $i$
	      can output a forgery on any message $j>i$ except with negligible
	      probability.
	\item Suggest how to modify the scheme so as to obtain a one-time 
	      signature scheme. \\
	      \emph{Hint: include two values $y,\,y'$ in the public key.}
\end{enumerate}
\begin{solution}
  \begin{enumerate}
    \item
      A has $(i, \sigma(i))$ with $\sigma (i) = f^{n-i} (x)$. We know (because $f$ is a permutation function) that:
      $$f(\sigma(i)) = f^{n-i+1}(x) = f^{n-(i-1)}(x) = \sigma(i-1)$$
      Then it's possible to compute a valid forgery for every $j < i$. The scheme is then not a one time-signature.
    \item
      Need schema drawn at TP !! It's a lot simpler with it...

      $\Pr[Success (\A_\sigma)] = \epsilon(\lambda)$, $\Pr[Abort] = \frac{n-k}{n}$, $\Pr[Success] = \frac{n-k}{n-m-1}$ then:
      $$ \Pr[Success(\A_{owf})] = \epsilon(\lambda) \frac{n-k}{n} \frac{n-k}{n-m-1}$$

      If $\epsilon(\lambda)$ is not negligible, then the probability of success is not negligible.
    \item
      We have $s_k = (x, x')$, $p_k = (f^n(x), f^n(x'))$.
      Then $m \rightarrow \sigma = (f^{n-m}(x), f^m(x'))$.

  \end{enumerate}
\end{solution}


\subsection{Exercise 5 (Jan 2011 evaluation)}
\label{subsec:4b.5}
Consider the following one-time signature scheme $\Pi:=\langle \Gen,
\mathsf{Sign}, \Vrfy\rangle$, parameterized by a PPT function $f: \{0,1\}^*
\rightarrow \{0,1\}^*$.
\begin{itemize}
\item $\Gen$: on input $1^n$, select $(x_0,x_1) \leftarrow
  \{0,1\}^n\times \{0,1\}^n$ uniformly at random, compute $(y_0,y_1) :=
  (f(x_0),f(x_1))$ and output the pair $(pk,sk):=
  ((y_0,y_1),(x_0,x_1))$.
\item $\mathsf{Sign}$: the signature $\sigma$ of the bit $m$ is $x_m$.
\item $\Vrfy$: on input $(m,\sigma)$, output 1 iff $y_m = f(\sigma)$.
\end{itemize}

Show that if $\Pi$ is existentially unforgeable under a single-message
attack, then $f$ is a one-way function.
\begin{solution}
  Two solution have been proposed. (Actually they are the same but with a different explanation)
  \begin{itemize}
    \item
      Let's show that if $f$ is not one way, then $\Pi$ is not existentially unforgeable.
      Let $\A$ be the inverter of $f$, we will build $\A'$ that builds an existential forgery with non-negligible probability.

      \begin{itemize}
        \item $\A'$ receives $pk = (y_0, y_1)$
        \item $\A'$ ask the signature of 0 and gets $\sigma$, he does not really care about it
        \item $\A'$ gives $y_0$ (or $y_1$) to $\A$ which outputs $x_0$ (or $x_1$) with non-negligible probability.
        \item $\A'$ outputs $(0,x_0)$ (or $(1, x_1)$)
      \end{itemize}
      Since $y_1$ is the image of a random $x_1$, we are exactly in the inverting experiment so $f(x_1') = y_1$
      with probability $\Pr[\Invert_{\A,f}(n) = 1]$.

      We know that
      \[
        \Pr[\Sigforgeone_{\A',\Pi}(n) = 1] = \Pr[\Invert_{\A,f}(n) = 1]
      \]
    \item
      Let assume that $f$ is not one way function $y = f(x)$.
      Then, we can recover $x$ with a non negligible probability $\epsilon_x (n)$.

      So, $(y_0, y_1) \Rightarrow (x_0, x_1)$ with probabilities $(\epsilon_{x_0} (n), \epsilon_{x_1} (n))$.
      We cannot compute a pre-image by asking the oracle. So I output $(0, x_0)$ and $(1, x_1)$ as a forgery.

      The probability $\Pr[\Sigforge_{\A,\Pi}(n)=1]= \Pr[f^{-1}(\cdot)_{Inv,f(\cdot)}(n)=1] \leq \epsilon(n)$. As $\Pi$ is supposed to be existentially unforgeable under a single-message attack, then $\epsilon(n)$ is negligible and this implies that f is a one-way function.
  \end{itemize}
\end{solution}