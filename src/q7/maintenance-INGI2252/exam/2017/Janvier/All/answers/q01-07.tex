6\section{Define and explain, in your own words, the difference between
software maintenance and software evolution.}

\textbf{Software maintenance} is the process of modifying a software system or component \textit{after delivery}, to correct faults, improve performances or other attributes, or adapt to a changed environment. \\

\textbf{Software evolution} is \enquote{any activity} (not only programming, could be software development) that is intended to generate a new software version from an earlier operational version.  (teacher does not like def on slide 36)\\

\textit{Software maintenance} typically does not involve major changes to the system's architecture. Changes are implemented by modifying existing components and adding new (small) components to the system. \textit{Software evolution} is broaded, it includes software maintenance and bigger changes, at different phases of the software life-cycle.\\

The main difference lies in how big the changes will be. In maintenance, the changes are \textbf{smaller} and more local. In evolution, the changes are much \textbf{bigger} and more general.

\section{List and explain the different types of software maintenance.
Given a particular maintenance activity, be able to classify it by its type
(adaptive, corrective, perfective or preventive maintenance)
(proactive or reactive, correction or enhancement)}

Different types of maintenance can be distinguished, depending on the goal of the maintenance activity:
\begin{itemize}
\item \textbf{Adaptive} maintenance: Software maintenance performed to make a computer program usable in a changed environment. It occurs when, as a result of external influences or strategic changes, a software system needs to be adapted to remain up to date. The purpose is to adapt to changes in the environment (either hardware or software). Example: An insurance company decides to offer a new kind of insurance.
\item \textbf{Corrective} maintenance: Software maintenance performed to correct faults in hardware or software. It often occurs after deployment, when the customers detect problems that were not discovered during the inital testing of the system. The purpose is to correct errors that cause the software to behave in undesired or unexpected ways.
\item \textbf{Perfective} maintenance: Software maintenance performed to improve performance, maintainability or other attributes of a computer program. It occurs after the system has been in place and running for a while, and end users start asking for minor tweaks improvements that could improve how the system works. The purpose is to improve the quality of the software system. Examples: better input forms, shortcut commands, better help system or error reporting, making the system more responsive, ...
\item \textbf{Preventive} maintenance: Software maintenance performed for the purpose of preventing problems before they occur. The purpose is to proactively change the software to avoid having bugs in the future.
\end{itemize}

Classify the types of software maintenance, in terms of when and why to apply a type of maintenance.\\

\begin{table}[!ht]
\centering
\begin{tabular}{|l|c|c|}
   \hline
   \diagbox{When?}{Why?} & \textbf{Correction} & \textbf{Enhancement} \\
   \hline
   \textbf{Proactive} & Preventive & Perfective \\
   \hline
   \textbf{Reactive} & Corrective & Adaptive \\
   \hline
\end{tabular}
\end{table}

\section{Discuss the need for and possible reasons for software maintenance, change and evolution.}

Let us see what are the reasons for software maintenance, change, and evolution:
\begin{itemize}
\item \textbf{Changed user requirements (42 \%)}: The user/customer asks for specific extensions and modifications
\item \textbf{Bug fixes (21\%)}: Either scheduled team gathering to fix bugs if some exist, or unexpected emergency fixes (more costly due to heavy pressure)
\item \textbf{Changed data formats (18\%)}: Changes in Euro, tax rates, postal codes, phone numbers, etc. Or New standards: UML, XML, COM, DCOM, CORBA, ActiveX, WAP
\item \textbf{Hardware changes(6\%)}: technology change or improvement
\item \textbf{Efficiency improvements(4\%)}
\end{itemize}


\section{Give some main causes of maintenance problems.}

\begin{itemize}
\item \textit{Poor quality of software documentation}
\item \textit{Poor software quality}: unstructured code, too large components, inadequate design
\item \textit{Insufficient knowledge about the system and its domain}: However it may be unavailable due to personnel turnover (=rotation des employ√©s: des membres qui partent et des nouveaux qui arrivent)
\item \textit{Ineffectiveness of maintenance team}: low productivity, low motivation, low skill levels, competing demands for programmer time
\end{itemize}


\section{Define and explain, in your own words, what technical debt is.}

\begin{mydef}[Technical debt]
\enquote{Technical debt is the extra development work that arises when code that is easy to implement in the short run is used instead of applying the best overall solution}
\end{mydef}

In other words, it is like taking a financial loan on our software. We tell ourselves: \enquote{I do this in this specific (and not optimal) way, but I will come back later on it because it is not perfect}. This loan induces a loss of time in the future. \\

The technical debt can then create accumulated interest. The longer you wait to make the changes, the harder it becomes, and the more time-consuming it is.

\section{What different types of software evolution can be distinguished?}

Different types of evolution can be distinguished according to the mechanism of how evolution is achieved:
\begin{itemize}
\item \textbf{Manual}: changes applied manually by a software developer
\item \textbf{Generic}: write sufficiently generic and abstract components that are broadly adaptable
\item \textbf{Generation}: generate lower-level representation from a higher-level specification of software. Also known as \textit{vertical transformation}, or \textit{refinement}: from more abstract to more concrete
\item \textbf{Transformation}: old components are transformed into a newer version. Also known as \textit{Horizontal transformation}, or \textit{restructuring}: transformation at the same level of abstraction
\item \textbf{Configuration}: different variants of software components are available  up front but the actual selection of which one to use is based on a desired configuration. Ex: software product lines, Software as a Service, context-oriented programming, ...
\end{itemize}

\section{Given one of the laws (1, 2, 6 or 7) of software evolution, be able to explain it.}

\begin{itemize}
\item \textbf{Law 1 - Continuing changes}: A program that is used in a real-world environment must be continually adapted, or else it becomes less satisfactory. \textit{Reasons}: The evolution of the environment, and the continuous need for a change because the requirements and the environment are continuously evolving.
\item \textbf{Law 2 - Increasing Complexity}: As a program is evolved, its complexity increased with time unless specific work is done to maintain or reduce it (the complexity). \textit{Reasons}: Unadressed technical debt increases entropy (= disorder). Small changes are applied in a step-wise process: each \enquote{patch} makes sense locally but not globally. Effort needed to take care of the accumulated technical debt, a more significant restructuring or refactoring may be needed
\item \textbf{Law 6 - Continuing growth}: Functional content of a program must be continually increased to maintain user satisfaction over its lifetime.  Often, one cannot afford to omit existing functionality. \enquote{Omitted attributes will become the bottlenecks and irritants in usage as the user has to replace automated operation with human intervention. Hence, they also lead to demand for change}. (Related to the first law, but with focus on fuctional requirements)
\item \textbf{Law 7 - Declining Quality}: Evolving programs will be perceived as of declining quality unless rigorously maintained and adapted to a changing operational environment. (Related to the first law, but with focus on obsered reliability)
\end{itemize}
