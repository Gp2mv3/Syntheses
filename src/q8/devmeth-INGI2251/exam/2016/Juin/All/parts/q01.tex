\clearpage{}

\section{Define the stages of a software lifecycle. Describe and compare the
waterfall model, the V model, the spiral model and the agile model of
software development. Discuss the addition of prototyping.}

\subsection{Stages of a software lifecycle (= software process)}

\begin{enumerate}
    \item \textbf{Requirements analysis and definition}: Description of \textit{what}
        behavior is needed not \textit{how} it is realized
    \item \textbf{System (architecture) design}: Description of \textit{how} to implement the customer's requirements (decomposition in software units, specifying interfaces, protocols and data,\ldots)
    \item \textbf{Program (detailed) design}:
     Translation of the architecture design into a program (how each software unit will be built). The basis for writing code.
    \item \textbf{Program writing}:
     Proper implementation of the solution.
    \item \textbf{Unit testing}:
     Check that the code properly implements the design and involves software developers to achieve it.
     These kind of test are to test small parts of the software.
    \item \textbf{Integration testing}:
     Another part of \textit{program testing} along with unit testing. They are used to detect bugs
     errors that cannot be detected with unit testing.
    \item \textbf{System testing}:
    Check that the system does what the customer wants and involves the whole development team to achieve it.
    \item \textbf{System delivery}:
     More than just handing the product over but helping the users to understand and make good use of the whole system.
    \item \textbf{Maintenance}:
    System maintenance involve all the operation that occurs after the delivery of the systems such as 
    improving performance or correcting faults.
\end{enumerate}

\subsection{Comparison}

\subsubsection{The waterfall model} 
\begin{itemize}
    \item Stages are depicted as cascading from one to another (i.e. one
        development stage should be completed before the next begins). 
        \proitem{} It can be
        used for well understood problems that have stable requirements. (Ex: if
        you are at the version 36 of your accounting software with stable
        customer needs, this process works pretty well)
        \proitem{} Very high-level view, simple and easy to understand.
        \consitem Cannot handle changes (frozen requirements, manufacturing
        process rather than creative, no iterative activities) 
        \consitem long wait before a final product.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.4\linewidth]{waterfall_plus.png}
    \caption{Waterfall model lifecycle}
\end{figure}
\FloatBarrier{}

\subsubsection{The V model}

\begin{itemize}
        \item Variation of the waterfall model that separates it in
two phases: \textbf{development} (design) and \textbf{testing}
(V\&V\footnote{Verification and validation}).
\proitem{} It shows how the testing activities are related to the analysis and
design. Indeed, if problems are found during the testing activities, it
is possible to \textbf{loop back to the left side} of the V and re-thinks a part
of the analysis and design with a better understanding of the problem
\end{itemize}

V model provide a bit more flexibility than the waterfall model.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.45\linewidth]{v_model_2.png}
    \includegraphics[width=0.45\linewidth]{v_model.png}
    \caption{V model lifecycle}
\end{figure}
\FloatBarrier{}

\subsubsection{The spiral model}

\begin{itemize}
    \item combines both the development activities with the risk management to minimize and
        control the risk. 
    \proitem{} It is a sort of iterative development (full system at the very
        beginning and then changes functionality of each subsystem with each new
        release).

        Note: iterative dvlpmt change functionality while incremental dvlpmt
        adds functionality. (mixing is beter)
\end{itemize}

Four basic activities that must occur in each cycle of the spiral model:
\begin{enumerate}
    \item Identify conditions of success
    \item Identify and evaluate alternative approaches for satisfying the win
    conditions.
    \item Identify and resolve risks created by selected solutions
    (e.g.\ you can try resolve it, by making a prototype which valid the
    approach).
    \item Obtain approval from all success-critical stakeholders, plus
    commitment to pursue the next cycle.
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\linewidth]{spiral_model.png}
    \caption{Spiral model lifecycle}
\end{figure}
\FloatBarrier{}

\subsubsection{Agile model}

\begin{itemize}
    \proitem{} Flexible process (opposite to rigorous process with
conception/documentation/dev/tests) that adapt to changing requirements.
    \item The overall goal of agile development is
to satisfy the customer by \enquote{early and continuous delivery of
valuable software}.
\end{itemize}

(Extreme programming (XP), Crystal, Scrum)


\paragraph{Agile Manifesto:}

\begin{itemize}
    \item Value \textbf{individuals} and \textbf{interactions} over processes and tools
    \item Prefer producing \textbf{working software} rather than comprehensive documentation
    \item Focus on \textbf{customer collaboration} rather than contract negotiation
    \item Concentrate on \textbf{responding to change} rather than on creating a plan and then following it
\end{itemize}

Development iterative AND incremental! 


\subsection{Addition of prototyping}

Prototyping means building a small version of a system (usually with limited
functionality) that can be used to:

\begin{itemize}
    \item Demonstrate the feasibility of a design or approach
    \item Help the user (or customer) to identify key requirements of a system
\end{itemize}


Often, the \textbf{prototyping is iterative}: We build a prototype, evaluate it (with
user and customer feedback), consider how changes might improve the product or
design, and then build another prototype. The iteration ends when our customers
and we think we have a satisfactory solution to the problem at hand.

\begin{center}
Imagine, in detail, a new product is... hard.


Criticize, in detail, an existing product is... easier.
 $\rightarrow$ That's prototyping.
 \end{center}


There are two main approaches to prototyping :

\begin{itemize}
    \item \textbf{Throwaway :} software developed to learn more about the
    problem/proposed solution. “Quick and dirty” software that will be thrown
    away (not part of the delivered software).

    Prototyping used at design level.

    \item \textbf{Evolutionary :} software developed not only to help us answer questions
    but also to be incorporated into the final product.
\end{itemize}

