\clearpage{}

\section{Define interfaces and classes in object-oriented design. Explain
typing and inheritance and the principles of polymorphism. Compare
inheritance and composition. Explain Liskov’s substitutability principle.
Explain and discuss the Law of Demeter. Describe the general principles and
constituting elements of design patterns.}

\subsection{Interfaces and classes in object-oriented design}

\begin{description}

    \item[Interface] Set of visible attributes and methods (signatures
        and specifications). It defines an abstract data type.

    \item[Class] Software module implementing an interface (i.e.\ it
        implements an abstract data type).

\end{description}

\subsection{Typing, inheritance and polymorphism}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.2\linewidth]{inheritance.png}
\end{figure}

\begin{itemize}

    \item \textbf{Typing}: If $v: T$ refers to $o: C$
        \begin{itemize}
        \item Static typing: only methods of $T$ can be invoked on $v$,
            \textbf{checked at compilation}.

        \item Dynamic binding: when a method is invoked on $v$, the
    implementation of $C$ is executed, \textbf{checked at runtime}. 
    \end{itemize}

    \item \textbf{Inheritance}: A inherits from B iff A extends B iff A is a subtype of B.

        Defining a new class (or interface) by reusing and extending an
        existing class (or interface). 

    \item \textbf{Polymorphism}

        Different implementations from different classes $C$ are
        executed for the same invocation on $v$. Ability of the code to
        act on values of multiple types.

        Improve the code reusability, e.g.\ implement one time a data
        structure such as list, array for all the different data types.

\end{itemize}

\subsection{Comparison between inheritance and composition}

Two main techniques for constructing larger objects from smaller objects:

\begin{itemize}
    \item Inheritance: extend an existing class aka. White-box reuse. Use when subtyping is
useful.

    \item Composition: combine simpler classes aka. Black-box reuse. Preferred in general.
\end{itemize}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\linewidth]{in_vs_compo.png}
\end{figure}


\begin{table}[!ht]
    \begin{tabular}{p{0.45\linewidth}p{0.45\linewidth}}
        Composition & Inheritance \\
        \begin{minipage}{\linewidth}
            \begin{center}
                \input{res/composition}
            \end{center}

            \begin{itemize}
                    \proitem{} Only Composite interface is visible
                    \proitem{} Component can change dynamically
                    \proitem{} Multiple components is possible
                    \proitem{} Composite may use a Component
                interface
                \consitem{} Component methods must be forwarded
                in Composite
                \consitem{} Component unrelated to Composite
            \end{itemize}
        \end{minipage}
        &
        \begin{minipage}{\linewidth}
            \begin{center}
                \input{res/inheritance_2}
            \end{center}
            \begin{itemize}
                    \proitem{} Component methods invoked directly
                    \proitem{} Composite subtype of Component
                    \consitem{} Interface of Component is visible in
                Composite
                \consitem{} Component fixed at design time
                \consitem{} Only one Component is possible
                \consitem{} Composite must extend a Component
                class
            \end{itemize}
        \end{minipage}
    \end{tabular}
    \caption{Inheritance VS composition}
\end{table}

\FloatBarrier

\subsection{Liskov’s substitutability principle}

\begin{figure}[!ht]
    \centering
    \input{res/substituability}
    \caption{Substitutability principle}
\end{figure}

\subsubsection{Substitutability}

\begin{itemize}
    \item Subclass is a subtype of Superclass
    \item Subclass instances can be used as Superclass instances
    \item Subclass must preserve the behaviour of Superclass
    \item Subclass must respect the contract of Superclass, so that Subclass instances are substitutable to Superclass instances
\end{itemize}

N.B. this is a guiding principle, not an absolute rule. \newline

\subsubsection{Liskov’s substitutability principle}

Subclass is substitutable for Superclass if:

\begin{enumerate}
    \item Subclass supports all the methods of Superclass (with compatible signatures)
    \item Subclass methods satisfy the specifications of Superclass methods
    \item Subclass preserves all properties of Superclass
\end{enumerate}

\begin{itemize}
\item \textbf{Substitutability of Specifications}
\begin{itemize}
	\item Precondition rule: $pre\_super \rightarrow pre\_sub$
	\item Postcondition rule= $pre\_super \rightarrow (post\_sub \rightarrow post\_super)$
\end{itemize}
pre condition of subclass must be weaker or same and
post condition of subclass must be stronger or same.

\item \textbf{Substitutability of Signatures}


\texttt{Subclass.m(params:T): U} \textit{is substitutable for}
\texttt{Superclass.m(params: T'): U'} \textit{if}:
\begin{itemize}
    \item $T \subseteq T'$: T is a subtype of T'
	\item $U' \subseteq U$: U' is a subtype of U
\end{itemize}

A subclass must accept parameter at least as general than superclass and
must return an output that satisfies the condition of return type of the
super-method.
\end{itemize}

\subsection{Law of Demeter (aka. \enquote{Don't talk to strangers})}

The Law of Demeter is used to remove indirect dependencies. \textbf{Each unit
should have knowledge only on directly related units}. \newline

In OO programming: each class should invoke methods only on directly
referenced classes.

\begin{itemize}
        \proitem{} Reduces dependencies
        \proitem{} Client of a composite need not know its components
        \consitem{} Needs additional wrapper functions, may degrade performance
\end{itemize}

\subsection{General principles and constituting elements of design patterns}

A design pattern codifies design decisions and practices for solving a
particular design problem according to design principles. ("Encapsulate
a design decision")

$\Rightarrow$  They are templates for a solution that must be modified and adapted for
each particular use. 
\newline

Elements of a design pattern:

\begin{description}
    \item[Name] for easy reference, enriches our design vocabulary
    \item[Problem] when to apply, objectives
    \item[Solution] structure, elements and relationships
    \item[Consequences] benefits and costs, trade-offs
\end{description}


