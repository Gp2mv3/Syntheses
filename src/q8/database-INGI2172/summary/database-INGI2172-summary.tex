\documentclass[fr,license=none]{../../../eplsummary}

\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\cdot$}
\renewcommand{\labelitemiii}{$\diamond$}
\renewcommand{\labelitemiv}{$\ast$}

\usepackage[french]{varioref} % \vref and \vpageref
\usepackage{graphicx} % images
\usepackage{float} % images
\usepackage{url}
	\urlstyle{sf}
\usepackage[backgroundcolor=yellow]{todonotes} %% todonotes: \listoftodos & \todo{Some note or other.} & \missingfigure{}

% draw
\usepackage{tikz}
\usetikzlibrary{arrows}
% \usepackage{qtree}    % dessiner des arbres %% => texlive-humanities

\definecolor{codeBlue}{rgb}{0,0,1}
\definecolor{webred}{rgb}{0.5,0,0}
\definecolor{codeGreen}{rgb}{0,0.5,0}
\definecolor{codeGrey}{rgb}{0.6,0.6,0.6}
\definecolor{webdarkblue}{rgb}{0,0,0.4}
\definecolor{webgreen}{rgb}{0,0.3,0}
\definecolor{webblue}{rgb}{0,0,0.8}
\definecolor{orange}{rgb}{0.7,0.1,0.1}

\usepackage{caption}
\renewcommand{\familydefault}{\sfdefault}

\usepackage{listings}		% Pour l'insersion de fichiers de codes sources.
\lstset{
	  language=Java,
	  frame=single,
	  flexiblecolumns=true,
	  numbers=none, % left
	  stepnumber=1,
	  numberstyle=\ttfamily\tiny,
	  keywordstyle=\ttfamily\textcolor{blue},
	  stringstyle=\ttfamily\textcolor{red},
	  commentstyle=\ttfamily\textcolor{green},
	  breaklines=true,
	  extendedchars=true,
	  basicstyle=\ttfamily\scriptsize,
	  showstringspaces=false
	}

\lstdefinelanguage{diff}{
  morecomment=[f][\color{blue}]{@@},     % group identifier
  morecomment=[f][\color{red}]-,         % deleted lines
  morecomment=[f][\color{green}]+,       % added lines
  morecomment=[f][\color{magenta}]{---}, % Diff header lines (must appear after +,-)
  morecomment=[f][\color{magenta}]{+++},
}

\IfFileExists{fourier.sty}{\usepackage{fourier}}{\typeout{! WARNING: Fourier package not included: skip it}}

%%%%%%%%%%%%%%%%%%%%


\title{LINGI2172 - Exams}
\author{Matth, LN, Alex, Ben, Leader, Houtain Nicolas}
\hypertitle{Databases}{8}{INGI}{2172}
{Houtain Nicolas \and Matthieu Baerts\and Benoît Baufays\and Julien Colmonts\and Alex Vermeylen\and Hélène Verhaeghe}
{Bernard Lambeau}
\section{Intro}
A database is a collection og related data, where data means fact that
can be stored and have an implicit meaning. Key point are:
\begin{itemize}
	\item Focus on information, not only storage.
	\item Independence (weak coupling for easier maintenance)
	\item High-level Specification, there is a guarentee on the behavior
	(because of the ACID property).
	\item Information aims at being queried.
\end{itemize}
\section{Lexique}
\begin{itemize}
	\item Variable : C'est une représentation à un temps t de la fonction. La ``table''
	    représente plutôt la valeur de variable.

	    Represent a predicate.
	\item[Notes:] Une table $\neq$ relation puisque la relation est indépendante
	    de l'ordre des rows/columns.

    \item Relation : Fonction qui lie les attributs entre eux. C'est elle qui leurs donne un sens.
    \item Attribut : Un champ de la variable.
    \item Cardinalité :  Nombre de n-tuple.
    \item N-Tuple : une ligne, un ensemble d'attribute value.
    \item Tuple : ensemble des lignes.
    \item Heading : a set of attributes.
    \item Orthogonalité : %TODO
\end{itemize}


\subsection{Definitions}
\begin{itemize}
\item Relation : A relation represents the extension of some n-adic predicate P by having
a body consisting of every n-tuple that satisfies P
	\item A database : is an organized machine readable collection of symbols
	 (we can see the value of the database) and machine-updatable.
	 \end{itemize}

\section{DBMS}
The DBMS is a piece of software for managing databases and providing
access to them. It has several function such as:
\begin{itemize}
	\item Create and destroy variable
	\item Assuring data integrity rules (constraint)
	\item Update variable
	\item ...
\end{itemize}
\begin{figure}[H] 
    \centering
    \includegraphics[width=10cm]{img/dbms.png}
    \caption{Database design}
\end{figure}

Everything is kept hidden, only information is exposed to the software layer.
\begin{description}
    \item[DML] : Data Manipulation Language (manipulate data)
    \item[DDL] : Data Definition Language (manipulate schema, metadata)
\end{description}

\section{Predicate logique}
A predicat is the meaningor a certain kind of sentence, but often used
to refer to the sentece itself.

\paragraph{Sentence}: By sentence, we means sentences with the form of
a statement (can be true of false). Notice that the meaning is 
language-independant while the sentence is not.

\subsection{Generally}
Une proposition est composé de différent paramètre (ex: $x \leq y$).
P(x), a predicate, is called a membership
predicate for the set consisting of all such objects a.

\begin{description}
    \item \begin{tabular}{m{2cm}m{11cm}}
    \textbf{Definition}&
    \begin{itemize}
        \item Intension : its meaning
        \item Extension : all the instantiations that are ''true''
        \item Substitution : replace a paramerter by a \textit{designator}
        \item Instantiation : substitution of all the parameter
        \item N-adic predicate : A predicate with n parameters.
    \end{itemize}
\end{tabular}

 \item \begin{tabular}{m{2cm}m{11cm}}
    \textbf{Operator}&
    \begin{itemize}
        \item Conjunction, disjunction , negation, implication, only if, equivalence
    \end{itemize}
\end{tabular}
\item \begin{tabular}{m{2cm}m{11cm}}
    \textbf{Qualifiers}&
    \begin{itemize}
    \item Existential, universal
    \end{itemize}
\end{tabular}
\item \begin{tabular}{m{2cm}m{11cm}}
    \textbf{Sets}&
    \begin{itemize}
    \item $\in$, $\subseteq$, $\supseteq$, $\subset$, $\supset$, equality
    \item Join, disjointness, union, intersection,
    \item complement : $A = \{x | \neg x \in A \}$,
    \item difference : $A-B = \{ x | x \in A \wedge \neg x \in B\}$
    \end{itemize}
\end{tabular}
\end{description}


A \textbf{relation} represents the extension of some n-adic (n parameters) predicate P,
by having a body consisting of every n-tuple that satisfies P.

\subsection{Tutorial D}
\subsubsection{Foundation}
There are important distinctions in Tutorial D that must be explained
given the example \texttt{Y : = X + 1} :

\begin{description}
	\item[Value vs variable: ] Y denotes a variable, X denotes the value 
	currently assigned to the variable X. 1 denotes a value. Variables
	are subject to change while value exists independently of time.
	\item[Variable vs variable reference: ] X and Y are both referencing 
	variable, but the context makes them denote different thing. 
	\item[Update operator versus read-only operator: ] ''\texttt{:=}'' is 
	an update operator (UO) and ''\texttt{+}'' is a read-only operator
	(ROO). An UO has at least on parameter that is subject to update
	which is not the case for a ROO. But a ROO yields a value.
	\item[Operator vs invocation: ] ''\texttt{+}'' is an operator and
	\texttt{X + 1} is an invocation of this operator.
	\item[Parameter vs argument: ] An argument refers to the substitution
	of the defined parameter of the operator by values. (\texttt{X and 1}
	are arguments of the operator \texttt{+} which is defined to have 2 
	parameters.)
	\item[Parameter subject to update vs parameter not subject to update: ]
	Update operator \texttt{:=} take two parameters. The first one
	is subject to update so it must be substitute by a variable. The second
	one is no subject to update so it must be substitute by a value.
\end{description}

\subsubsection{Relation Type}
A type (= domain) is a named set of values. The value in the sets are
called litteral. The type of a relation is defined by its heading.\\
It's possible in Tutorial D to define user-type that are a subtype
system existing type. 

\begin{lstlisting}
TYPE SID POSSREP SID { C CHAR
			CONSTRAINT LENGTH(C) <= 5
				AND
			  	STARTS_WITH(C,'S')
				AND
				IS_DIGIT(SUBSTRING(C,1)))
			 }
	INIT SID('S1');
\end{lstlisting}

\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Logic} & \textbf{Tutorial D} \\
        \hline
        AND & JOIN \\
        & WHERE (restriction) \\
        & EXTEND (extension) \\
        & SUMMARIZE \\
        \hline
        EXISTS & EXISTS (projection) \\
        \hline
        OR & UNION \\
        \hline
        (AND) NOT & MINUS (difference) \\
        & NOT MATCHING (semi-difference) \\
        \hline
        & RENAME \\
        \hline
    \end{tabular}
    \caption{Link Logic operate and Tutorial D}
\end{table}

\subsubsection{RENAME}
\begin{lstlisting}
IS_CALLED RENAME { StudentId AS Sid1 } JOIN IS_CALLED RENAME { StudentId AS Sid2 }
\end{lstlisting}
LET $s= r$ RENAME \{A1 AS B1, \ldots, An AS Bn\}

\begin{itemize}
    \item Heading of s = heading of r except that $Ai$ is renamed to $Bi$
    \item Body of s = body of r except that $Ai$ is renamed to $Bi$
\end{itemize}

\subsubsection{EXISTS}
\begin{lstlisting}
IS_ENROLLED_ON { StudentId } = IS_ENROLLED_ON { ALL BUT CourseId }
\end{lstlisting}

LET $s= r$\{A1,\ldots,An\} = r\{ALL BUT B1, \ldots, Bm\}

\begin{itemize}
    \item Heading of s is the subset of r given \{A1,\ldots,An\}
    \item Body of s consists of each tuple that can be formed by removing
        attibutes named \{B1,\ldots,Bm\}
\end{itemize}

\paragraph{Special case :}
\begin{itemize}
    \item R {ALL BUT } = R
    \item R { } = Empty relation with no attributes
\end{itemize}


\subsubsection{JOIN}
Let $s = r_1 JOIN r_2$.
$\to$ Commutative and associative.

\begin{itemize}
    \item Heading s is the union of heading $r_1$ and $r_2$
    \item Body of s is all tuple that can be formed by taking union of $r_1$ and $r_2$
        with the heading of s
\end{itemize}

\paragraph{Special case :}
\begin{itemize}
    \item R JOIN R = \textbf{R}
    \item If all attributes are common to both operand = \textbf{Intersection}
    \item If no attribute are common to both operand = \textbf{Cartesian product}
\end{itemize}

\subsubsection{WHERE}
Let $s = R WHERE C$

\begin{itemize}
    \item Heading s is the heading of r
    \item Body of s consist of tuple of r where the condition is true
\end{itemize}

\paragraph{Special case :}
\begin{itemize}
    \item $R WHERE TRUE$ = \textbf{R}
    \item $R WHERE FALSE$ = \textbf{A empty relation with heading of R}
\end{itemize}

\paragraph{Using JOIN}:

\begin{lstlisting}[mathescape]
IS_CALLED JOIN RELATION { TUPLE { Name NAME ('Boris') } }  $\equiv$ IS_CALLED WHERE Name = NAME ('Boris')
\end{lstlisting}

\subsubsection{EXTEND}
Let $s = EXTENd r : \{formula_1 AS A1, \cdots, formula_n AS AN\}$

\begin{itemize}
    \item Heading of s is heading of r with the attribute A1,\ldots,An
    \item Body of s consist of tuple of r with the additionnal attribut evaluate with
        $formula_i$
\end{itemize}

\subsubsection{UNION}
Let $s = r_1$ UNION $r_2$.

\begin{itemize}
    \item $r1$ and $r2$ must have the same heading
    \item all possibility between two set of tuple
\end{itemize}

\subsubsection{ TODO }
TODO slide 4b

\subsection{PostgreSQL}

\subsubsection{SQL relationnal operator}

\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Logic} & \textbf{SQL} \\
        \hline
        AND & JOIN \\
        & WHERE (restriction) \\
        & GROUP BY  (HAVING)\\
        \hline
        EXISTS & EXISTS (projection) \\
        & DISTINCT\\
        & IN\\
        \hline
        OR & UNION \\
        \hline
        (AND) NOT & EXCEPT (difference) \\
        &NOT EXISTS\\
        & NOT IN (semi-difference) \\
        \hline
        & AS \\
        \hline
    \end{tabular}
    \caption{Link Logic operate and SQL}
\end{table}

%TODO EXAMPLE WITH 5b slide 30 WHERE FAILS

\section{Tuple Calculus and Relational Algebra }

\paragraph{Describe}:

\begin{tabular}{cc}
Relational algebra & Tuple calculus \\
X = 98 + 2 & Find X s.t X-1 = 98 \\
\end{tabular}

$\Rightarrow$ \textbf{Equivalent}

\subsection{Relational algebra}

A relation has is a n-tuple with attributes and attribute values. It has a heading (set of attributes) with a
certain degree.

\begin{itemize}
    \item Build with predicates 
    \item Extension of the predicate is the set of true propositions that are instantiations of it.
        Each proposition in
        the extension has exactly one corresponding tuple in the relation.
\end{itemize}

\subsection{Tuple calculus}

A tuple relational calculus have the form:
$$\{t_1.A_j,...,t_n.A_m\quad|\quad COND(t_1...t_n)\}$$ 

Tuple variables ranges over a particular relation variable, stisfy \texttt{COND(t)}
\begin{itemize}
    \item Truth value of an atom : evaluates to either TRUE or FALSE for a specific
        combination of tuples
    \item Formula : Made up of one or more atoms connected via
        logical operators AND, OR, and NOT
\end{itemize}

\begin{lstlisting}[mathescape, caption=query listing the name and address of all employees who work fot the Research department]
{t.Fname,t.Lname,t.Address | EMPLOYEE(t) AND ($\exists d$)(DEPARTMENT(d)
                                         AND d.Dname = 'Research' 
                                         AND d.Dnumber = t.Dno)}
\end{lstlisting}

\section{Constraint}

Constraints express the integrity rules for a database.
They enforcement of constraints by the DBMS ensures that the
database is at all times in a consistent state.

\subsection{KEY constraints}%\label{key}
\begin{itemize}
    \item A key for a relvar r is a set of attributes of r (i.e, a subset of 
        r's heading) such that at no time does r contain more than one tuple
        having any given collection of values for those attributes.
    \item A key must have the property of irreducibility meaning that we cannot 
        take any attribute away from a key and still have a key.
    \item A relvar can have several keys : the nominated one is called 
        ''primary key'' and the others ''alternate keys''.
\end{itemize}

\paragraph{Definition from the book}
\begin{description}
	\item[SuperKey :] Let K be a subset of a ther heading of the relvar $r$. Then K is a 
	\textbf{superkey} for $r$ iff , at all times , t1 and t2 both appear
	in the body of $r$ and the projection t1\{K\} is equal to the
	projection t2\{K\},then t1 = t2(i.en they are the same tuple)
	\item[Key :] K is \textbf{key} for $r$ iff:
	 \begin{itemize}
	 	\item K is a superkey for $r$
	 	\item No proper subset of K is a superkey for $r$.
	 \end{itemize}
\end{description}

In others word, a superkey is a set of attributes that uniquely identifies
any tuples within the body of the relvar. A superkey become a key 
when it is reduced to the minimum number of attributes.

\paragraph{$\Rightarrow$} You can nominate a \textbf{primary key} amoung the \textbf{keys} and
the others are called \textbf{alternate key}.

\subsection{Foreign key}

There is a \textbf{inclusion dependency} because the relation which
contains a foreign key (SECOND) must be included into the relation which
contains the key (FIRST) : 
\begin{center}
    FIRST \{ StudentId \} $\supseteq$ SECOND \{StudentId\}
\end{center}

\paragraph{Generalisation of inclusion dependency}
\begin{center}
IS\_EMPTY( SECOND NOT MATCHING FIRST )
\end{center}

\paragraph{Multiple assignement} is used when we need to update several
variable on the same time to respect some constraint.

\subsection{Implicit constraint}

A single relvars describe by \{ID\#, Name, Field1,
Field2\} have an implicit constraint to the effect that every ``A'' has a
ID, a Name, a Field1 and a Field2\ldots

To avoid this implicit constaint, we need to decomposed the design in
different table link by the a foreign key (ID\#).

\paragraph{ }
The single relvar design is preferred so long as the constraint implied
by it truly reflects the real world!

\section{Normal Form}
In database design, there are some requirement that can be used to check 
the quality of database:
\begin{itemize}
	\item Orthogonality
	\item Redundancy
	\item Simplicity
\end{itemize}

\subsection{Fonctional dependency (FD)}\label{fd}

Soit une relation $R$, un set d'attributs (\textbf{determinant}) et
détermine un set (\textbf{dependant set}) $\forall (x \rightarrow y)$
si et seulement si chaque valeur de $x$ est associée à un élément de
$y$. Note that a FD denotes a function.

For example, in the relation $a+b=c$ we have $\{a,b\} \rightarrow \{c\}$.

\paragraph{Definition}: If we have $\{A_1,...,A_n\} \to \{B_1,...,B_m\} \in R$ then
\begin{center}
for any two tuple $S$ and $T$ s.t $S.\{A_1,...,A_n\} = T.\{A_1,...,A_n\}$ $\Rightarrow$
    $S.\{B_1,...,A_m\} = T.\{B_1,...,A_m\}$
\end{center}

\paragraph{Theorem about FD: }
\begin{itemize}
    \item Left augmentation : if A' is a superset of A, then A' $\to$ B 
    \item Right reduction : if B' is a subset of B, then A $\to$ B' 
    \item Transivity : if A $\to$ B and B $\to$ C, then A $\to$ C 
    \item General : if A $\to$ B and C $\to$ D, then A $\cup ( C - B) \to B \cup D$
    \item[]
    \item Left-irreducibility : if A $\to$ B and there is no proper subset A' such
        that A' $\to$ B, then A $\to$ B is \textbf{left-irreducible} and B is said
        \textit{fully dependent} on A.
    \item[]
    \item A is a superkey of r if A $\to$ B and A $\cup$ B constitutes the entire
        heading of r
    \item A is a key of r if A $\to$ B is left-irreducible and A $\cup$ B constitutes the entire
        heading of r
\end{itemize}

\subsection{Join dependency}\label{jd}

Une relation est sujette à une join dependency si elle peut être
recréée en joignant plusieurs tables ayant chacune un sous ensemble
des attributs de la relation.

On parle de \textit{join dependency triviale} si une des tables du join
à tous les attributs de la relation initiale: bref que l'on ne peut
plus faire de join dependency (voir exemple en section \vref{6NF}).


\paragraph{Notation:}
Si on a la relvar \texttt{WIFE\_OF\_HENRY\_VIII}  = \{Wife\#,FName,LName,Fate\},

$\to$ une JD se note : * \{ \{ Wife\#,FName \}, \{Wife\#, LName , Fate \}\}


\subsection{Normalisation}
Normalisation is the act of decomposing a relvar that fails
to satisfy a given normal form scuh that the result is an
equivalent set of two or more ''smaller'' relvars that do satisfy
that normal form. 

\paragraph{Goals}
\begin{itemize}
	\item Remove redundancy
	\item No update anomalies
	\item Full orthogonality
\end{itemize}

For example go check \url{http://www.studytonight.com/dbms/database-normalization.php}

\subsection{1 NF}
\paragraph{Normalisation}

A relation is in 1NF if attribute domains include only
atomic (simple, indivisible) values and each tuple
attribute value is a single value from the domain.

% http://www.tablesgenerator.com/#
% http://truben.no/latex/table/
\begin{table}[H]
    \centering
    \begin{tabular}{ccc}
\begin{tabular}{|c|c|c|}
\hline
A$_1$ & A$_2$ & A$_3$ \\ \hline
      &       &       \\ \hline
      &       &       \\ \hline
\end{tabular}
&
\begin{tabular}{|c|c|c|}
\hline
A$_1$ & A$_2$ & A$_3$ \\ \hline
      &   \rule{0pt}{3ex} \begin{tabular}{|c|c|}\hline & \\ \hline \end{tabular}    &       \\ \hline
      &   \rule{0pt}{3ex} \begin{tabular}{|c|c|}\hline & \\ \hline \end{tabular}    &       \\ \hline
\end{tabular}
&
\begin{tabular}{|c|c|c|}
\hline
A$_1$ & A$_2$ & A$_3$ \\ \hline
      &   \rule{0pt}{5ex} \begin{tabular}{|c|}\hline \\\hline \\ \hline \end{tabular}    &       \\ \hline
      &   \rule{0pt}{5ex} \begin{tabular}{|c|}\hline \\\hline \\ \hline \end{tabular}    &       \\ \hline
\end{tabular} \\
GOOD & Non atomic value (tuple) & No simple value \\
\end{tabular}
\end{table}


\subsection{BCNF}
Pour toutes dépendances fonctionnelles $X \rightarrow A$ (voir section \vref{fd}) , il doit y avoir au-moins une de ces 2 conditions respectées:
\begin{itemize}
	\item $X$ contient $A$ ($A\subseteq X$)  (FD triviale, voir section \vref{fd})
    \item $X$ est une key (voir section \vref{key})
\end{itemize}

\paragraph{$\Rightarrow$} BCNF allows to deal with the redundancy and the lack of orthogonality 
through splitting.

\paragraph{Tradeoff} between keep FD and remove redondancy/improve orthogonality.

\begin{figure}[!h]
\centering
\begin{tabular}{cccc}
\begin{tabular}{|ccc|}
\hline
\underline{SID} & NAME & \underline{CID} \\
\hline
S1 & Anne & C1\\
... & ... & ... \\
S1 & Anne & C2 \\
\hline
\end{tabular}
& $\Rightarrow$ &
\begin{tabular}{|cc|}
\hline
\underline{SID} & NAME \\
\hline
S1 & Anne \\
\hline
\end{tabular}
&
\begin{tabular}{|cc|}
\hline
\underline{SID} & \underline{CID} \\
\hline
S1 & C1\\
S1 & C2 \\
\hline
\end{tabular}
\end{tabular}
\caption{}
    \captionsetup{singlelinecheck=off}
    \caption[level]{ Remove redondancy and improve orthogonality
\begin{enumerate}
\item FD : \{SID \} $\to$ NAME
\end{enumerate}}
\end{figure}


\begin{figure}[!h]
\centering
\begin{tabular}{cccc}
\begin{tabular}{|ccc|}
\hline
\underline{SID} & TUTORID & \underline{CID} \\
\hline
S1 & T1 & C1 \\
... & ... & ... \\
S1 & T2 & C2 \\
\hline
\end{tabular}
& $\Rightarrow$ &
\begin{tabular}{|cc|}
\hline
\underline{SID} & \underline{TUTORID} \\
\hline
S1 & T1 \\
S1 & T2 \\
\hline
\end{tabular}
&
\begin{tabular}{|cc|}
\hline
\underline{TUTORID} & \underline{CID} \\
\hline
T1 & C1\\
T2 & C2 \\
\hline
\end{tabular}
\end{tabular}
    \captionsetup{singlelinecheck=off}
    \caption[level]{ Loss of FD
\begin{enumerate}
\item FD : \{SID, CID \} $\to$ TUTORID
\item FD : \{TUTORID \} $\to$ CID
\end{enumerate}}
\end{figure}


\subsection{5 NF}

Une relation est 5NF si toutes \textit{join dependencies} (voir section
\vref{jd}) non-triviales est implicite par les candidate keys (=
super key quand il n'y a pas encore de clé primaire). 
\begin{center}
    \textit{join dependencies} à $\{A, B, ..., Z\}$ est implicite
par les candidates keys si et seulement si chaque $A, B, ..., Z$ est
superkey.
\end{center}

\subsection{6 NF}\label{6NF}
Une relation est 6NF si elle ne satisfait aucune \textit{join dependency} (autre que les triviales donc).\\

\begin{table}[H]
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\cline{1-2} \cline{4-5} \cline{7-8}
\textbf{ID} & \textbf{FName} & \textbf{} & \textbf{ID} & \textbf{LName} & \textbf{} & \textbf{ID} & \textbf{Status} \\ \cline{1-2} \cline{4-5} \cline{7-8}
1           & Alex           &           & 1           & Vermeylen      &           & 1           & Sleeping        \\ \cline{1-2} \cline{4-5} \cline{7-8}
2           & LN             &           & 2           & Verhaeghe      &           & 2           & Watching TV     \\ \cline{1-2} \cline{4-5} \cline{7-8}
\end{tabular}
\caption{Exemple de 6NF}
\end{center}
\end{table}
On ne peut plus faire de join dependency mais du coup, c'est dangereux: si on ajoute une nouvelle entrée dans la première table, il faut ajouter des contraintes pour être sûr d'ajouter aussi dans les autres tables si c'est nécessaire.

\subsection{FD-driven Logical Design}
A general method for logical design is
given a relvar R with heading H and some FDs, decompose R into
relvars $R_1\  ...\  R_n$ s.t
\begin{itemize}
	\item $H\ =\ H_1\cup\ ...\ \cup\ H_n$
	\item $\forall i R_i$ is in a particular NF
	\item Every FD appears in a $R_i$
	\item R = JOIN\{$R_1,\ ...\ ,R_n$\}
\end{itemize}

\subsection{Heath's theorem}
\begin{itemize}
	\item Let A, B and C be subsets of the heading of a relvar R s.t every 
	attribute appears in at least one subset and suppose FD: $A\to B$ 
	holds.
	\item Then , the JD*$\{A\cup B,A\cup C\}$ holds in R
\end{itemize}

%%TODO Algorithms

\section{View, Rules \& Triggers}

\subsection{View}


View are computed relation variables (capture predicate extension, 
should be updatable, have constraints and have keys). 

\paragraph{unlike ''BASE''}: they should be kept hidden to end-users.
Views allows the independence of the logical schema. If the schema
evolves (i.e for a better design), views will shield users from
breaking changes.

%TODO

\subsubsection{View updating}
\begin{description}
	\item[Golden rule :] No database is ever allowed to violate its 
	own databas constraint.
	\item[Assigment principle :]After assignment og value v to 
	variable V then v = V must evaluate to true.
\end{description}

\paragraph{Issue}
Depending on how the view is defined, updating a view can be a problem.
For example:
\begin{lstlisting}
V := SUPPLIERS{CITY} UNION PARTS {CITY}
\end{lstlisting}
$\Rightarrow$ If we want to insert something, do we have to do it in the both?

\subsection{Rules \& Triggers}

Both of them are object in database but trigger be attached to a 
relvar.

\begin{itemize}
    \item Trigger be attached to a table and execute before/after a
        \texttt{INSERT}, \texttt{UPDATE} or \texttt{DELETE} is done.
        \begin{itemize}
            \item Execute a automatique request after a event
            \item[$\Rightarrow$] Cannot cancel operations!
        \end{itemize}
    \item Rule modified thes AST
    \item[Perf] 
De ce fait, la rule est plus efficace que le trigger. Si on fait 100
insert, on exécute 100 fois le trigger ; alors que si on modifie
l'arbre, on ne doit construire qu'une seule fois cet arbre. Le travail
est donc le même pour une ou 100 query(ies).
\item 
En outre, la rule peut être utilisé avec une view, alors que le
trigger, ne peut pas.
\end{itemize}



\section{Database programming}
\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Techinique} & \textbf{Examples} & \textbf{What is exposed} & \textbf{Data transfer}\\
\hline
Active Database & PSM,PL/SQL& SQL code& Shared variables and cursors\\
\hline
Embedded SQL &&SQL code & Shared variables and cursors\\
\hline
Call-level APIs&JDBC,ODBC&SQL as string repr.&Cursor-like ResultSet\\
\hline
Query builders& Sequel,JOOQ& SQL ASTs&Cursor-like ResultSet\\
\hline
ORMS&Hibernate & Object model & Class instances(one at a time)\\
\hline
First-class Relation &Alf & Relations and Relvars& Relation instances (set at a time)\\
\hline
\end{tabular}
\caption{Various approaches to Database Programming}
\end{table}
An host language is a language in which SQL calls are embedded.

\subsection{Active database} 
SQL with statement, trigger and stored procedures

\begin{itemize}
    \item Branching/loops : IF .. THEN .. ELSE, WHILE .. DO .., REPEAT.. UNTIL ..
    \item Interaction :SELECT .. INTO .., Cursors
\end{itemize}

\paragraph{Cursor}
A cursors is a tuple-variable that ranges over all tuples in the result 
of some query. We can get the result from the cursor through the 
\texttt{FETCH} command.


\paragraph{}

\begin{tabular}{m{0.5\linewidth}m{0.5\linewidth}}
    \multicolumn{1}{c}{\textbf{Pros}} & \multicolumn{1}{c}{\textbf{Cons}}\\
    \begin{itemize}
		\item Easy to use \& deploy.
		\item Efficiency (treaments close to data)
		\item Transactions made easy
     \end{itemize}
     &
    \begin{itemize}
		\item Difficult to test \& deploy (incompatibility)
		\item Hard to scale/distribute processing
		\item Bad programming language design
	\end{itemize}
\end{tabular}

\subsection{Embedded SQL}
\begin{itemize}
    \item In Embedded SQL a preprocessor is used. 
    \item SQL statements are turned into
procedure calls that fit with the host-language code surronding. (Key word
EXEC is used to easiliy recognize SQL calls)
\end{itemize}

$\to$ To interact with each other,  SQL and the host-language share variable. 
Embedded SQL is no longer used because it is hard to maintain programs with 
mixed styles and there is a need for higher-level construts.

\subsection{Call-level interface} 
Use a external library to connect and execute some statement on
the database. It's a low level because the query is write into
a String and pass as argument to a function which return a result set.

\paragraph{}

\begin{tabular}{m{0.5\linewidth}m{0.5\linewidth}}
    \multicolumn{1}{c}{\textbf{Pros}} & \multicolumn{1}{c}{\textbf{Cons}}\\

\begin{itemize}
    \item Standardize at the API level, keep the control (because low-level)
\end{itemize}
&
\begin{itemize}
    \item SQL injection risks, difficult to maintain
\end{itemize}
\end{tabular}

\subsection{Query builder} 
Query is like a object and we can execute some function (where(), join(), select(),...)
on the table to have some result.

This idea raise the level of abstraction (no visible string concatenation, 
handles SQL escaping automatically)

\paragraph{}

\begin{tabular}{m{0.5\linewidth}m{0.5\linewidth}}
    \multicolumn{1}{c}{\textbf{Pros}} & \multicolumn{1}{c}{\textbf{Cons}}\\
\begin{itemize}
    \item Cleaner that previous solution, easier for dynamically created queries,
        less prone to SQL injection
\end{itemize}
&
\begin{itemize}
    \item Complex queries tend to be a mess to build
\end{itemize}
\end{tabular}

\subsection{ORM} 
Expose a Class diagram(Object model) instead of a relational schema to 
the application layer. Then map that diagram to the relational schema. 

\paragraph{}

\begin{tabular}{m{0.5\linewidth}m{0.5\linewidth}}
    \multicolumn{1}{c}{\textbf{Pros}} & \multicolumn{1}{c}{\textbf{Cons}}\\
    \begin{itemize}
		\item Simple and less prone to SQL injections
		\item Natural data layer for object-minded people
	\end{itemize}
    &
    \begin{itemize}
		\item OO/ Relation Mismatch (one-at-a-time vs set-at-at-a-time ways of thinking)
		\item Software coupling (Huge OO model where all is already implemented)
		\item Require control of the SQL schema
		\item Hide database connections and transaction
	\end{itemize}
\end{tabular}

\subsection{Relation as first-class citizen}
Expose relation concepts at application layer (relational algebra)

\paragraph{}

\begin{tabular}{m{0.5\linewidth}m{0.5\linewidth}}
    \multicolumn{1}{c}{\textbf{Pros}} & \multicolumn{1}{c}{\textbf{Cons}}\\
	\begin{itemize}
		\item Algebra cleaner than SQL query builders
		\item Simpler and sounder %%SOunder?
	\end{itemize}
    &
	\begin{itemize}
		\item Risk of loosing control of generated SQL.
		\item Not widely available.
	\end{itemize}
\end{tabular}

\subsection{The NOSQL Cases}
Data models is not the same: Key-value stores or document database. With one
of these approach, it is easier to do a mapping with a programming languages.

\section{Transactions}
\subsection{Purposes}
DBMS manages database variables, the variable are:
\begin{itemize}
    \item \textbf{Mutable} : different values at different times.
    \item \textbf{Shared} : read \& updated by many users or processes
	at the same time.
\item \textbf{Complex}: consistency constraints to be preserved whatever
	happens.
\end{itemize}

$\Rightarrow$ Mutable shared state is one of the biggest source of complexity in
software engineering. Transaction deals with this problem.


\subsection{Properties}
Toutes les transactions doivent être ACID pour être relationnelles. ACID:
\begin{itemize}
    \item \textbf{Atomic}: The whole process is done or none is.
    \item \textbf{Concistant}: Database constraints are preserved.
    \item \textbf{Isolated}: Appear to the user as if only one process executes at a time.
        (Need to manage with concurrence)
    \item \textbf{Durability}: Effect of a process do not get lost\ldots 
        Modifications are permanent.

\end{itemize}

There is Read-only and Read-write access for a transaction\ldots Indeed, using 
this may improve performance in practice.

\paragraph{ } Use COMMIT to complete the transaction or ROLLBACK to abort
the transaction.

\paragraph{Correctness}
\begin{tabular}{|c|cc|}
\hline
& Commit & Rollback \\
\hline
A & Applies all transaction update & No effect on DB \\
C & Succeed only if no constraint violated & Back to least consistent state \\
I & Effect become visible & No partial visible state \\
D & Modification are permanent & No partial change \\
\hline
\end{tabular}

\subsection{Isolation levels}

\begin{tabular}{|l|c|c|c|}
    \hline
    Level & Dirty read & Nonrep. read & Phantom read \\
    \hline
    Serializable (safest) & \textcolor{red}{x} & \textcolor{red}{x} & \textcolor{red}{x} \\
    Repeatable read & \textcolor{red}{x} & \textcolor{red}{x} & \textcolor{green}{v} \\
    Read committed & \textcolor{red}{x} & \textcolor{green}{v} & \textcolor{green}{v} \\
    Read uncommitted (unsafest) & \textcolor{green}{v} & \textcolor{green}{v} & \textcolor{green}{v} \\
    \hline
\end{tabular}

\paragraph{Properties}
\begin{itemize}
    \item Dirty read : Read of data written by a concurren uncommited transaction.
    \item Nonrepeatable read : re-read data and find it has been updated by
        another transaction that committed since the initial read.
    \item Phantom read : re-read and sees new inserted/deleted record by
        another transaction that commited since the initial read.
\end{itemize}

\paragraph{Serializable}
Serializable is the most safe solution because the observable 
result is the same as if T1 and T2 were serial\ldots but it's not 
the most efficient solution.

\section{Recovery}
\subsection{Aim of Recovery}

There are different type of failure such as system failures, transaction
failures and media failures.

\paragraph{$\Rightarrow$} The aim of recovery is to ensure \textbf{atomicity} 
(revert all transaction updates),\textbf{consistency} (roolback from a 
inconsistent state) and \textbf{durability}.


\subsection{Transaction log}

The key problem is the \textbf{unfinished transaction} ! The solution
is to use a transaction log and on failure recovery unfinished transaction 
have start but no commit nor abort record.

Three solution to make the transaction log :
\begin{enumerate}
    \item \textbf{Undo logging} (immediate changes) :
        \begin{itemize}
            \item Keep old value in the log records 
            \item Do the real update job on disk. 
            \item Undo operation can be done on failure recovery using the log.
        \end{itemize}

        \begin{tabular}{m{2cm}m{14cm}}
            Invariant &
        \begin{itemize}
            \item X new value flushed $\Rightarrow$ old value flushed in log
            \item $<T_i, commit>$ $\Rightarrow$ changes flushed on disk
            \item $<T_i, abord>$ $\Rightarrow$ undo changes flushed on disk
        \end{itemize}
    \end{tabular}

        \begin{tabular}{m{3cm}m{14cm}}
            order OUTPUT &
        \begin{enumerate}
            \item $<T_i, X, old>$ record first
            \item change database items themselves
            \item $<T_i, commit>$ 
        \end{enumerate}
    \end{tabular}

    \paragraph{Recovery}
    \begin{enumerate}
    \item S = set of transaction with $<T_i, start>$ in log but no $<T_i, commit>$
    (or $<T_i, abort>$)
    \item For each $<T_i, X, v>$ in log, in reverse order (latest $\to$ earliest) :
    
    $\Rightarrow$ if $T_i \in S$ then write(X, v) then output(X)

    \item For each $T_i \in S$ 

    $\Rightarrow$ write $<T_i, abort>$ to log then output if
    \end{enumerate}


    \item[Drawback] : Cannot commit transaction without lots of I/O and
        cannot use the log to bring backup database copies up to date.
    \item \textbf{Redo logging} (deferred changes) :
        \begin{itemize}
            \item Keep new values in log recodes 
            \item Do the real update on in memory (not the disk!). 
            \item Because update are not done on the disk,
                opetation can be redo on failure recovery thanks to the log.
        \end{itemize}

        \begin{tabular}{m{2cm}m{14cm}}
            Invariant &
        \begin{itemize}
            \item X new value flushed $\Rightarrow$ $<T_i, commit>$ flushed
            \item $<T_i, end>$ in log $\Rightarrow$ changed items flushed
        \end{itemize}
    \end{tabular}

        \begin{tabular}{m{3cm}m{14cm}}
            order OUTPUT &
        \begin{enumerate}
            \item $<T_i, X, new>$ record first
            \item $<T_i, commit>$ 
            \item change database items themselves
            \item $<T_i, end>$
        \end{enumerate}
    \end{tabular}

\paragraph{Recovery}
    \begin{enumerate}
    \item S = set of transaction with $<T_i, commit>$ in log but no $<T_i, end>$
    \item For each $<T_i, X, v>$ in log, in forward order (earliest $\to$ latest) :
    
    $\Rightarrow$ if $T_i \in S$ then write(X, v) then output(X)

    \item For each $T_i \in S$ 

    $\Rightarrow$ write $<T_i, end>$ to log then output it
    \end{enumerate}

    \item[Drawback] : Need to keep all modified block in memory until commit.
    \item \textbf{Both of them}

\end{enumerate}

\subsubsection{Checkpointing the log} To avoid very long transaction logs, periodically :
\begin{enumerate}
    \item Do not accept new transactions
    \item Wait until all transaction finish
    \item Flush all log record to disk
    \item Flush all buffers to disk
    \item Write ``checkpoint'' record on disk
    \item Resume transaction processing
\end{enumerate}
When a recovery must be done, it starts at the last checkpoint.

\subsection{Media failures}
%TODO
To cope with with Media Failure, there is no choice but making copies.
There are different techniques:
\begin{itemize}
	\item Triple redundancy (keep 3 copies on separate disks)
	\item Redundant writes/single reads
	\item Backup database + log
\end{itemize}


\section{Concurrency control}

A process can \textbf{read(X)} and \textbf{write(X)} without any assumption
on the sceduler.

\subsection{Transaction Schedule}
Two differents transactions are in conflict if they want to do an
operation on the same data item and one of the operation is a write.\\
Transation execute concurrently in an interleaved fashion, the order 
of execution in which they operates is known as the transaction
scedule. 
\subsection{Serializability}
\begin{enumerate}
    \item \textbf{Serial schedule}
        For every transaction T participating in the schedule, all the
        operations of T are executed consecutively in the schedule.
    \item \textbf{Serializable schedule}
        A schedule S is serializable :
        \begin{itemize}
            \item if it is equivalent to some serial 
                schedule of the same n transactions
            \item Allow interleaving of transcation operations
        \end{itemize}
\end{enumerate}

$\Rightarrow$ Serial and serializable schedule are correct (consistency of database).

\subsection{Equivalences} 
\begin{description}
\item[Conflict operation] Any pair of operations from two different transactions
on the same data item where at least on is a write
	\item[Result equivalent ] They produce the same final state of the
	database
	\item[Conflict equivalent] The order of any two conflicting operations
	 is the same in both schedules
	\item[Conflict serializable] Conflict equivalent to some serial schedule.
	(It can be tested throug a directed graph (slide 15 in 11a))
\end{description}

\begin{figure}[!h]
\centering
\begin{tikzpicture}
\node (A1) {$S_A$:};
\node (B1) [right=1pt of A1] {$r_1(X),$};
\node (C1) [right=1pt of B1] {$w_1(X),$};
\node (D1) [right=1pt of C1] {$r_1(Y),$};
\node (E1) [right=1pt of D1] {$w_1(Y),$};
\node (F1) [right=1pt of E1] {$w_2(X),$};
\node (G1) [right=1pt of F1] {$w_2(X),$};

\node (M1) [right=2cm of G1, draw, circle] {$T_1$};
\node (N1) [right=of M1, draw, circle] {$T_2$};

\draw (M1) edge[->, bend left] node[above] {x}(N1);
\draw (B1.north) edge[color=red, bend left=10] (G1.north);
\draw (C1.north) edge[color=red, bend left=10] (F1.north);

\node (A2) [below=of A1] {$S_B$:};
\node (B2) [right=1pt of A2] {$r_1(X),$};
\node (C2) [right=1pt of B2] {$r_2(X),$};
\node (D2) [right=1pt of C2] {$w_1(X),$};
\node (E2) [right=1pt of D2] {$r_1(Y),$};
\node (F2) [right=1pt of E2] {$w_2(X),$};
\node (G2) [right=1pt of F2] {$w_1(Y),$};

\node (M2) [right=2cm of G2, draw, circle] {$T_1$};
\node (N2) [right=of M2, draw, circle] {$T_2$};

\draw (M2) edge[->, bend left] node[above] {x}(N2);
\draw (N2) edge[->, bend left] node[above] {x}(M2);
\draw (B2.north) edge[color=red, bend left=10] (F2.north);
\draw (C2.north) edge[color=red, bend left=10] (D2.north);

\node (A3) [below=of A2] {$S_B$:};
\node (B3) [right=1pt of A3] {$r_1(X),$};
\node (C3) [right=1pt of B3] {$w_1(X),$};
\node (D3) [right=1pt of C3] {$r_2(X),$};
\node (E3) [right=1pt of D3] {$w_2(X),$};
\node (F3) [right=1pt of E3] {$r_1(Y),$};
\node (G3) [right=1pt of F3] {$w_1(Y),$};

\node (M3) [right=2cm of G3, draw, circle] {$T_1$};
\node (N3) [right=of M3, draw, circle] {$T_2$};

\draw (M3) edge[->, bend left] node[above] {x} (N3);
\draw (B3.north) edge[color=red, bend left=10] (E3.north);
\draw (C3.north) edge[color=red, bend left=10] (D3.north);

\end{tikzpicture}
\caption{Conflict example}
\end{figure}

\subsubsection{Lock}
Lock and unlock need to be atomic operation. And all transaction need 
to be well-formed:

\begin{itemize}
\item lock before making an opreation
\item don't lock what has already been lock
\item don't unlock what is not unlock
\end{itemize}

\begin{itemize}
    \item[\textbf{Mode}]
\begin{tabular}{p{14cm}}
        \begin{itemize}
    \item Read lock (X) : More than one transaction can share read lock on X but
        no write lock on X by other transaction
    \item Write lock (x) : only one write lock on X
\end{itemize}
\end{tabular}
    \item[\textbf{Conversion}]
\begin{tabular}{p{13cm}}
        \begin{itemize}
    \item Lock upgrade : read lock on X to write lock on X (Need to have only
        one read lock on X)
    \item Lock downgrade : from write lock on X to read lock on X
\end{itemize}
\end{tabular}
\end{itemize}

\paragraph{Transactions requirement}
A transaction should be well-formed : lock data before access them, does not lock 
an already locked data item and not try to unlock an unlocked data item.

\subsubsection{Two-phase locking}
\begin{enumerate}
    \item Growing phase : Transaction applies locks on desired data item one at a time
        \begin{itemize}
            \item \textbf{Basic} : incrementally lock during execution (but may cause deadlock)
            \item \textbf{Conservative} : All-or-nothing locks before transactions begins execution
        \end{itemize}
    \item Shrinkin phase : Transaction unlock ressource
\end{enumerate}

\subsubsection{Deadlock}
The scheduler maintains a \textbf{wait-for-graph} and if he detect a cycle
then a deadlock exist. In this case, one transaction involved in the cycle
is selected and rolled-back.

\subsection{Timestamps (TS)}
Variable which is monotonically increase to indicate the age of an
operation/transaction.

To guarantee conflict serializability because we can detect
conflicting operation occuring in incorrect order.

\begin{enumerate}
    \item Transaction T issues a write(X) operation :
        \begin{itemize}
            \item If read\_TS(X) > TS(T) or write\_TS(X) > TS(T) $\to$ roll-back T 
                because a younger transaction has already read/wrote X
            \item Else execute write(X) and write\_TS(X) = TS(T)
        \end{itemize}
    \item Transaction T issues a read(X) operation :
        \begin{itemize}
            \item If write\_TS(X) > TS(T) $\to$ roll-back T 
                because a younger transaction has already wrote X
            \item Else execute read(X) and read\_TS(X) = max(TS(T), read\_TS(X))
        \end{itemize}
\end{enumerate}

\section{Storage}
\begin{description}
	\item[Primary Storage :] This category includes storage media that can be
	operated on directly by the computer CPU. Usually provides fast access
	to data but is of limited storage capacity.
	\item[Secondary Storage :] This category includes SSD disks,
	 optical disk,tape... Cannot be processed by the CPU must first copied 
	 in primary storage (slower access).
\end{description}
%\url{http://mathcomp.uokufa.edu.iq/staff/kbs/file/2/Fundamentals\%20of\%20Database\%20Systems\%20-\%20Ramez\%20Elmasri\%20&\%20Navathe.pdf}

\subsection{Disk}

\paragraph{Terminology}
Information is stored on a disk surface s.t.
\begin{itemize}
\item \textbf{Track} : Concenctric circles of small widith, each having a distinct diameter
\item \textbf{Cylinder}: Packs the tracks with the same diameter on the various surfaces.
\item \textbf{Sector} : Part of a track with fixed-size (it is hard-coded on the disk surface and cannot be
        changed)

\item \textbf{Blocks} : The operating system also divides the track into equal-sized disk.
(The size is fixed at initialization and cannot be changed dynamically)

    \item \textbf{Gap} : Blocks are separated by fixed-size which contains information to 
    determine which block on the track follows each gap.
    \item \textbf{Head} : used to read/write on the disk and its attached to 
    a mechanical arm. 
    \item Each arms are connected to an \textbf{actuator} which
    moves the heads over cylinder of tracks.
    \end{itemize}


    Access time 
\begin{tabular}{p{6cm}|cc}
     & DDR & SSD \\
 = Seek time (moving the head) & 4ms $\to$ 15 ms& 0.08ms $\to$ 0.16ms \\
    + Rotation delay & (2ms $to$ 7ms) & 0 \\
    + Transert rate & 1000Mbit/sec & 3000Mbit/sec \\
\end{tabular}

\subsubsection{Double buffering}
When blocks transfering block from disk to main memory, use
several buffer to speed up the process. The idea is, while one 
buffer is being read/written, the CPU can process the data in an 
other buffer.


\paragraph{Note :} Only possible if there is a an I/O processor 
independent of the CPU



\subsection{Disk organisation}

\begin{figure}[!h]
    \centering
\begin{tikzpicture}
	\node[text width=2.5cm,align=center, draw, rectangle] (A) {Data item};
	\node[text width=2.5cm,align=center, draw, rectangle] (B) [right= of A] {Records};
	\node[text width=2.5cm,align=center, draw, rectangle] (C) [right= of B] {Blocks};
	\node[text width=2.5cm,align=center, draw, rectangle] (D) [right= of C] {Files};
	\path[->] (A) edge (B)
                (B) edge (C)
                (C) edge (D);

\end{tikzpicture}
\caption{Disk organisation}
\end{figure}



\subsubsection{Data items} 
The data item is its value (fixed/variable length) and has a type that
tell us how to interpre it and its representation size.
\subsubsection{Records} 

Collection of related data item called field. A format specified how to read
this record.

\begin{itemize}
    \item Fixed format : Defined in advance by the algorithm
    \item Variable format : Some byte is used before the
        record to say how to read it\ldots

        Useful but may waste space
\end{itemize}

\subsubsection{Blocks} 
\begin{itemize}
    \item \underline{Separate record} : 
        \begin{enumerate}
            \item Used fixed size for the record (no need to separate)
            \item Use special marker
            \item Give record lengths (within each record or in block header)
        \end{enumerate}
    \item \underline{Unspanned} : record must be within one block. 

        Simpler but may waste space.
    \item \underline{Spanned} : essential if record size > block size.
    In that case, a pointer at the end of the first block points to 
    the block containing the remainder of the record.

        Sequencing options :
        \begin{enumerate}
            \item Next record physically contiguous
            \item Linked (after the record there is the reference to the next one)
            \item Overflow area : It is used to store new records
            without rewriting the sequential file. References to the new
            records are placed in the header of the file.
            \item Indirection 
        \end{enumerate}
\end{itemize}

\subsubsection{Files} 
\begin{enumerate}
    \item Heap files : Not sorted, insertion at the end
        \begin{itemize}
            \item Searching for a record is done in a linear search.
            \item May lead to wasted storage space (when deleting a record
            it leaves a ''hole''.)
            \item Require periodic reorganization.
        \end{itemize}
    \item Sorted files : Record are contained in a certain order.
        \begin{itemize}
            \item Sorting based on a ordering field. (If this field is the key 
            then it's a called an ordering fields).
            \item Search more efficient. (logharitmic)
        \end{itemize}
    \item Hash files : Similar to hashtables 
        \begin{itemize}
            \item Hashing based on hash field (if key field then it is called
            an hash key).
            \item Very fast acces to records.
        \end{itemize}
\end{enumerate}

There are many operations that can be done on the files such 
as OPEN,READ,DELETE,...

\subsection{Indexing}
An index is an auxiliary file that makes it more
efficient to search for records in the data file. 
(index file size $<<<$ data)
\begin{center}<field value, pointer>\end{center}

%%TODO : example no index vs with index
\begin{tabular}{|p{8cm}|p{8cm}|}
\hline
\multicolumn{1}{|c|}{\textbf{Without index}} & \multicolumn{1}{c|}{\textbf{With index}}\\
\hline
\multicolumn{2}{|c|}{r = 30 000 records}\\
\multicolumn{2}{|c|}{R = 100 bytes (record size)}\\
\hline
\begin{itemize}
	\item B(lock) = 1024 bytes
	\item Blocking factor = B/100 =~10 records per block
	\item Binary search = $log_2(3000)$ = 12
\end{itemize}
&
\begin{itemize}
	\item V = 9 bytes (ordering key size)
	\item P = 6 bytes(logical pointer size)
	\item B(lock) = 1024 bytes
	\item Blocking factor = B/15 =~67
	\item Binary search = $log_2(45) $+1 =7
\end{itemize}
\\
\hline
$\Rightarrow$ number of access 12 &$\Rightarrow$  number of access 7\\
\hline
\end{tabular}

\paragraph{Type}
\begin{itemize}
    \item Dense index : index for \textbf{every key value} in the data file
    \begin{itemize}\item[$\to$] can tell if record exist without accessing file \end{itemize}
    \item Sparse index : index for some search value
\end{itemize}


\subsubsection{Primary index}
\begin{tabular}{m{7cm}m{8cm}}
\begin{itemize}
    \item The data file must be ordered on a key field
    \item One index entry for each block in the data file
        $\to$ \textbf{sparse index}
        (Keys of anchor 
        record rather than every search value)
    \item Major problem with insertion and deletion of record
\end{itemize}
&
\includegraphics[width=6cm]{img/primary.png}
\end{tabular}

\subsubsection{Clustering index}
\begin{tabular}{m{7cm}m{8cm}}
\begin{itemize}
    \item The data file must be ordered on a non-key field (cluster field)
    \item One index entry for each distinct value with that field value
    (block pointer points to the first occurence of this value)
        $\to$ \textbf{sparse index} 
\end{itemize}
&
\includegraphics[width=6cm]{img/clustering.png}
\end{tabular}

\subsubsection{Secondary index}
\begin{tabular}{m{7cm}m{5cm}m{5cm}}
\begin{itemize}
    \item Accessing a file for which some
        primary access already exists.(can be several for the same file)
        \begin{enumerate}
            \item With a candidate key
            \item or a non-key with duplicate values
        \end{enumerate}
    \item Composed of two field : data type and (block pointer or recorde pointer)
    \item One entry for each record $\to$ \textbf{dense index}
\end{itemize}
&
\includegraphics[width=5cm]{img/secondary1.png}
&
\includegraphics[width=5cm]{img/secondary2.png}
\end{tabular}

\subsubsection{Multi-level index}
\begin{tabular}{m{7cm}m{8cm}}
\begin{itemize}
    \item Multi-level index is done with a B-Tree data structure
        by repeat a primary/clustering index on multiple level 
    \item[]
    \item[Remarque:] Multi-level is is useless if add levels don't separate they element in
        different block
\end{itemize}
&
\includegraphics[width=6cm]{img/multi.png}
\end{tabular}


\paragraph{B-Tree and B+-Tree}

%TODO quick explanation on how B tree work

\begin{figure}[!h]
\centering
\includegraphics[width=6cm]{img/btree.png}
\caption{B-tree}
\end{figure}

B-Tree solve the problem to insert and delete new entries in
a multi level which must be ordered. (In this data-structure
these operation are quite efficient)

\begin{itemize}
    \item Insert element in a node an split it in two node if the 
        node is full (Splitting may propagate to other levels)
    \item Deleted element from a node and if he become less than
        half full merged it with neighboring nodes.
\end{itemize}


\paragraph{ } B-Tree are pointers on \textbf{all level} of the three
where B+-Tree are pointer only at the \textbf{leaf level}

\subsubsection{Using indexes}
%TODO ?

\section{Query processing}
\begin{description}
	\item[Query processing] The process of translating from a high-level
	query language to actual data access.
	\item[Query optimization] The process of choosing a suitable execution
	strategy for processing a query.
\end{description}
Two internal representations of a query : Tree or Graph.

\begin{center}
\includegraphics[width=9cm]{img/query.png}
\end{center}

\subsection{SQL $\to$ Relationnal algebra}

Query block (Single SELECT-FROM-WHERE [GROUP BY] [HAVING]) is the basic unit
that can be translated into \textbf{algebraic operator}.\\
Nested query within query are indentified as separate query blocks.

\subsection{Relationnal algebra $\to$ Data access}
For every abstract algebra operator (RESTRICT, PROJECT, JOIN,\ldots),
various algorithms exist (Sort-driven, hash-driven, loop-driven).

\subsubsection{External Sorting}
\begin{itemize}
	\item External sorting refers to sorting algorithms that are suitable for 
	large file of records on disk that do no fit in main memory.
	\item It uses sort-merges strategy, it consist of sorting small subfiles
	(runs) then merges them.
	%TODO cost?
\end{itemize}
\subsubsection{Restrict}
There are diffent algorithm that can be use to implement the restrict
\begin{itemize}
	\item Linear search: Check on every record, if it satisfy a condition
	\item Binary search : If restriction condition involves
	 a equality comparison on a key attribute and the file is ordered.
	\item Primary index (or hash key) : if restriction condition involves
	equality comparison on a key attribute witth a primary index.
	\item Primary index to retrieve multiple record: If there is a 
	comparaison condition other that = on a key field with primary index.
	\item Cluster index to retrieve multiple record : Restriction 
	involves an equality comparison on a non-key attribute with clustering
	index.
\end{itemize}
If the condition involves only one attribute , the brute force linear 
search is used if there is no access path.\\
If the condition involves many attributes, it's the role of the query 
optimization to choose the best access path. 

\subsubsection{Join}
Different techniques to implement the join
\begin{itemize}
	\item Nested-loop join : Test the join codition t[A] = s[B] for every pair 
	of record (where A and B are domain-compatible attribute and t and s
	are record for R and S).
	\item Single-loop join: If a index exists for one of the two join
	attributes, use access structure to retrieve all matching records
	that satisfy join condition.
	\item Sort-merge join : %TODO
	\item hash-join : %TODO

\end{itemize}

\subsubsection{Project}
%TODO
\subsubsection{Set}
%TODO
\subsection{Pipelining Operations}
%TODO
\subsection{Query Optimization}
%TODO

\section{NoSQL}

No SQL has been created to answer the problem of the scalabilility/
velocity/volume of data.  Goal is not replace RDBMS but rather act
as a complement.\\
Oriented on aggregate which is a collection of related objects that 
treated as a unit.\\
There are four basic type of database:
\begin{description}
	\item[Key/value]: Similar to a hashmap. Data are represented by 
	key/value couple. All intelligence is left to the querier. Basic 
	operation are : PUT,GET,DELETE.
	\item[Column-family Stores]: The number of column is variable. It allows
	to avoid NULL value. To achieve this variation in the number of column,
	many columns are associated with a row key.
	\item[Document] Based on the key/value paradigme. Value is a document
	(JSON or XML). It's easy with only the key , to get information 
	organized in a hierarchical way.
	\item[Graph] Entities are stored as node and relation are depicted via
	the edges.
\end{description}
\url{http://blog.neoxia.com/nosql-5-minutes-pour-comprendre/}

\subsection{Data Distribution}
%TODO

\section{Puzzles}
\subsection{E1}
Get supplier numbers for suppliers who supply part P1.
\begin{lstlisting}
(SHIPMENTS WHERE PID=P#("P1")) {SID}

SELECT sid FROM SHIPMENTS WHERE shipments.pid = 'P1';
\end{lstlisting}

\subsection{E2}
Get how many shipments there are.
\begin{lstlisting}
RELATION { TUPLE { C COUNT(SHIPMENTS)}}

SELECT count(*) AS c FROM SHIPMENTS;
\end{lstlisting}

\subsection{E3}
Get how many parts are supplied by supplier S1.
\begin{lstlisting}
RELATION { TUPLE { C COUNT(SHIPMENTS WHERE SID=S#("S1")) }}

SELECT count(*) AS c FROM SHIPMENTS WHERE shipments.sid='S1';
\end{lstlisting}

\subsection{E4}
Get suppliers who supply at least one part.
\begin{lstlisting}
(SUPPLIERS  JOIN SHIPMENTS) {SID, NAME, STATUS, CITY}

SELECT * 
FROM suppliers AS s 
WHERE s.sid IN (SELECT sh.sid FROM shipments AS sh);
\end{lstlisting}

\subsection{E5}
Get suppliers who supply no part at all.
\begin{lstlisting}
(SUPPLIERS NOT MATCHING SHIPMENTS)

SELECT DISTINCT s.sid, s.name, s.status, s.city 
FROM suppliers AS s 
WHERE s.sid NOT IN (SELECT sid FROM shipments);
\end{lstlisting}

\subsection{E6}
Get shipments together with the name of the supplier
(sname) and the name of the part (pname)
\begin{lstlisting}
( SUPPLIERS{SID, NAME}  RENAME {NAME AS SNAME} JOIN SHIPMENTS JOIN PARTS{PID, NAME} RENAME {NAME AS PNAME}) 

SELECT s.name AS sname, s.sid, p.name AS pname , p.pid, sh.qty
FROM suppliers AS s, shipments AS sh, parts AS p 
WHERE (s.sid=sh.sid AND sh.pid=p.pid);
\end{lstlisting}

\subsection{M1}
Get the 'total' quantity of parts supplied by supplier S1.
\begin{lstlisting}
RELATION { TUPLE { total SUM( (SHIPMENTS WHERE SID=S#('S1')), QTY) }}

SELECT SUM(sh.qty) AS total 
FROM shipments AS sh 
WHERE sh.sid = 'S1';
\end{lstlisting}

\subsection{M2}
Get part numbers for parts supplied by at least one
supplier in Paris.
\begin{lstlisting}
(SHIPMENTS JOIN (SUPPLIERS WHERE CITY = 'Paris')) {PID}

SELECT DISTINCT p.pid 
FROM suppliers AS s, shipments AS sh, parts AS p 
WHERE (s.city='Paris' AND s.sid=sh.sid AND p.pid = sh.pid );
\end{lstlisting}

\subsection{M3}
Get city names for cities in which at least two suppliers
are located.
\begin{lstlisting}
( (SUPPLIERS{SID, CITY} GROUP{SID} AS C)  WHERE COUNT(C) >= 2 ) {CITY}

SELECT DISTINCT s.city 
FROM suppliers AS s 
WHERE ( SELECT count(*) 
    FROM suppliers As s2 
    WHERE s.city=s2.city ) > 1 ;
\end{lstlisting}


\subsection{M4}
Get supplier numbers for suppliers whose city is first in
the alphabetic list of such cities.
\begin{lstlisting}
( SUPPLIERS WHERE CITY=MIN(SUPPLIERS{CITY}, CITY) ) {SID, CITY}

SELECT s.sid, s.city
FROM suppliers AS s 
WHERE s.city IN ( SELECT city 
    FROM suppliers AS s2 
    ORDER BY city ASC LIMIT 1);
\end{lstlisting}


\subsection{M5}
Get the supplier numbers and the 'total' quantity of
supplied parts for each of them.
\begin{lstlisting}
SUMMARIZE  SHIPMENTS PER (SUPPLIERS{SID}) : { total := SUM(QTY)}

SELECT DISTINCT s.sid, (SELECT COALESCE(SUM(sh.qty), 0) AS total 
      FROM shipments AS sh 
      WHERE sh.sid = s.sid) 
FROM suppliers AS s;
\end{lstlisting}


\subsection{M6}
Get the number(s) of lightest part(s). In case of ex-
aequo, get all parts with that smallest weight.
\begin{lstlisting}
( PARTS WHERE WEIGHT=MIN(PARTS{WEIGHT}, WEIGHT) ) {PID} 

SELECT p.pid 
FROM parts AS p 
WHERE p.weight IN (SELECT min(p2.weight) 
     FROM parts AS p2);
\end{lstlisting}

\subsection{D1}
Get part numbers for parts not supplied by any supplier in Paris.
\begin{lstlisting}
(SUMMARIZE SHIPMENTS JOIN SUPPLIERS WHERE (CITY = 'Paris') PER (PARTS{PID}) : {supparis  := COUNT()} WHERE supparis=0) {PID}

SELECT p.pid 
FROM parts AS p 
WHERE p.pid NOT IN (    SELECT sh.pid 
    FROM shipments AS sh, suppliers AS s 
    WHERE sh.pid = p.pid AND s.sid = sh.sid AND s.city='Paris');
\end{lstlisting}


\subsection{D2}
Get numbers of suppliers who supply all parts.
\begin{lstlisting}
(SUMMARIZE SHIPMENTS JOIN PARTS PER (SUPPLIERS{SID}) : {supall  := COUNT()} WHERE supall= (COUNT(PARTS))) {SID}

SELECT s.sid FROM suppliers AS s WHERE (SELECT DISTINCT count(p.pid) FROM parts AS p) = (SELECT DISTINCT count(sh.pid) FROM shipments AS sh WHERE sh.sid = s.sid);
\end{lstlisting}


\subsection{D3}
Get supplier for suppliers with a status strictly lower
than of supplier S1.
\begin{lstlisting}
SUPPLIERS WHERE STATUS < (MIN((SUPPLIERS WHERE SID=S#("S1")), STATUS))

SELECT * FROM suppliers AS s WHERE s.status < ( SELECT s2.status FROM suppliers AS s2 WHERE s2.sid='S1'); 
\end{lstlisting}


\subsection{D4}
Get supplier-number/part-number pairs such that the
indicated supplier does not supply the indicated part.
\begin{lstlisting}
(SUMMARIZE SHIPMENTS  PER (SUPPLIERS{SID} JOIN PARTS{PID}) : {supall  := COUNT()} WHERE supall=0 ){SID, PID}

SELECT DISTINCT s.sid,p.pid FROM suppliers AS s, parts AS p WHERE p.pid NOT IN (SELECT sh.pid FROM shipments AS sh WHERE sh.sid=s.sid);

\end{lstlisting}


\subsection{D5}
Get every known city together with the count of parts
located in that city ('ps'), the count of suppliers located
there ('ss'), and the total shipped quantity by the latter
('total').
\begin{lstlisting}
SELECT c.city, 
    (SELECT count(p.pid) AS ps FROM parts AS p WHERE p.city = c.city), 
    (SELECT count(s.sid) AS ss FROM suppliers AS s WHERE s.city = c.city), 
    (SELECT COALESCE(SUM(sh.qty), 0) AS total FROM shipments AS sh, suppliers AS s WHERE s.city = c.city AND s.sid=sh.sid) 
FROM ((SELECT s.city FROM suppliers AS s) UNION (SELECT p.city FROM parts AS p)) AS c GROUP BY c.city; 
\end{lstlisting}

\subsection{D6}
Get the heaviest part. In case of ex-aequo, select the
one with the smallest part number.
\begin{lstlisting}
(PARTS WHERE PID=MIN(PARTS WHERE WEIGHT=MAX(PARTS{WEIGHT}, WEIGHT), PID) ) {PID} 

SELECT MIN(p.pid) AS pid FROM parts AS p WHERE p.weight IN (SELECT MAX(p.weight) FROM parts AS p);
\end{lstlisting}



\section{Annexe I - Tutoriel D}

\subsection{Operators}

\begin{figure}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Logic} & \textbf{Tutorial D}\\
\hline
AND & JOIN \\
& WHERE (restriction, aka selection or $\sigma$)\\
& EXTEND (extension)\\
& SUMMARIZE\\
& and some more\\
\hline
EXISTS & \{...\} (projection aka $\pi$)\\
\hline
OR & UNION\\
\hline
(AND) NOT & MINUS (difference)\\
& NOT MATCHING (semi-difference)\\
\hline
& RENAME\\
\hline
\end{tabular}
\caption{Tutoriel D Operators}
\end{figure}

\subsubsection{JOIN}

Let $s = r_1\ JOIN\ r_2$, then the body of s consists of those tuples having heading H that can be formed by taking the union of $t_1$ and $t_2$, where $t_i$ is a tuple of $r_i$.

\begin{itemize}
\item It is cummutation: $r_1\ JOIN\ r_2 \equiv r_2\ JOIN r_2$
\item It is associative: ($r_1\ JOIN\ r_2)\ JOIN\ r_3\equiv r_1\ JOIN\ (r_2\ JOIN\ r_3)$
\end{itemize}

\subsubsection{RENAME}

Let $s = r\ RENAME\ \{A_1\ AS\ B_1, ..., A_n\ AS\ B_n\}$, then the heading of $s$ is the heading of $r$ except that attribute $A_i$ is renamed to $B_i$.

\subsubsection{EXISTS}

Let $s = r\{A_1, ..., A_n\} = r\{ALL\ BUT\ B_1, ..., B_m\}$, then the heading of $s$ is the subset of the heading of $r$ given by $\{A_1, ..., A_n\}$. The body of $s$ consists of each tuple that can be formed from a tuple of $r$ by removing from it the attributes named $B_1, ..., B_m$.

\subsubsection{WHERE}

Let $s = r\ WHERE\ c$, where $c$ is a conditional expression on attributes of r. The heading of $s$ is the heading of $r$ and the body of $s$ consists of those tuples of $r$ for which the condition $c$ evaluates to TRUE. It is a subset of $r$.

\subsubsection{EXTEND}

Let $s = EXTEND\ r:\{formula_1\ AS\ A_1, ..., formula_n\ AS\ A_n\}$, then the heading of $s$ consists of the attributes of the heading of $r$ plus the attributes $A_1, ..., A_n$. The declared type of attribute $A_k$ is that of formula-k. 

The body of $s$ consists of tuples formed from each tuple of $r$ by adding $n$ additional attributes $A_1$ to $A_n$. The value of attribute $A_k$ is the result of evaluating $formula_k$ on the corresponding tuple of $r$.

\subsubsection{UNION}

Let $s = r_1\ UNION r_2$, then $r_1$ and $r_2$ must have the same heading. The heading of $s$ is the common heading of $r_1$ and $r_2$. The body of $s$ consists of each tuple that is either a tuple of $r_1$ or a tuple of $r_2$.

\subsubsection{NOT MATCHING}

Let $s = r_1\ NOT\ MATCHING\ r_2$, then the heading of $s$ is the heading of $r_1$. The body of $s$ consists of each tuple of $r_1$ that matches no tuple of $r_2$ on their common attributes.

$MINUS$ is like $NOT\ MATCHING$.

\subsubsection{Other useful operators}

\begin{itemize}
\item MATCHING
\item COMPOSE
\item GROUP/UNGROUP
\item UPDATE
\end{itemize}

\subsection{Examples}

\subsubsection{Create and destroy variables}

\begin{lstlisting}
VAR ENROLMENT BASE RELATION
    {StudentId SID,
     Name CHAR}
    KEY {StudentID};

DROP VAR ENROLMENT;
\end{lstlisting}

\subsubsection{Integrity Rules}

\begin{lstlisting}
CONSTRAINT MAX_ENROLMENTS
    COUNT(ENROLMENT) <= 20000;

DROP CONSTRAINT MAX_ENROLMENTS;
\end{lstlisting}

\subsubsection{Update variables}

\begin{lstlisting}
DELETE ENROLMENT WHERE StudentId = SID('S4');

UPDATE ENROLMENT WHERE StudentId = SID('S1')
    Name := 'Jean';

INSERT ENROLMENT
    RELATION{
        TUPLE{StudentId SID('S4'),
                    Name 'Devinder',
                    CourseId CID('C1')
        }
    };
\end{lstlisting}

\subsubsection{Query}

\begin{lstlisting}
(ENROLMENT WHERE CourseId = CID('C1'))
    {StudentId, Name}
\end{lstlisting}

\subsubsection{Operator definition}

\begin{lstlisting}
OPERATOR HIGHER_OF(A INTEGER, B INTEGER)
        RETURNS INTEGER;
    IF A > B 
            THEN RETURN A;
            ELSE RETURN B;
    END IF;
END OPERATOR;
\end{lstlisting}

\subsubsection{A Relation Literal}

\begin{lstlisting}
RELATION {
    TUPLE{ StudentId SID('S1'), CourseId CID('C1'), Name NAME('Anne')    },
    TUPLE{ StudentId SID('S1'), CourseId CID('C2'), Name NAME('Anne')    },
    TUPLE{ StudentId SID('S2'), CourseId CID('C1'), Name NAME('Boris')   },
    TUPLE{ StudentId SID('S3'), CourseId CID('C3'), Name NAME('Cindy')   },
    TUPLE{ StudentId SID('S4'), CourseId CID('C1'), Name NAME('Devinder')}
}
\end{lstlisting}

\subsubsection{Aggregate Operators}

\begin{lstlisting}
SUM(EXAM_MARK, Mark) = 342
AVG(EXAM_MARK, Mark) = 68.4
MAX(EXAM_MARK, Mark) = 93
MIN(EXAM_MARK, Mark) = 49
\end{lstlisting}

\subsubsection{Summarize}

\begin{lstlisting}
SUMMARIZE EXAM_MARK BY{CourseID}:{
    TopScore := MAX(Mark)
}
SUMMARIZE EXAM_MARK PER(COURSE{CourseID}):{
    Takers: COUNT()
}
\end{lstlisting}

\subsubsection{Primary and Foreign Key}

\begin{lstlisting}
VAR EXAM_MARK BASE RELATION {
    StudentId SID,
    CourseId CID,
    Mark INTEGER
}
KEY{StudentId, CourseId};


VAR IS_CALLED BASE RELATION {
    StudentId SID,
    Name CHAR
}
VAR IS_ENROLLED_ON BASE RELATION {
    StudentId SID,
    CourseId CID
}
FOREIGN KEY{CourseId} REFERENCING IS_CALLED;
\end{lstlisting}


\subsubsection{Constraint declaration}

\begin{lstlisting}
CONSTRAINT Marks_out_of_100 IS_EMPTY
(EXAM_MARK WHERE Mark < 0 OR Mark > 100);

DROP CONSTRAINT Marks_out_of_100 ;
\end{lstlisting}


\section{Annexe II - Postgresql}

We are going to compare operators with Postgresql

\subsection{Operators}


\subsubsection{JOIN}
\begin{lstlisting}[title=Tutoriel D]
IS_CALLED JOIN IS_ENROLLED_ON
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.student_id, C.name, I.course_id
FROM is_called AS C,
    is_enrolled_on AS I
WHERE C.student_id = I.student_id
\end{lstlisting}

\subsubsection{RENAME}
\begin{lstlisting}[title=Tutoriel D]
IS_CALLED RENAME {StudentId as Sid1}
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.student_id AS sid1, C.name
FROM is_called AS C
\end{lstlisting}

\subsubsection{EXISTS}
\begin{lstlisting}[title=Tutoriel D]
IS_ENROLLED_ON{StudentId}
\end{lstlisting}

\begin{lstlisting}[title=SQL, language=sql]
SELECT S.student_id FROM students AS S
WHERE EXISTS (
    SELECT * FROM is_enrolled_on AS I
    WHERE I.student_id = S.student_id
)   

-- Alternative

SELECT S.student_id FROM students AS S
WHERE S.student_id IN (
    SELECT I.student_id FROM is_enrolled_on AS I
)
\end{lstlisting}

\subsubsection{WHERE}
\begin{lstlisting}[title=Tutoriel D]
IS_CALLED WHERE Name=NAME('Boris')
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.student_id, C.name
FROM is_called AS C
WHERE C.name = 'Boris'
\end{lstlisting}

\subsubsection{EXTEND}
\begin{lstlisting}[title=Tutoriel D]
EXTEND IS_CALLED : {
    Initial := SUBSTRING (THE_NAME(Name),0,1)
}
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.student_id, C.name, substring(C.name, 1, 1) AS initial
FROM is_called AS C
\end{lstlisting}

\subsubsection{SUMMARIZE}
\begin{lstlisting}[title=Tutoriel D]
SUMMARIZE EXAM_MARK BY { CourseId } : {
TopScore := MAX(Mark)
}
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT M.course_id, max(M.mark) AS top_score
FROM exam_mark AS M
GROUP BY M.course_id
\end{lstlisting}

\begin{lstlisting}[title=Tutoriel D]
SUMMARIZE EXAM_MARK PER (COURSE{CourseId}) : {
    Takers := COUNT()
}
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.course_id,
    count(*) AS takers
FROM course AS C
JOIN exam_mark AS M ON M.course_id = C.course_id
GROUP BY C.course_id
\end{lstlisting}

\subsubsection{UNION}
\begin{lstlisting}[title=Tutoriel D]
(IS_CALLED WHERE Name=NAME('Devinder')){StudentId} 
UNION 
(IS_ENROLLED_ON WHERE CourseId=CID('C1')){StudentId}
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.student_id FROM is_called AS C
WHERE C.name='Devinder'
UNION SELECT I.student_id FROM is_enrolled_on AS I
WHERE I.course_id='C1'
\end{lstlisting}

\subsubsection{NOT MATCHING}
\begin{lstlisting}[title=Tutoriel D]
IS_CALLED NOT MATCHING IS_ENROLLED_ON
\end{lstlisting}

\begin{lstlisting}[title=SQL]
SELECT C.student_id, C.name
FROM is_called AS C
WHERE NOT EXISTS (
    SELECT * FROM is_enrolled_on AS I
    WHERE I.student_id=C.student_id 
)
\end{lstlisting}

\subsubsection{Other useful operators}

\begin{itemize}
\item DISTINCT
\end{itemize}

\section{Exam}

\subsection{FB}
%\begin{lstlisting}
%- FD et BCNF et donner le compromis entre les 2 : certaines FD peuvent être perdue en passant vers le BCNF.
%- Une query à faire en Tuto D et SQL sur les suppliers and parts : donner les SID des suppliers qui ont un status plus grand que le status du supplier S1.
%- Expliquer le REDO loggin pour les transactions et ce que ça implique sur les propriétés ACID.
%
%
%-expliquer le two-phase locking
%
% 1) Physical data independence : define it and explain according to relational model
%2) Devoir 2 (SQL + TutorialD) : City name where there is at least two suppliers
%3) Indexes : the purpose, how, why + example
%
%1) Relvar + normalization : rule with dependant and key
%2)M2 : Get the pairs of parts such the two parts have the same supplier. (sql+ tutoD)
%3) Undo : everything (table, how why invariants)
%
%
%1. What is the C in ACID ? What's the link between the C and the logical level ? What are the strengths and weakness of SQL and Tutorial D to enforce C ? What operators can you use in SQL to enforce C ?
%2. Using pre-defined methods in Tutorial D, implement the IMAGE function such that
%
%s= IMAGE r {S1 AS a1, S2, as a2, ...}
%The header of s is the header of r plus one attribute named aj for each relation Sj
%Si is a relation
%The body of s consists of the body of r for the corresponding attributes and has a relation defined by Si for each further attribute
%Ex:
%
%(le format de fb pue)
%Suppliers:
%SID City Name
%1 LLN Smith
%2 Bxl Adam
%
%Parts
%PID Name
%1 Part1
%2 Part2
%
%Shipments
%SID PID QTY CITY
%1 1 30 BXL
%2 1 10 BXL
%2 2 20 LLN
%
%Then IMAGE Suppliers {Shipments{Pid, City} as S1, …} gives
%SID City Name S1
%1 LLN Smith { : Pid
%2 }
%2 BXL Adam { : Pid
%1
%2 }
%(je suis plus tout a fait sur de l'exemple...)
%En gros il faut utiliser Extend.
%
%3. What are the main goals we want to achieve with normalization ? (orthogonality, redundancy, udate anomalies)
%
%
%1- What is the meaning of lossless decomposition in normalization .... Anchor your answers with JD and FD.
%2- we have a relation that contains QusetionId as integer .... write using Tutorial D a constraint that makes sure this integer is starting from 1 and increasing in Ascending order ..... then just explain how you can do that constraint in SQL.
%3- What is the purpose of concurrency control ... and what is the meaning of serializable schedule.
%
%Définition de IMAGE en utilisant les opérateurs de Tutorial D :
%EXTEND r : {
%A1 := ( r1 COMPOSE RELATION { TUPLE { common_attr } } );
%A2 := ( r2 COMPOSE ... ) ;
%}
%
%1) Explain normalization tradeoff between dependency preservation and relvars in BCNF. Begin by explaining roughly (oui en gros) what is a FD and BCNF.
%2) Get supplier numbers where status lower than status of supplier S1
%3) REDO logging in terms of ACID + explain roughly how it works (no need of invariant)
%A&C en quoi c'est garanti dans tous les scénarios possible grâce au logging (en précisant bien que A => C)
%
%\end{lstlisting}


\subsection{Expliquer pourquoi l'implémentation des views dans PostGreSQL brise la règle de Logical Dependencies}


\subsection{Donner les avantages et inconvénients des databases JSON suivant certains requirements}
\begin{itemize}
	\item Communiquer directement avec la DB).
    \item JSON comme une base de données (like NoSQL). Mais ce n'est pas relationnel -> c'est la merde de mettre ca dans un type de base de données relationnel (pas 1NF)
    \item compare c'est la merde
    \item si tu chopes un JSON pour ta DB, tu peux le save
    \item si TYPE en REL, on peut ajouter des opérateurs
\end{itemize}

\subsection{Atomicity of ACID}
La transaction est vue comme une seule transaction, même si elle est constituée de plein de petites transactions. Donc, l'atomicité consiste à voir une trnsaction comme si c'était une seule opération. De ce fait, soit la transaction réussi et est effectuée, soit la transaction plante et donc, rien n'est fait (comme si on avait pas fait de tansaction).

Pour assurer l'atomicité (quand une transaction plante) :
\begin{itemize}
  \item Undo log : reverse action déjà faites
  \item Redo log : je retente les actions déjà faites
  \item mélange de undo/redo : je fais une soupe
  \item rollback/checkpoint : plus nouvelles transactions.  Quand fini, checkpoint (sauve DB) et je reviens la si c'est la merde
  \item Backup DB : j'utilise mon backup
\end{itemize}

\subsection{Consistant of ACID}
Les contraintes doivent toujours être vérifiées.\\
Commit se fait que si toutes les contraintes sont vérifiées.\\
Rollback on revient au dernier état consistant.\\
\subsection{Isolation of ACID}
Toutes les transactions sont serializable ().\\
Implémenté avec des LOCK.  Read Only et Write Only.  Toujours dans le même ordre sont pris les lock.\\


\subsection{Les DB sont basées sur la théorie des ensembles.  Montrez le dans l'algèbre relationnelle}
Les types sont des ensembles de valeurs.\\
\texttt{NOT MATCHING} (disjonction), \texttt{MATCHING} (intersection), \texttt{WHERE} (appartenance)

\subsection{Pourquoi certaines versions de SQL ne permette pas d'updater les views ?}
Quand on update la view, on update pas les tables qu'elle utilise. Il faut créer une rule qui update les tables. Mais pas dispo dans toutes les versions.


\subsection{Index dans Postgresql}
Source: \url{https://dev.mysql.com/doc/refman/5.0/fr/mysql-indexes.html}.

Tous les index de MySQL (\texttt{PRIMARY}, \texttt{UNIQUE} et \texttt{INDEX}) sont stockés sous la forme de \texttt{B-tree}. Les chaînes sont automatiquement préfixée et leurs espaces terminaux sont supprimés.

En PostgreSQL, B-tree, R-tree, Hash ou GiST.

\subsection{Expliquer l'indépendance des données (logique et physique)}
Dépendance physique : Peut importante le support, ca doit toujours être la même représentation.\\
Dépendance logique : Dépendant dans l'idée mais pas la même entre la DB et le programme\\

\subsection{En quoi l'architecture ANSI-SPARC en est liée avec le data model}
Il s’agit de l’architecture fondamentale sur laquelle reposent les SGBD modernes, elle fut proposée en 1965 par Charles Bachman qui reçut le prix Turing pour ses travaux. L’architecture Ansi-Sparc est divisée en trois niveaux, celui du schéma interne (SI), celui du schéma conceptuel (SC) et celui des schémas externes (SE).\\
La première innovation de l’architecture Ansi-Sparc est la distinction claire entre la représentation interne des données au niveau physique (structure de données) et la représentation logique de celles-ci. Une base de données est définie et manipulée via le niveau conceptuel (SC) sans avoir à se soucier des détails de l’implémentation physique (SI). Par exemple, il est possible de définir un index sur un ensemble de données, mais comment celui-ci est réalisé au niveau physique n’a pas besoin d’être spécifié. Sur le même principe, lors d’une requête, l’usager n’a pas besoin d’indiquer comment utiliser l’index pour maximiser l’efficacité de la recherche.
La deuxième grande innovation de ce modèle est la possibilité de créer des schémas externes qui sont en fait des portions de la base de données (sous-bases virtuelles) destinées à différents usagers. Un usager particulier ne peut manipuler que les données appartenant à son propre schéma externe. De nos jours, le terme schéma externe est remplacé par celui de « vue ».\\
\subsection{Définir une relation et donner le lien avec le first order logique}
une relation c'est un ensemble de tuple qui vérifie une propriété.\\
Le first order les prédicats qui peuvent être instanciées en fonction des variables (soit vrai soit fausse) et au final la propriété peut être un prédicat.  Les tuples pouvant être acceptés sont ceux qui vérifient un prédicat.\\
Closed world assumption : l'entièreté des tuples peuvent être mis dans la relation.  On suppose que la relation a tous les tuples.
\subsection{BCNF}
Table donnée.  Créée une nouvelle relation.  Pourquoi pas BCNF ?  FD uniquement trivial ou X super Key.  Or, ici cours est toujours=C1.  FD Point vers cours et point n'est pas superkey, donc merdoum.
\subsection{Requete et le query plan donné.  Que fait l'optimizer ?}
Associativité : restriction sur chaque avant de join.\\
Mettre un clustering index et un index primaire sur les quantités.

\subsection{Question Vincent}
\subsubsection{Requête}
1 question avec une requete à faire, et dire comment j'aurais pu faire pour la mettre comme contrainte dans ma DB en tuto D. Et aussi en SQL. La question c'etait genre, dans l'exemple suppliers, shipments, parts s'assurer qu'un fournisseur localiser à Paris ne puisse pas founir plus de 3 parts différentes. je fais le summarize et je dis where countPID > 3 et je dis que ca dois etre = TABLE\_DEE. Pour sql j'ai récris la requete et j'ai dis qu'il faudrait mettre dans un trigers qu'il verifie la contrainte a chaque fois qu'un shipment est insérer $\Rightarrow$ faut une rules plutôt!

\subsubsection{closed world assumption}
"closed world assumption" in database field et expliquer en quoi c'etait relié à la théorie des prédicats dans la logique du premier ordre. $\Rightarrow$ Closed pour 'fermé'. Venant de Kikipedia:

La notion d'hypothèse de monde clos est utilisée en particulier en Prolog, elle s'oppose à l'hypothèse de monde ouvert (voir aussi l'article Logique argumentative) et concerne la question du vrai et du faux.

Elle signifie qu'un fait est considéré comme faux si, en un temps fini, on échoue à montrer qu'il est vrai, ce qui revient à dire que tout ce qui est vrai doit être connu (inclus dans la base de données des faits) ou démontrable en temps fini, il n’y a pas de monde extérieur qui pourrait contenir des éléments de preuve inconnus du programme. Pour les faits vrais, l'hypothèse de monde clos ne dit rien de particulier.

Avec l'hypothèse de monde clos, l'univers des faits se partage entre les faits 'vrai' prouvables en temps fini et tout le reste, assimilé au faux (pour ce qui est accessible en temps fini). Outre la question de la terminaison, cela impose une utilisation du 'faux' avec précaution. Autant le 'vrai' est fort (il ne dépend que de la base de faits et de règles initiale acceptée et du mode d'inférence adopté), autant le 'faux' dépend de l'exhaustivité de la base de faits et de la complétude de la base de règle (2 notions délicates à obtenir).\\

Relation avec la DB: This 1:1 correspondence reflects the Closed-World Assumption:
\begin{itemize}
	\item A tuple representing a true instantiation is in the relation.
	\item A tuple representing a false one is out.
\end{itemize}
(and vice-versa, with respect to the database vs. the world)
The Closed-World Assumption underpins the operators we are
about to meet.
i.e. Algebra operators do not create new facts out of nowhere

\subsubsection{ACID}
il me demandait d'expliquer ce qu'etais l'atomicité d'une transaction et comment on pouvait implementer ca

j'ai dû définir relation et faire le lien avec la logique du premier ordre

\subsection{Question Ricetti}

ACID

une question de porc sur un algo rela que jai pas su faire mais le prof ma dit que cetaitt la plus dure de tte les question
KeRANK r { a1 , a2 , a3 ,... ak }

\subsection{INSERT/DELETE/UPDATE sont des shorthands pour une assignation de relvar}
Shorthands pour raccourcis je suppose...
\begin{itemize}
	\item INSERT, for adding tuples to a relvar
	\item UPDATE, for updating existing tuples in a relvar
	\item DELETE, for removing tuples from a relvar
\end{itemize}

\subsection{Comment optimiser les DB qui tiennent entièrement en RAM}
Que mettre dedans? Si on doit choisir, d'abord l'index. Si c'est tout, faut-il optimiser le temps d'accès ou la place? Et donc en gros, répondre à: comment arranger les info?\\
Vu que c'est du random access memory, on s'en fout où c'est en mémoire (toujours le même temps d'accès, peu importe où on doit aller).
\begin{itemize}
	\item Si on doit minimiser la place, vaut mieux éviter plein de références et avoir tout en un bloc (si on sait que la suite est juste après, pas besoin d'utiliser de la mémoire pour dire que le bloc suivant est à l'adresse X, ça occupe de la place...  $\Rightarrow$ donc plus dans l'idée d'utiliser surtout un primary index (voir multi-level pour profiter des B-Trees) et donc un \textit{sparse} index pour avoir une index que sur qqs search values.
    \item d'un autre côté si on veut optimiser le temps d'accès, c'est intéressant d'avoir plein de jumps pour éviter de tout lire et directement avoir ce que l'on veut surtout que le coût des jumps en terme de temps est (quasi) nul $\Rightarrow$ secondary Index et donc avec un index \textit{dense}: une entrée dans l'index pour chaque valeur recherchée.
\end{itemize}
Mais ça m'a l'air faible comme explication...\\
Pour moi l'idée est de profiter du temps d'accès ultra rapide peu importe où se situe l'info. Si on a plein de jumps, sur un disque dur, c'est lent.\\
Note: en RAM, s'il n'y a plus de courant... tout est parti!

\end{document}
