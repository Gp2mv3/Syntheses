\documentclass[fr,license=none]{../../../eplsummary}
\usepackage{wasysym}
\usepackage{../../../eplcode}

\frenchbsetup{StandardLists=true}
\renewcommand*{\labelitemi}{\strut\textcolor{black}{$\bullet$}}

\DeclareMathOperator{\pgcd}{PGCD}

\lstset{language={Oz},morekeywords={for,do}}

\newcommand{\st}{\mathrm{ST}}
\newcommand{\ce}{\mathrm{CE}}
\newcommand{\mozart}{Mozart}



\newpage

\author{Luis Tascon Gutierrez}
\title{Exercices du MOOC}

\begin{document}
	
	\maketitle
	\tableofcontents
\part{Louv1.1x}	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				    	%Introduction%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Introduction}
	
		\subsection{Why and how should we learn about paradigms?}
			\begin{itemize}
				\item What is a paradigm? \\
					\textit{''An approach for programming a computer based on a coherent set of principles or a mathematical theory.''}
				\item Why do we use Oz?\\
					\textit{''Oz is designed to support many paradigms.''}
				\item Which kind of simple language contains the primitive elements that we use to study paradigms?\\
					\textit{''The kernel language.''}
			\end{itemize}
		\subsection{Practical organization.}
			Let's test Mozart2!
			\lstinputlisting{Intro1.oz}
			\begin{itemize}
				\item After feeding the first region, which value is printed for X?\\
					\textit{''$42$''}
				\item Which value is printed for Z?\\
					\textit{'' \AC $3$''}
				\item Consider now the second region, which value of Y is printed after feeding?\\
					\textit{''$47$''}
				\item Now, proceed to the feeding of the last region, which value is printed for X?\\
					\textit{''$1234567890$''}
				\item Feed the line (a), what is printed?\\
					\textit{''$1234567890$''}
				\item Finally, feed the line (b), which printed value do you observe?\\
					\textit{''$47$''}
			\end{itemize}
			
		\subsection{Basic programming concepts}
			\subsubsection*{Our first paradigm}
				\begin{itemize}
					\item which statement is true?\\
						\textit{''Logic programming and functional programming are both a kind of declarative programming.''}
					\item Complete the sentence:\\
						\textit{''Functional programs do not have any internal memory, they are \textbf{stateless}''}
					\item We first study the functional paradigm because:\\
						\textit{''Based on this paradigm, we will add concepts to reach other paradigms.''}
				\end{itemize}
			\subsubsection*{Identifiers and variables}
				Exercice \textbf{BrowseX} : Ressource externe\\
				\lstinputlisting{Intro2.oz}
			\subsubsection*{What about single assignment?}
				Consider:
				\lstinputlisting{Intro3.oz}
				What happens?\\
				\textit{A compilation error is raised.}
			\subsubsection*{Scope and identifier redeclaration}
				Consider:
				\lstinputlisting{Intro4.oz}
				\begin{itemize}
					\item What is printed by the first call to Browse?\\
						\textit{''$3$''}
					\item What is printed by the second call to Browse?\\
						\textit{''$1$''}
				\end{itemize}
				Exercice \textbf{Scope} : Ressource externe\\
				\lstinputlisting{Intro5.oz}
			\subsubsection*{Learning the syntax of Oz}
				\begin{itemize}
					\item Why is Oz syntax so different from C-like syntax?\\
						\textit{''Because Oz supports many paradigms that do not interfer with each other.''}
					\item Which of the following denotes an identifier?\\
						\textit{''X''}\\
						\textit{''Wyghfjsk''}\\
						\textit{''Browse''}\\
						\textit{''AVeryVeryLongIdentifierButIsItReallyAnIdentifierBecauseItIsVeryLong''}
					\item Which character is used to denote a record?\\
						\textit{''()''}
				\end{itemize}
				
		\subsection{Functions}
			\subsubsection*{Functions}
				Exercice \textbf{CalledOnlyOnce} : Ressource externe\\
				\lstinputlisting{Intro6.oz}
			\subsubsection*{True/False about recursion}
				Check the true statement(s):\\
				\textit{''A recursive function is a function that calls itself.''}\\
				\textit{''Recusive procedures exist.''}
				
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    	%Recursion, loops, and invariant programming%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Recursion, loops, and invariant programming}
		\subsection{Introduction to invariant programming}
			Some definitions:
			\begin{itemize}
				\item A mathematical formula that is true at each recursive call:\\
					\textit{''invariant''}
				\item A mathematical formula that defines what the function calculates:\\
					\textit{''specification''}
				\item ''While loops'' are strictly equivalent to ''recursive functions''.\\
					\textit{''False.''}
			\end{itemize}
		\subsection{The priciple of communicating vases}
			\begin{itemize}
				\item The name ''communicating vases'' comes from the fact that:\\
					\textit{''We can decrease a variable and in the same time increase another, just like pouring water from one vase to another.''}
				\item The two presented factorial functions consume:\\
					\textit{''A different amount of memory, the simpler one consumes more.''}
				\item Exercice \textbf{Sum} : Ressource externe\\
				\lstinputlisting{RLIP1.oz}
			\end{itemize}
		\subsection{Sum of digits with commnicating vases}
			Exercice \textbf{Mirror} : Ressource externe\\
			\lstinputlisting{RLIP2.oz}
		\subsection{Tail recursion}
			Sometimes, while using a tail recursive function, a recursive call has to come back in a previous call to execute something (i.e. a multiplication).\\
			\textit{''False''}\\\\
			Exercice \textbf{Prime} : Ressource externe\\
			\lstinputlisting{RLIP3.oz}
		\subsection{Invariant programming for real}
			\begin{itemize}
				\item If we program using accumulators, we always use only one of them per program.\\
					\textit{''False''}
				\item How many accumulators do you use with this new way?\\
					\textit{''$2$''}
				\item Exercice \textbf{Fib} : Ressource externe\\
					\lstinputlisting{RLIP4.oz}
				\item What is the result if you compute {Fib 32}?\\
					\textit{''$2178309$''}
				\item What is the result if you compute {Fib 42}?\\
					\textit{''$267914296$''}
				\item When will you have the answer of the naive {Fib 1000}?\\
					\textit{''In a long time''}
			\end{itemize}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				%Lists and pattern matching%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Lists and pattern matching}
		\subsection{Lists}
			\subsubsection*{Lists informally}
				\begin{itemize}
					\item Lists can be changed.\\
						\textit{''False''}
					\item $[[1][2][3]]$ is:\\
						\textit{''A list of lists''}
					\item Consider the following list: [[1] 2 'a']\\
						\textit{''This is a list''}
				\end{itemize}
			\subsubsection*{Lists - More precisely}
				\begin{itemize}
					\item Which word represents the empty list? (One word)\\
						\textit{''nil''}
					\item The circular definition of list (definition of lists using lists) is a problem.\\
						\textit{''False''}
				\end{itemize}
			\subsubsection*{Useful representations for lists}
				\begin{itemize}
					\item Which representations are equivalent to [[1] [2]]?\\
						\textit{''(1|nil)|(2|nil)|nil''}\\
						\textit{''[(1|nil) (2|nil)]''}\\
						\textit{''[(1|nil) [2]]''}\\
					\item Is (a|b)|c|nil a list?\\
						\textit{''Yes''}
					\item Exercice \textbf{Intuitive Append} : Ressource externe\\
					\lstinputlisting{LPM1.oz}
				\end{itemize}
		\subsection{Calculating with lists}
			\subsubsection*{Tail recursion for lists}
				\begin{itemize}
					\item We can write tail recursive function with lists.\\
						\textit{''True''}
					\item Exercice \textbf{Fact} : Ressource externe\\
					\lstinputlisting{LPM2.oz}
				\end{itemize}
			\subsubsection*{Pattern matching}
				Consider the following code:
				\lstinputlisting{LPM3.oz}
				\begin{itemize}
					\item What is printed if we call \{TestPattern nil\}?\\
						\textit{''$1$''}
					\item And if we call \{TestPattern [a b]\}?\\
						\textit{''$1$''}
					\item Consider the pattern: H|T \\
					What is bound to H? And to T?\\
						\textit{''H = a and T = b|c|nil''}
				\end{itemize}
		\subsection{Why list functions are tail recursive}
			\begin{itemize}
				\item Select the correct statement:\\
					\textit{''A function can be translated to a procedure with one additional argument.''}
				\item Tail-recursive Append is possible because of ... . (two words, last plural)\\
					\textit{''unbound variables''}
			\end{itemize}
			Exercice \textbf{FindString} : Ressource externe\\
			\lstinputlisting{LPM4.oz}
		\subsection{Bonus challenge: Flatten}
			Exercice \textbf{Flatten} : Ressource externe\\
			\lstinputlisting{LPM5.oz}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			%Higher-order programming and records%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Higher-order programming and records}
		\subsection{Contextual environment and free identifiers}
			Consider the following code:
			\lstinputlisting{HOPR1.oz}
			Which of these identifiers (A,B,C,D,E,F,G) are free identifiers?\\
				\textit{''A''}\\
				\textit{''D''}
		\subsection{Procedure values (closures)}
			Consider the following code:
			\lstinputlisting{HOPR2.oz}
			Consider that the identifier Add refers to a variable a in memory. What is the value of a?\\
				\textit{''a = (proc \{\$ B C E\} E = B + C + D end, \{D->d\})''}
		\subsection{Procedures as inputs and outputs}
			\begin{itemize}
				\item What is printed if I write:\{Browse Browse\}?\\
					\textit{''The procedure value refered by Browse''}
				\item Consider the following code:
				\lstinputlisting{HOPR3.oz}
				\item What is printed with: \{Browse M\}?\\
					\textit{''<P/2 M>''}
				\item What is printed with: \{Browse \{M 5\}\}\\
					\textit{''<P/1>''}
				\item What is printed with:\\
				Test = \{M 5\}\\
				\{Browse \{Test\}\}?\\
					\textit{''5\#<P/1>''}
				\item Exercice \textbf{FunAsInput} : Ressource externe\\
				\lstinputlisting{HOPR4.oz}
				\item Exercice \textbf{BuildMyFunction} : Ressource externe\\
				\lstinputlisting{HOPR5.oz}
			\end{itemize}
		\subsection{Records as compound data type}
			Consider the following record:\\
			Menus = menu\_of\_this\_course(\\
			--menu(entree: 'salad'\\
			------meal: 'steak'\\
			------cost: 10)\\
			--menu(entree: 'fruits'\\
			------meal: 'salmon'\\
			------cost: 12)\\
			--menu(meal: 'hamburger'\\
			------cost: 9))
			\begin{itemize}
				\item What is the meal of the second menu?\\
					\textit{''salmon''}
				\item What is the type of this value (the meal of the second menu)?\\
					\textit{''atom''}
				\item What formula represents the total cost?\\
					\textit{''X*10+Y*12+Z*9''} 
				\item How to access the cost of the first menu?\\
					\textit{''Menus.1.cost''}
				\item How to access the cost of the second menu?\\
					\textit{''Menus.2.cost''}
				\item How to access the cost of the third menu?\\
					\textit{''Menus.3.cost''}
				\item What is the width of the record identified by ''Menus'' ?\\
					\textit{''3''}
				\item What is the width of the first menu ?\\
					\textit{''3''}
				\item What is the width of the third menu ?\\
					\textit{''2''}
				\item Exercice \textbf{BuildMyRecord} : Ressource externe\\
					\lstinputlisting{HOPR6.oz}
			\end{itemize}
		\subsection{The full kernel language}
			Consider the two following programs:
			\lstinputlisting{HOPR7.oz}
			\begin{itemize}
				\item What is printed by the first program?\\
					\textit{''42''}
				\item And what is printed by the second program?\\
					\textit{''-2''}
				\item Which variables are created by the first program?\\
					\textit{''arg1 arg2 res''}
				\item Which variables are created by the second program?\\
					\textit{''arg1 arg2 res''}
			\end{itemize}
			
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			%Trees and computational complexity%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Trees and computational complexity}
		\subsection{Trees}
			\subsubsection*{Introduction to trees}
				Consider the following tree:\\
				T = tree(42\\
				--leaf\\
				--leaf\\
				--leaf\\
				--tree(42\\
				--------leaf\\
				--------leaf\\
				--------leaf\\
				--------tree(42 leaf)\\
				--------leaf)\\
				--leaf\\
				--leaf)
				\begin{itemize}
					\item How many leaves has the tree T?\\
						\textit{''$10$''}
					\item How many leaves has the tree T.5.5?\\
						\textit{''$1$''}
				\end{itemize}
			\subsubsection*{Ordered binary trees}
				\begin{itemize}
					\item Which of these trees are binary trees according to the above rule?\\
						\textit{''tree(42 left:leaf right:leaf)''}\\
						\textit{''tree(42 right:leaf left:leaf)''}\\
						\textit{''tree(1 left:tree(2 left:leaf right:leaf) right:tree(3 left:leaf right:leaf))''}\\
						\textit{''tree(1 left:tree(2 left:tree(3 left:leaf right:leaf) right:leaf) right:leaf)''}\\
						\textit{''leaf''}\\\\
					Consider these three trees:\\
						T1 = tree(key:5 value:6 left:tree(key:6 value:7 left:leaf right:leaf) right:tree(key:4 value:5 left:leaf right:leaf))\\
						
						T2 = tree(key:5 value:6 left:tree(key:3 value:5 left:tree(key:2 value:4 left:leaf right:leaf) right:tree(key:4 value:10 left:leaf right:leaf)) right:tree(key:6 value:7 left:leaf right:leaf))\\
						
						T3 = tree(key:6 value:5 left:tree(key:5 value:3 left:tree(key:4 value:2 left:leaf right:leaf) right:tree(key:10 value:4 left:leaf right:leaf)) right:tree(key:7 value:6 left:leaf right:leaf))
					\item Which of these trees are ordered binary trees?\\
						\textit{''T2''}
					\item Exercice \textbf{Infix} : Ressource externe\\
						\lstinputlisting{Tree1.oz}
					\item Exercice \textbf{SortWithTree} : Ressource externe\\
						\lstinputlisting{Tree2.oz}
						\lstinputlisting{Tree3.oz}
				\end{itemize}
		\subsection{Search trees}
			\subsubsection*{Lookup function}
				Consider the following ordered search tree:\\
				T = tree(key:horse value:cheval\\
				--------left:tree(key:dog value:chien\\
				-----------------left:tree(key:cat value:chat left:leaf right:leaf)\\
				-----------------right:tree(key:elephant value:elephant left:leaf right:leaf))\\
				--------right:tree(key:mouse value:souris\\
				-----------------left:tree(key:monkey value:singe left:leaf right:leaf)\\
				-----------------right:tree(key:tiger value:tigre left:leaf right:leaf)))
				\begin{itemize}
					\item What is printed after calling \{Browse \{Lookup mouse\}\}?\\
						\textit{''found(souris)''}
					\item How many calls to Lookup are done when calling \{Lookup tiger\}?\\
						\textit{''$3$''}
					\item How many calls to Lookup are done when calling \{Lookup rabbit\}? \\
						\textit{''$4$''}
					\item What is the tree T of the last call of Lookup when calling \{Lookup rabbit\}?\\
						\textit{''leaf''}
				\end{itemize}
			\subsubsection*{Insert function}
				Consider the following ordered search tree:\\
				T = tree(key:horse value:cheval\\
				--------left:tree(key:dog value:chien\\
				-----------------left:tree(key:cat value:chat left:leaf right:leaf)\\
				-----------------right:tree(key:elephant value:elephant left:leaf right:leaf))\\
				--------right:tree(key:mouse value:souris\\
				-----------------left:tree(key:monkey value:singe left:leaf right:leaf)\\
				-----------------right:tree(key:tiger value:tigre left:leaf right:leaf)))
				\begin{itemize}
					\item What is printed if we call \{Browse \{Lookup elephant \{Insert elephant mouche T\}\}\}?\\
						\textit{''found(mouche)''}
					\item How many calls to Insert are done while calling \{Insert elephant mouche T\}? (Count the original call to Insert)\\
						\textit{''$3$''}
					\item What is printed if we call \{Browse \{Lookup elephant \{Insert fly mouche T\}\}\}?\\
						\textit{''found(elephant)''}
					\item How many calls to Insert are done while calling \{Insert fly mouche T\}? (Count the original call to Insert)\\
						\textit{''$4$''}
				\end{itemize}
			\subsubsection*{Balanced trees}
				Let our ordered tree T be balanced.
				\begin{itemize}
					\item How many time units (in average) do we have while calling Lookup with 16 nodes in T?\\
						\textit{''$4$''}
					\item And with 31415 nodes in T? (approximately)\\
						\textit{''$15$''}
					\item Exercice \textbf{IsBalanced} : Ressource externe\\
						\lstinputlisting{Tree4.oz}
						\lstinputlisting{Tree5.oz}
				\end{itemize}
		\subsection{Deleting information from a search tree}
			Consider the following ordered search tree:\\
			T = tree(key:horse value:cheval\\
			--------left:tree(key:dog value:chien\\
			-----------------left:tree(key:cat value:chat left:leaf right:leaf)\\
			-----------------right:tree(key:elephant value:elephant left:leaf right:leaf))\\
			--------right:tree(key:mouse value:souris\\
			-----------------left:tree(key:monkey value:singe left:leaf right:leaf)\\
			-----------------right:tree(key:tiger value:tigre left:leaf right:leaf)))
			\begin{itemize}
				\item Let us call T1 the result of \{Delete dog T\}. What will be the key of T1.left? \\
					\textit{''elephant''}
				\item Let us call T2 the result of \{Delete mouse T\}. What will be the key of T2.right? \\
					\textit{''tiger''}
				\item Let us call T3 the result of \{Delete cat T\}. What will be the key of T3.left.left?\\ 
					\textit{''leaf''}
				\item Let us call T4 the result of \{Delete tiger T\}. What will be the key of T4.right.right? \\
					\textit{''leaf''}
				\item Let us call T5 the result of \{Delete monkey \{Delete horse T\}\}. What will be the key of T5? \\
					\textit{''mouse''}
				\item What is the key of the node \{Delete monkey \{Delete horse T\}\}.left? \\
					\textit{''dog''}
			\end{itemize}
		\subsection{Goal-oriented programming}
			\begin{itemize}
				\item In which domain is goal oriented programming widely used? (Two words, do not use initials)\\
					\textit{''artificial intelligence''}
			\end{itemize}
		\subsection{Computational complexity}
			\subsubsection*{Execution speed and big-O notation}
				Assume we have a problem which can be solved with different algorithms. Bellow, are the functions f(n) for each of theses algorithms.
				\begin{itemize}
					\item For a very big input size, which algorithm is going to finish its computation first ?\\
						\textit{''n''}
					\item Now we have a set of input data of different size and give the exact same time to each algorithm, which one will be able to solve the less problems ?\\
						\textit{''$2n\:\hat{}\:2$''}
					\item If $f(n)=3n^2+7$, which of the following holds ?\\
						\textit{''$f(n) \in O(n^2)$''}\\
						\textit{''$f(n) \in O(n^3)$''}\\
						\textit{''$f(n) \in O(2^n)$''}
				\end{itemize}
			\subsubsection*{Temporal complexity of the function Pascal}
				Consider the following algorithm:
				\lstinputlisting{Tree6.oz}
				Suppose we call \{Calculate N\}
				\begin{itemize}
					\item How many calls to \{Calculate N-1\} are made?\\
						\textit{''$3$''}
					\item How many calls to \{Calculate N-2\} are made?\\
						\textit{''$9$''}
					\item How many calls to \{Calculate N-4\} are made?\\
						\textit{''$81$''}
					\item How many calls to \{Calculate 0\} are made?\\
						\textit{''$3\:\hat{}\:n$''}
				\end{itemize}
					Now condider this other algorithm:
					\lstinputlisting{Tree7.oz}
				\begin{itemize}
					\item Considering n (the size of the input) is N, what is the complexity of the CalcAux function in big-O notation ?\\
						\textit{''O(n)''}
				\end{itemize}
			\subsubsection*{Best case, average case, and worst case}
				Consider the function \{Insert N L\} which returns a sorted list containing all the elements of L (L must only have integer), plus N. Assume that L is sorted from small to big, and so is the result.
				\begin{itemize}
					\item Which case are we in if N is bigger than all the elements of L?\\
						\textit{''Worst case''}
				\end{itemize}
					Now consider the function \{Smallest L\} which returns the smallest elements of the list L, for any list (sorted or not).
				\begin{itemize}
					\item If L is sorted from small to big, which case are we in ?\\
						\textit{''None of the above''}
				\end{itemize}
			\subsubsection*{Upper and lower bounds}
				\begin{itemize}
					\item If a function has the same lower and upper bounds, we talk about... (2 words)\\
						\textit{''asymptotic equivalence''}
				\end{itemize}
					Now let's consider again the function Insert. As a reminder, the function \{Insert N L\} returns a sorted list containing all the elements of L (L must only have integer), plus N (L is sorted from small to big, and so is the result).
				\begin{itemize}
					\item What is the lower bound in the worst case?\\
						\textit{''n''}
					\item What is the upper bound in the worst case?\\
						\textit{''n''}
					\item What about the best case, $f_{best} \in O(...)$? (if you think it doesn't exist, type 'null')\\
						\textit{''1''}
				\end{itemize}
			\subsubsection*{Spatial complexity}
				\begin{itemize}
					\item Assume you start an algorithm on your computer. You pause the program and see that your process uses 42 Mo of memory. We are talking about ...\\
						\textit{''active memory''}
					\item Now assume that you run your algorithm for a few seconds, and see that your process now use 51 Mo. That makes a 9 Mo difference in say, 3 seconds. We are talking about ...\\
						\textit{''memory consumption''}
					\item Now imagine that your algorithm has nothing more to do and is waiting for some action (for example, a server waiting for a connection). It is then not doing any calculation. However it is still using 51 Mo. What is the transition that reprensents the life cycle of these 9 Mo when the program entered waiting?\\
						\textit{''Active $\rightarrow$ inactive''}
					\item A special algorithm can make these 9 Mo free, it's called ...\\
						\textit{''garbage collection''}
				\end{itemize}
		\subsection{Reflections on performance}
			\subsubsection*{Moore's Law and program optimization}
				\begin{itemize}
					\item Check the true propositions.\\
						\textit{''Even though clock speed is in a plateau, circuit density is still increasing.''}\\
						\textit{''Optimization is not always a good idea.''}
					\item When is it a good idea to optimize an algorithm?\\
						\textit{''When a bottleneck is spotted in the algorithm''}
				\end{itemize}
			\subsubsection*{Intractable problems and the class NP}
				\begin{itemize}
					\item A NP problem can be solved in...\\
						\textit{''nondeterministic polynomial time''}
					\item Assume we have a NP-Problem, and we find an algorithm which can find a solution in polynomial time. If we can derive an algorithm for any NP-problem, this problem is said to be...\\
						\textit{''NP-complete''}
					\item If such an algorithm is found, we can deduce that... (there is no whitespace in the answer)\\
						\textit{''$P=NP$''}
				\end{itemize}
			\subsubsection*{Coding ecercise to summarize computational complexity}
				\begin{itemize}
					\item What is the complexity of this function ? The answer should be formatted like in the previous exercises, and therefore should be like 'O(...)'. For exponential, use $\hat{}$ . (Also note that this exercise (and this one only, not the coding exercise bellow) is Bonus, it will not count and your final note).\\
						\textit{''$O(3\:\hat{}\:n)$''}
					\item Exercice \textbf{MasterOfRabbit} : Ressource externe\\
						\lstinputlisting{Tree8.oz}
						\lstinputlisting{Tree9.oz}
				\end{itemize}
				
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				%Correctness and semantics%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Correctness and semantics}
		\subsection{Overview of semantics lesson}
			\begin{itemize}
				\item What general approach will be used in this course to define the semantics (two words)?\\
					\textit{''operational semantics''}
			\end{itemize}
		\subsection{Program correctness}
			\begin{itemize}
				\item In what language is a specification written?\\
					\textit{''Mathematics''}
				\item What kind of proof method do we use for a recursive function? (two words, not capitalized)\\
					\textit{''mathematical induction''}
				\item How many cases does this kind of proof consider? (enter a number)\\
					\textit{''2''}
				\item How many variables in memory does a local instruction create?\\
					\textit{''1''}
			\end{itemize}
			Now Consider the following code:
			\lstinputlisting{Corr1.oz}
			We begin the translation into the kernel language, you will have to complete the underlined part:
			\begin{itemize}
				\item You are asked to give the kernel language representation of "N + \{Add N - 1\}".\\
					\textit{''local I1 in''}\\
					\textit{''local N1 in''}\\
					\textit{''local R1 in''}\\
					\textit{''I1 = 1''}\\
					\textit{''N1 = N - I1''}\\
					\textit{''\{Add N1 R1\}''}\\
					\textit{''R = N + R1''}\\
					\textit{''end''}\\
					\textit{''end''}\\
					\textit{''end''}
				\item Which variable(s) are added in memory?\\
					\textit{''\{c\}''}
				\item Which reference(s) to identifier(s) are added to the environment?\\
					\textit{''\{C->c\}''}
			\end{itemize}
			Consider the following code:
			\lstinputlisting{Corr3.oz}
			\begin{itemize}
				\item What is the state of the memory when reaching the underlined "end"?\\
					\textit{''\{a=false, b=true\}''}
			\end{itemize}
		\subsection{The abstract machine}
			\begin{itemize}
				\item Which of the following concepts are NOT part of the abstract machine?\\
					\textit{''Specification''}\\
					\textit{''Mathematical induction''}\\
					\textit{''Axiomatic semantics''}
				\item Which of the following can be calculated using the abstract machine?\\
					\textit{''Number of execution steps of a program in function of input size''}\\
					\textit{''Stack size (in number of instructions) of a program during its execution''}\\
					\textit{''How much memory a program uses''}\\
					\textit{''How garbage collection works''}\\
					\textit{''Why tail recursion works''}\\
					\textit{''How a procedure call works''}
				\item The environment allows to make the link between an instruction and the ...\\
					\textit{''memory''}
				\item While the semantic stack is not empty, we pop a semantic ... from the semantic stack\\
					\textit{''instruction''}
				\item and then, we execute it according to its corresponding semantic ... .\\
					\textit{''rule''}
			\end{itemize}
		\subsection{Semantic rules}
			\begin{itemize}
				\item How many elements are added to the semantic stack after the execution of a sequential composition?\\
					\textit{''$1$''}
				\item Which of the following kernel language instructions create variables in memory?\\
					\textit{''local''}\\
					\textit{''creation of a number''}\\
					\textit{''creation of a procedure''}\\
					\textit{''creation of a record''}
				\item What is modified after the execution of a local instruction?\\
					\textit{''the semantic stack''}\\
					\textit{''the memory''}
			\end{itemize}
			Consider the following code:
			\lstinputlisting{Corr4.oz}
			And consider the following execution state:\\
			\{[(A = 42, {A$\rightarrow$a, B$\rightarrow$b})], \{a, b=42\}\}
			\begin{itemize}
				\item What is the next execution state? Please respect carefully the syntax used above to represent the semantic stack, including spaces.\\
					\textit{''\{[], \{a=42, b=42\}\}''}
			\end{itemize}
			Consider now the following code:
			\lstinputlisting{Corr5.oz}
			\begin{itemize}
				\item Consider the fact that the variables a, b and c have been created in memory and the fact that the "if" instruction is being executed.\\
					\textit{''b = 42 (in memory)''}\\
					\textit{''the instruction waits until A is bound''}
			\end{itemize}
		\subsection{Procedure definition and call}
			\begin{itemize}
				\item When calling a procedure, what two things are used to calculate the environment needed to execute the procedure body?\\
					\textit{''Contextual environment''}\\
					\textit{''Arguments''}
			\end{itemize}
			Given the following program:
			\lstinputlisting{Corr6.oz}
			\begin{itemize}
				\item What are the identifiers in the environment just before executing the call \{MakeAdder A\}?\\
					\textit{''MakeAdder''}\\
					\textit{''A''}\\
					\textit{''Add''}
				\item What are the identifiers in the environment when the function body of MakeAdder is executed?\\
					\textit{''X''}
				\item What are the identifiers in the environment just before executing the call \{Add 100\}?\\
					\textit{''MakeAdder''}\\
					\textit{''A''}\\
					\textit{''Add''}
				\item What are the identifiers in the environment when the function body of Add is executed?\\
					\textit{''X''}\\
					\textit{''Y''}
			\end{itemize}
			Consider the following code:
			\lstinputlisting{Corr7.oz}
			\begin{itemize}
				\item Which are the free identifiers in Add?\\
					\textit{''B''}
			\end{itemize}
			Consider the fact that a variable name corresponds to its referring identifier name in lower case.
			In the environment that exists when the body of Add is executed (meaning after the call in \%1):
			\begin{itemize}
				\item A refers to the variable...\\
					\textit{''d''}
				\item B refers to the variable...\\
					\textit{''b''}
				\item C refers to the variable...\\
					\textit{''e''}
				\item R refers to the variable...\\
					\textit{''f''}
			\end{itemize}
		\subsection{Summary of semantics}
			\begin{itemize}
				\item If the semantics of a program is simple ...\\
					\textit{''the program's behavior is simplified''}
			\end{itemize}
\end{document}