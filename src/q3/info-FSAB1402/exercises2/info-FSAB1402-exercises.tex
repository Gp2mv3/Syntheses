\documentclass[fr,license=none]{../../../eplexercises}
\usepackage{wasysym}
\usepackage{../../../eplcode}

\frenchbsetup{StandardLists=true}
\renewcommand*{\labelitemi}{\strut\textcolor{black}{$\bullet$}}

\DeclareMathOperator{\pgcd}{PGCD}

\lstset{language={Oz},morekeywords={for,do}}

\hypertitle[']{Informatique : Solutions des exercices du MOOC}{3}{FSAB}{1402}
{Luis Tascon Gutierrez\and Louis Devillez}
{Peter Van Roy}

\newcommand{\st}{\mathrm{ST}}
\newcommand{\ce}{\mathrm{CE}}
\newcommand{\mozart}{Mozart}


\part{Louv1.1x}	
	\section{Introduction}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Introduction%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
		\subsection{Why and how should we learn about paradigms?}
			\begin{itemize}
				\item What is a paradigm? \\
					\textit{``An approach for programming a computer based on a coherent set of principles or a mathematical theory.''}
				\item Why do we use Oz?\\
					\textit{``Oz is designed to support many paradigms.''}
				\item Which kind of simple language contains the primitive elements that we use to study paradigms?\\
					\textit{``The kernel language.''}
			\end{itemize}
		\subsection{Practical organization.}
			Let's test Mozart2!
			\lstinputlisting{Intro1.oz}
			\begin{itemize}
				\item After feeding the first region, which value is printed for X?\\
					\textit{``$42$''}
				\item Which value is printed for Z?\\
					\textit{`` \AC $3$''}
				\item Consider now the second region, which value of Y is printed after feeding?\\
					\textit{``$47$''}
				\item Now, proceed to the feeding of the last region, which value is printed for X?\\
					\textit{``$1234567890$''}
				\item Feed the line (a), what is printed?\\
					\textit{``$1234567890$''}
				\item Finally, feed the line (b), which printed value do you observe?\\
					\textit{``$47$''}
			\end{itemize}
			
		\subsection{Basic programming concepts}
			\subsubsection*{Our first paradigm}
				\begin{itemize}
					\item which statement is true?\\
						\textit{``Logic programming and functional programming are both a kind of declarative programming.''}
					\item Complete the sentence:\\
						\textit{``Functional programs do not have any internal memory, they are \textbf{stateless}''}
					\item We first study the functional paradigm because:\\
						\textit{``Based on this paradigm, we will add concepts to reach other paradigms.''}
				\end{itemize}
			\subsubsection*{Identifiers and variables}
				Exercice \textbf{BrowseX} : Ressource externe\\
				\lstinputlisting{Intro2.oz}
			\subsubsection*{What about single assignment?}
				Consider:
				\lstinputlisting{Intro3.oz}
				What happens?\\
				\textit{``A compilation error is raised.''}
			\subsubsection*{Scope and identifier redeclaration}
				Consider:
				\lstinputlisting{Intro4.oz}
				\begin{itemize}
					\item What is printed by the first call to Browse?\\
						\textit{``$3$''}
					\item What is printed by the second call to Browse?\\
						\textit{``$1$''}
				\end{itemize}
				Exercice \textbf{Scope} : Ressource externe\\
				\lstinputlisting{Intro5.oz}
			\subsubsection*{Learning the syntax of Oz}
				\begin{itemize}
					\item Why is Oz syntax so different from C-like syntax?\\
						\textit{``Because Oz supports many paradigms that do not interfer with each other.''}
					\item Which of the following denotes an identifier?\\
						\textit{``X''}\\
						\textit{``Wyghfjsk''}\\
						\textit{``Browse''}\\
						\textit{``AVeryVeryLongIdentifierButIsItReallyAnIdentifierBecauseItIsVeryLong''}
					\item Which character is used to denote a record?\\
						\textit{``()''}
				\end{itemize}
				
		\subsection{Functions}
			\subsubsection*{Functions}
				Exercice \textbf{CalledOnlyOnce} : Ressource externe\\
				\lstinputlisting{Intro6.oz}
			\subsubsection*{True/False about recursion}
				Check the true statement(s):\\
				\textit{``A recursive function is a function that calls itself.''}\\
				\textit{``Recusive procedures exist.''}

	\section{Recursion, loops, and invariant programming}				
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Recursion, loops, and invariant programming%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Introduction to invariant programming}
			Some definitions:
			\begin{itemize}
				\item A mathematical formula that is true at each recursive call:\\
					\textit{``invariant''}
				\item A mathematical formula that defines what the function calculates:\\
					\textit{``specification''}
				\item ``While loops'' are strictly equivalent to ``recursive functions''.\\
					\textit{``False.''}
			\end{itemize}
		\subsection{The principle of communicating vases}
			\begin{itemize}
				\item The name ``communicating vases'' comes from the fact that:\\
					\textit{``We can decrease a variable and in the same time increase another, just like pouring water from one vase to another.''}
				\item The two presented factorial functions consume:\\
					\textit{``A different amount of memory, the simpler one consumes more.''}
				\item Exercice \textbf{Sum} : Ressource externe\\
				\lstinputlisting{RLIP1.oz}
			\end{itemize}
		\subsection{Sum of digits with commnicating vases}
			Exercice \textbf{Mirror} : Ressource externe\\
			\lstinputlisting{RLIP2.oz}
		\subsection{Tail recursion}
			Sometimes, while using a tail recursive function, a recursive call has to come back in a previous call to execute something (i.e. a multiplication).\\
			\textit{``False''}\\\\
			Exercice \textbf{Prime} : Ressource externe\\
			\lstinputlisting{RLIP3.oz}
		\subsection{Invariant programming for real}
			\begin{itemize}
				\item If we program using accumulators, we always use only one of them per program.\\
					\textit{``False''}
				\item How many accumulators do you use with this new way?\\
					\textit{``$2$''}
				\item Exercice \textbf{Fib} : Ressource externe\\
					\lstinputlisting{RLIP4.oz}
				\item What is the result if you compute {Fib 32}?\\
					\textit{``$2178309$''}
				\item What is the result if you compute {Fib 42}?\\
					\textit{``$267914296$''}
				\item When will you have the answer of the naive {Fib 1000}?\\
					\textit{``In a long time''}
			\end{itemize}
	
	\section{Lists and pattern matching}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Lists and pattern matching%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Lists}
			\subsubsection*{Lists informally}
				\begin{itemize}
					\item Lists can be changed.\\
						\textit{``False''}
					\item $[[1][2][3]]$ is:\\
						\textit{``A list of lists''}
					\item Consider the following list: [[1] 2 'a']\\
						\textit{``This is a list''}
				\end{itemize}
			\subsubsection*{Lists - More precisely}
				\begin{itemize}
					\item Which word represents the empty list? (One word)\\
						\textit{``nil''}
					\item The circular definition of list (definition of lists using lists) is a problem.\\
						\textit{``False''}
				\end{itemize}
			\subsubsection*{Useful representations for lists}
				\begin{itemize}
					\item Which representations are equivalent to [[1] [2]]?\\
						\textit{``(1|nil)|(2|nil)|nil''}\\
						\textit{``[(1|nil) (2|nil)]''}\\
						\textit{``[(1|nil) [2]]''}\\
					\item Is (a|b)|c|nil a list?\\
						\textit{``Yes''}
					\item Exercice \textbf{Intuitive Append} : Ressource externe\\
					\lstinputlisting{LPM1.oz}
				\end{itemize}
		\subsection{Calculating with lists}
			\subsubsection*{Tail recursion for lists}
				\begin{itemize}
					\item We can write tail recursive function with lists.\\
						\textit{``True''}
					\item Exercice \textbf{Fact} : Ressource externe\\
					\lstinputlisting{LPM2.oz}
				\end{itemize}
			\subsubsection*{Pattern matching}
				Consider the following code:
				\lstinputlisting{LPM3.oz}
				\begin{itemize}
					\item What is printed if we call \{TestPattern nil\}?\\
						\textit{``$1$''}
					\item And if we call \{TestPattern [a b]\}?\\
						\textit{``$1$''}
					\item Consider the pattern: H|T \\
					What is bound to H? And to T?\\
						\textit{``H = a and T = b|c|nil''}
				\end{itemize}
		\subsection{Why list functions are tail recursive}
			\begin{itemize}
				\item Select the correct statement:\\
					\textit{``A function can be translated to a procedure with one additional argument.''}
				\item Tail-recursive Append is possible because of ... . (two words, last plural)\\
					\textit{``unbound variables''}
			\end{itemize}
			Exercice \textbf{FindString} : Ressource externe\\
			\lstinputlisting{LPM4.oz}
		\subsection{Bonus challenge: Flatten}
			Exercice \textbf{Flatten} : Ressource externe\\
			\lstinputlisting{LPM5.oz}
			
	\section{Higher-order programming and records}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Higher-order programming and records%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Contextual environment and free identifiers}
			Consider the following code:
			\lstinputlisting{HOPR1.oz}
			Which of these identifiers (A,B,C,D,E,F,G) are free identifiers?\\
				\textit{``A''}\\
				\textit{``D''}
		\subsection{Procedure values (closures)}
			Consider the following code:
			\lstinputlisting{HOPR2.oz}
			Consider that the identifier Add refers to a variable a in memory. What is the value of a?\\
				\textit{``a = (proc \{\$ B C E\} E = B + C + D end, \{D->d\})''}
		\subsection{Procedures as inputs and outputs}
			\begin{itemize}
				\item What is printed if I write:\{Browse Browse\}?\\
					\textit{``The procedure value refered by Browse''}
				\item Consider the following code:
				\lstinputlisting{HOPR3.oz}
				\item What is printed with: \{Browse M\}?\\
					\textit{``<P/2 M>''}
				\item What is printed with: \{Browse \{M 5\}\}\\
					\textit{``<P/1>''}
				\item What is printed with:\\
				Test = \{M 5\}\\
				\{Browse \{Test\}\}?\\
					\textit{``5\#<P/1>''}
				\item Exercice \textbf{FunAsInput} : Ressource externe\\
				\lstinputlisting{HOPR4.oz}
				\item Exercice \textbf{BuildMyFunction} : Ressource externe\\
				\lstinputlisting{HOPR5.oz}
			\end{itemize}
		\subsection{Records as compound data type}
			Consider the following record:\\
			Menus = menu\_of\_this\_course(\\
			--menu(entree: 'salad'\\
			------meal: 'steak'\\
			------cost: 10)\\
			--menu(entree: 'fruits'\\
			------meal: 'salmon'\\
			------cost: 12)\\
			--menu(meal: 'hamburger'\\
			------cost: 9))
			\begin{itemize}
				\item What is the meal of the second menu?\\
					\textit{``salmon''}
				\item What is the type of this value (the meal of the second menu)?\\
					\textit{``atom''}
				\item What formula represents the total cost?\\
					\textit{``X*10+Y*12+Z*9''} 
				\item How to access the cost of the first menu?\\
					\textit{``Menus.1.cost''}
				\item How to access the cost of the second menu?\\
					\textit{``Menus.2.cost''}
				\item How to access the cost of the third menu?\\
					\textit{``Menus.3.cost''}
				\item What is the width of the record identified by ''Menus'' ?\\
					\textit{``3''}
				\item What is the width of the first menu ?\\
					\textit{``3''}
				\item What is the width of the third menu ?\\
					\textit{``2''}
				\item Exercice \textbf{BuildMyRecord} : Ressource externe\\
					\lstinputlisting{HOPR6.oz}
			\end{itemize}
		\subsection{The full kernel language}
			Consider the two following programs:
			\lstinputlisting{HOPR7.oz}
			\begin{itemize}
				\item What is printed by the first program?\\
					\textit{``42''}
				\item And what is printed by the second program?\\
					\textit{``-2''}
				\item Which variables are created by the first program?\\
					\textit{``arg1 arg2 res''}
				\item Which variables are created by the second program?\\
					\textit{``arg1 arg2 res''}
			\end{itemize}
		
	\section{Trees and computational complexity}	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Trees and computational complexity%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Trees}
			\subsubsection*{Introduction to trees}
				Consider the following tree:\\
				T = tree(42\\
				--leaf\\
				--leaf\\
				--leaf\\
				--tree(42\\
				--------leaf\\
				--------leaf\\
				--------leaf\\
				--------tree(42 leaf)\\
				--------leaf)\\
				--leaf\\
				--leaf)
				\begin{itemize}
					\item How many leaves has the tree T?\\
						\textit{``$10$''}
					\item How many leaves has the tree T.5.5?\\
						\textit{``$1$''}
				\end{itemize}
			\subsubsection*{Ordered binary trees}
				\begin{itemize}
					\item Which of these trees are binary trees according to the above rule?\\
						\textit{``tree(42 left:leaf right:leaf)''}\\
						\textit{``tree(42 right:leaf left:leaf)''}\\
						\textit{``tree(1 left:tree(2 left:leaf right:leaf) right:tree(3 left:leaf right:leaf))''}\\
						\textit{``tree(1 left:tree(2 left:tree(3 left:leaf right:leaf) right:leaf) right:leaf)''}\\
						\textit{``leaf''}\\\\
					Consider these three trees:\\
						T1 = tree(key:5 value:6 left:tree(key:6 value:7 left:leaf right:leaf) right:tree(key:4 value:5 left:leaf right:leaf))\\
						
						T2 = tree(key:5 value:6 left:tree(key:3 value:5 left:tree(key:2 value:4 left:leaf right:leaf) right:tree(key:4 value:10 left:leaf right:leaf)) right:tree(key:6 value:7 left:leaf right:leaf))\\
						
						T3 = tree(key:6 value:5 left:tree(key:5 value:3 left:tree(key:4 value:2 left:leaf right:leaf) right:tree(key:10 value:4 left:leaf right:leaf)) right:tree(key:7 value:6 left:leaf right:leaf))
					\item Which of these trees are ordered binary trees?\\
						\textit{``T2''}
					\item Exercice \textbf{Infix} : Ressource externe\\
						\lstinputlisting{Tree1.oz}
					\item Exercice \textbf{SortWithTree} : Ressource externe\\
						\lstinputlisting{Tree2.oz}
						\lstinputlisting{Tree3.oz}
				\end{itemize}
		\subsection{Search trees}
			\subsubsection*{Lookup function}
				Consider the following ordered search tree:\\
				T = tree(key:horse value:cheval\\
				--------left:tree(key:dog value:chien\\
				-----------------left:tree(key:cat value:chat left:leaf right:leaf)\\
				-----------------right:tree(key:elephant value:elephant left:leaf right:leaf))\\
				--------right:tree(key:mouse value:souris\\
				-----------------left:tree(key:monkey value:singe left:leaf right:leaf)\\
				-----------------right:tree(key:tiger value:tigre left:leaf right:leaf)))
				\begin{itemize}
					\item What is printed after calling \{Browse \{Lookup mouse\}\}?\\
						\textit{``found(souris)''}
					\item How many calls to Lookup are done when calling \{Lookup tiger\}?\\
						\textit{``$3$''}
					\item How many calls to Lookup are done when calling \{Lookup rabbit\}? \\
						\textit{``$4$''}
					\item What is the tree T of the last call of Lookup when calling \{Lookup rabbit\}?\\
						\textit{``leaf''}
				\end{itemize}
			\subsubsection*{Insert function}
				Consider the following ordered search tree:\\
				T = tree(key:horse value:cheval\\
				--------left:tree(key:dog value:chien\\
				-----------------left:tree(key:cat value:chat left:leaf right:leaf)\\
				-----------------right:tree(key:elephant value:elephant left:leaf right:leaf))\\
				--------right:tree(key:mouse value:souris\\
				-----------------left:tree(key:monkey value:singe left:leaf right:leaf)\\
				-----------------right:tree(key:tiger value:tigre left:leaf right:leaf)))
				\begin{itemize}
					\item What is printed if we call \{Browse \{Lookup elephant \{Insert elephant mouche T\}\}\}?\\
						\textit{``found(mouche)''}
					\item How many calls to Insert are done while calling \{Insert elephant mouche T\}? (Count the original call to Insert)\\
						\textit{``$3$''}
					\item What is printed if we call \{Browse \{Lookup elephant \{Insert fly mouche T\}\}\}?\\
						\textit{``found(elephant)''}
					\item How many calls to Insert are done while calling \{Insert fly mouche T\}? (Count the original call to Insert)\\
						\textit{``$4$''}
				\end{itemize}
			\subsubsection*{Balanced trees}
				Let our ordered tree T be balanced.
				\begin{itemize}
					\item How many time units (in average) do we have while calling Lookup with 16 nodes in T?\\
						\textit{``$4$''}
					\item And with 31415 nodes in T? (approximately)\\
						\textit{``$15$''}
					\item Exercice \textbf{IsBalanced} : Ressource externe\\
						\lstinputlisting{Tree4.oz}
						\lstinputlisting{Tree5.oz}
				\end{itemize}
		\subsection{Deleting information from a search tree}
			Consider the following ordered search tree:\\
			T = tree(key:horse value:cheval\\
			--------left:tree(key:dog value:chien\\
			-----------------left:tree(key:cat value:chat left:leaf right:leaf)\\
			-----------------right:tree(key:elephant value:elephant left:leaf right:leaf))\\
			--------right:tree(key:mouse value:souris\\
			-----------------left:tree(key:monkey value:singe left:leaf right:leaf)\\
			-----------------right:tree(key:tiger value:tigre left:leaf right:leaf)))
			\begin{itemize}
				\item Let us call T1 the result of \{Delete dog T\}. What will be the key of T1.left? \\
					\textit{``elephant''}
				\item Let us call T2 the result of \{Delete mouse T\}. What will be the key of T2.right? \\
					\textit{``tiger''}
				\item Let us call T3 the result of \{Delete cat T\}. What will be the key of T3.left.left?\\ 
					\textit{``leaf''}
				\item Let us call T4 the result of \{Delete tiger T\}. What will be the key of T4.right.right? \\
					\textit{``leaf''}
				\item Let us call T5 the result of \{Delete monkey \{Delete horse T\}\}. What will be the key of T5? \\
					\textit{``mouse''}
				\item What is the key of the node \{Delete monkey \{Delete horse T\}\}.left? \\
					\textit{``dog''}
			\end{itemize}
		\subsection{Goal-oriented programming}
			\begin{itemize}
				\item In which domain is goal oriented programming widely used? (Two words, do not use initials)\\
					\textit{``artificial intelligence''}
			\end{itemize}
		\subsection{Computational complexity}
			\subsubsection*{Execution speed and big-O notation}
				Assume we have a problem which can be solved with different algorithms. Bellow, are the functions f(n) for each of theses algorithms.
				\begin{itemize}
					\item For a very big input size, which algorithm is going to finish its computation first ?\\
						\textit{``n''}
					\item Now we have a set of input data of different size and give the exact same time to each algorithm, which one will be able to solve the less problems ?\\
						\textit{``$2n\:\hat{}\:2$''}
					\item If $f(n)=3n^2+7$, which of the following holds ?\\
						\textit{``$f(n) \in O(n^2)$''}\\
						\textit{``$f(n) \in O(n^3)$''}\\
						\textit{``$f(n) \in O(2^n)$''}
				\end{itemize}
			\subsubsection*{Temporal complexity of the function Pascal}
				Consider the following algorithm:
				\lstinputlisting{Tree6.oz}
				Suppose we call \{Calculate N\}
				\begin{itemize}
					\item How many calls to \{Calculate N-1\} are made?\\
						\textit{``$3$''}
					\item How many calls to \{Calculate N-2\} are made?\\
						\textit{``$9$''}
					\item How many calls to \{Calculate N-4\} are made?\\
						\textit{``$81$''}
					\item How many calls to \{Calculate 0\} are made?\\
						\textit{``$3\:\hat{}\:n$''}
				\end{itemize}
					Now condider this other algorithm:
					\lstinputlisting{Tree7.oz}
				\begin{itemize}
					\item Considering n (the size of the input) is N, what is the complexity of the CalcAux function in big-O notation ?\\
						\textit{``O(n)''}
				\end{itemize}
			\subsubsection*{Best case, average case, and worst case}
				Consider the function \{Insert N L\} which returns a sorted list containing all the elements of L (L must only have integer), plus N. Assume that L is sorted from small to big, and so is the result.
				\begin{itemize}
					\item Which case are we in if N is bigger than all the elements of L?\\
						\textit{``Worst case''}
				\end{itemize}
					Now consider the function \{Smallest L\} which returns the smallest elements of the list L, for any list (sorted or not).
				\begin{itemize}
					\item If L is sorted from small to big, which case are we in ?\\
						\textit{``None of the above''}
				\end{itemize}
			\subsubsection*{Upper and lower bounds}
				\begin{itemize}
					\item If a function has the same lower and upper bounds, we talk about... (2 words)\\
						\textit{``asymptotic equivalence''}
				\end{itemize}
					Now let's consider again the function Insert. As a reminder, the function \{Insert N L\} returns a sorted list containing all the elements of L (L must only have integer), plus N (L is sorted from small to big, and so is the result).
				\begin{itemize}
					\item What is the lower bound in the worst case?\\
						\textit{``n''}
					\item What is the upper bound in the worst case?\\
						\textit{``n''}
					\item What about the best case, $f_{best} \in O(...)$? (if you think it doesn't exist, type `null')\\
						\textit{``1''}
				\end{itemize}
			\subsubsection*{Spatial complexity}
				\begin{itemize}
					\item Assume you start an algorithm on your computer. You pause the program and see that your process uses 42 Mo of memory. We are talking about ...\\
						\textit{``active memory''}
					\item Now assume that you run your algorithm for a few seconds, and see that your process now use 51 Mo. That makes a 9 Mo difference in say, 3 seconds. We are talking about ...\\
						\textit{``memory consumption''}
					\item Now imagine that your algorithm has nothing more to do and is waiting for some action (for example, a server waiting for a connection). It is then not doing any calculation. However it is still using 51 Mo. What is the transition that reprensents the life cycle of these 9 Mo when the program entered waiting?\\
						\textit{``Active $\rightarrow$ inactive''}
					\item A special algorithm can make these 9 Mo free, it's called ...\\
						\textit{``garbage collection''}
				\end{itemize}
		\subsection{Reflections on performance}
			\subsubsection*{Moore's Law and program optimization}
				\begin{itemize}
					\item Check the true propositions.\\
						\textit{``Even though clock speed is in a plateau, circuit density is still increasing.''}\\
						\textit{``Optimization is not always a good idea.''}
					\item When is it a good idea to optimize an algorithm?\\
						\textit{``When a bottleneck is spotted in the algorithm''}
				\end{itemize}
			\subsubsection*{Intractable problems and the class NP}
				\begin{itemize}
					\item A NP problem can be solved in...\\
						\textit{``nondeterministic polynomial time''}
					\item Assume we have a NP-Problem, and we find an algorithm which can find a solution in polynomial time. If we can derive an algorithm for any NP-problem, this problem is said to be...\\
						\textit{``NP-complete''}
					\item If such an algorithm is found, we can deduce that... (there is no whitespace in the answer)\\
						\textit{``$P=NP$''}
				\end{itemize}
			\subsubsection*{Coding ecercise to summarize computational complexity}
				\begin{itemize}
					\item What is the complexity of this function ? The answer should be formatted like in the previous exercises, and therefore should be like 'O(...)'. For exponential, use $\hat{}$ . (Also note that this exercise (and this one only, not the coding exercise bellow) is Bonus, it will not count and your final note).\\
						\textit{``$O(3\:\hat{}\:n)$''}
					\item Exercice \textbf{MasterOfRabbit} : Ressource externe\\
						\lstinputlisting{Tree8.oz}
						\lstinputlisting{Tree9.oz}
				\end{itemize}
	
	\section{Correctness and semantics}			
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Correctness and semantics%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Overview of semantics lesson}
			\begin{itemize}
				\item What general approach will be used in this course to define the semantics (two words)?\\
					\textit{``operational semantics''}
			\end{itemize}
		\subsection{Program correctness}
			\begin{itemize}
				\item In what language is a specification written?\\
					\textit{``Mathematics''}
				\item What kind of proof method do we use for a recursive function? (two words, not capitalized)\\
					\textit{``mathematical induction''}
				\item How many cases does this kind of proof consider? (enter a number)\\
					\textit{``2''}
				\item How many variables in memory does a local instruction create?\\
					\textit{``1''}
			\end{itemize}
			Now Consider the following code:
			\lstinputlisting{Corr1.oz}
			We begin the translation into the kernel language, you will have to complete the underlined part:
			\begin{itemize}
				\item You are asked to give the kernel language representation of ``N + \{Add N - 1\}''.\\
					\textit{``local I1 in''}\\
					\textit{``local N1 in''}\\
					\textit{``local R1 in''}\\
					\textit{``I1 = 1''}\\
					\textit{``N1 = N - I1''}\\
					\textit{``\{Add N1 R1\}''}\\
					\textit{``R = N + R1''}\\
					\textit{``end''}\\
					\textit{``end''}\\
					\textit{``end''}
				\item Which variable(s) are added in memory?\\
					\textit{``\{c\}''}
				\item Which reference(s) to identifier(s) are added to the environment?\\
					\textit{``\{C->c\}''}
			\end{itemize}
			Consider the following code:
			\lstinputlisting{Corr3.oz}
			\begin{itemize}
				\item What is the state of the memory when reaching the underlined ``end''?\\
					\textit{``\{a=false, b=true\}''}
			\end{itemize}
		\subsection{The abstract machine}
			\begin{itemize}
				\item Which of the following concepts are NOT part of the abstract machine?\\
					\textit{``Specification''}\\
					\textit{``Mathematical induction''}\\
					\textit{``Axiomatic semantics''}
				\item Which of the following can be calculated using the abstract machine?\\
					\textit{``Number of execution steps of a program in function of input size''}\\
					\textit{``Stack size (in number of instructions) of a program during its execution''}\\
					\textit{``How much memory a program uses''}\\
					\textit{``How garbage collection works''}\\
					\textit{``Why tail recursion works''}\\
					\textit{``How a procedure call works''}
				\item The environment allows to make the link between an instruction and the ...\\
					\textit{``memory''}
				\item While the semantic stack is not empty, we pop a semantic ... from the semantic stack\\
					\textit{``instruction''}
				\item and then, we execute it according to its corresponding semantic ... .\\
					\textit{``rule''}
			\end{itemize}
		\subsection{Semantic rules}
			\begin{itemize}
				\item How many elements are added to the semantic stack after the execution of a sequential composition?\\
					\textit{``$1$''}
				\item Which of the following kernel language instructions create variables in memory?\\
					\textit{``local''}\\
					\textit{``creation of a number''}\\
					\textit{``creation of a procedure''}\\
					\textit{``creation of a record''}
				\item What is modified after the execution of a local instruction?\\
					\textit{``the semantic stack''}\\
					\textit{``the memory''}
			\end{itemize}
			Consider the following code:
			\lstinputlisting{Corr4.oz}
			And consider the following execution state:\\
			\{[(A = 42, {A$\rightarrow$a, B$\rightarrow$b})], \{a, b=42\}\}
			\begin{itemize}
				\item What is the next execution state? Please respect carefully the syntax used above to represent the semantic stack, including spaces.\\
					\textit{``\{[], \{a=42, b=42\}\}''}
			\end{itemize}
			Consider now the following code:
			\lstinputlisting{Corr5.oz}
			\begin{itemize}
				\item Consider the fact that the variables a, b and c have been created in memory and the fact that the ``if'' instruction is being executed.\\
					\textit{``b = 42 (in memory)''}\\
					\textit{``the instruction waits until A is bound''}
			\end{itemize}
		\subsection{Procedure definition and call}
			\begin{itemize}
				\item When calling a procedure, what two things are used to calculate the environment needed to execute the procedure body?\\
					\textit{``Contextual environment''}\\
					\textit{``Arguments''}
			\end{itemize}
			Given the following program:
			\lstinputlisting{Corr6.oz}
			\begin{itemize}
				\item What are the identifiers in the environment just before executing the call \{MakeAdder A\}?\\
					\textit{``MakeAdder''}\\
					\textit{``A''}\\
					\textit{``Add''}
				\item What are the identifiers in the environment when the function body of MakeAdder is executed?\\
					\textit{``X''}
				\item What are the identifiers in the environment just before executing the call \{Add 100\}?\\
					\textit{``MakeAdder''}\\
					\textit{``A''}\\
					\textit{``Add''}
				\item What are the identifiers in the environment when the function body of Add is executed?\\
					\textit{``X''}\\
					\textit{``Y''}
			\end{itemize}
			Consider the following code:
			\lstinputlisting{Corr7.oz}
			\begin{itemize}
				\item Which are the free identifiers in Add?\\
					\textit{``B''}
			\end{itemize}
			Consider the fact that a variable name corresponds to its referring identifier name in lower case.
			In the environment that exists when the body of Add is executed (meaning after the call in \%1):
			\begin{itemize}
				\item A refers to the variable...\\
					\textit{``d''}
				\item B refers to the variable...\\
					\textit{``b''}
				\item C refers to the variable...\\
					\textit{``e''}
				\item R refers to the variable...\\
					\textit{``f''}
			\end{itemize}
		\subsection{Summary of semantics}
			\begin{itemize}
				\item If the semantics of a program is simple ...\\
					\textit{``the program's behavior is simplified''}
			\end{itemize}
			
\part{Louv1.2x}
	\section{Explicit state and data abstraction}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Explicit state and data abstraction%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Introduction to Louv1.2x}
			\begin{itemize}
				\item The concept that allow the representation of the world in a program to change is... (two words, singular)\\
					\textit{``explicit state''}
				\item What do you need to add to functional programming to get deterministic dataflow ? (not the concept, one word, singular)\\
					\textit{``thread''}
				\item What concept do you need to add to deterministic dataflow to get multiagent dataflow ? (one word)\\
					\textit{``nondeterminism''}
				\item What are the paradigms that will NOT be covered in this course ?\\
					\textit{``Functional programming''}\\
					\textit{``Context-oriented Programming''}
			\end{itemize}
		\subsection{What is state?}
			\subsubsection*{State as an abstract time}
				\begin{itemize}
					\item According to the course, a state is a ...\\
						\textit{``sequence of values calculated progressively, which contains the intermediate results of a computation''}
					\item According to this definition, what kind of state can be used by the functional paradigm?\\
						\textit{``implicit''}
				\end{itemize}
			\subsubsection*{Adding state to the language}
				\begin{itemize}
					\item What extension is added to the language in order to express the explicit state?\\
						\textit{``cell''}
					\item How many variables compose this new extension?\\
						\textit{``$2$''}
					\item Which of the following change through time?\\
						\textit{``the reference to the variable contained in this new extension''}
				\end{itemize}
		\subsection{Semantics of state}
			\subsubsection*{Structure euality and identity equality}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Two cells are the same if they are not created separately''}\\
						\textit{``Two lists are the same if they represent the same value''}
				\end{itemize}
			\subsubsection*{Cell semantics and kernel language}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``the cell's name is bound to a constant and can never change''}\\
						\textit{``the cell's content can be any variable in the single-assignment store''}\\
						\textit{``the cell's content can be changed''}
					\item Which paradigm do we obtain by adding cells to the functional paradigm?\\
						\textit{``imperative''}
					\item Exercice \textbf{FromImplicitToExplicit} : Ressource externe\\
						\lstinputlisting{ESDA1.oz}
				\end{itemize}
		\subsection{State and modularity}
			\begin{itemize}	
				\item Check the true statement(s):\\
					\textit{``In the functional paradigm, what works now will work in the future.''}\\
					\textit{``In the imperative paradigm, a function can be updated without changing the interface.''}
			\end{itemize}
		\subsection{Data abstraction}
			\subsubsection*{Encapsulation and data abstraction}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``The encapsulation increases the danger while using the implementation through the corresponding interface''}\\
						\textit{``The complexity of the implementation is hidden, therefore it is simpler for the user''}
					\item There are two fundamental ways to organize data abstractions. What are these two ways?\\
						\textit{``objects and abstract data types''}
				\end{itemize}
			\subsubsection*{Abstract data types}
				\begin{itemize}
					\item In what do we put a value to protect it?\\
						\textit{``wrapper''}
					\item Exercice \textbf{Shuffle} : Ressource externe\\
						\lstinputlisting{ESDA2.oz}
					\item Exercice \textbf{Calculator} : Ressource externe\\
						\lstinputlisting{ESDA3.oz}
				\end{itemize}
			\subsubsection*{Objects}
				\begin{itemize}
					\item Check the true statment(s):\\
						\textit{``In ADTs, values and operations are separated''}\\
						\textit{``Every data abstraction can be implemented as an ADT''}\\
						\textit{``Every data abstraction can be implemented as an object''}
				\end{itemize}
		\subsection{Summary of data abstraction}
			\begin{itemize}
				\item What are the two axes to compare data abstractions?\\
					\textit{``state and bundling''}
				\item Concerning objects and functional objects. Check the true statement(s):\\
					\textit{``Objects are mutables''}\\
					\textit{``Objects combine values and operations together''}\\
					\textit{``Functional objects combine values and operation together''}\\
					\textit{``Objects are popular''}
				\item Concerning ADTs and stateful ADTs. Check the true statement(s):\\
					\textit{``Stateful ADTs use cells''}\\
					\textit{``Stateful ADTs were often used in C''}
			\end{itemize}
	\section{Object-oriented programming}			
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Object-oriented programming%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Objects}
			\subsubsection*{The big picture}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Java provides encapsulation correctly''}\\
						\textit{``Inheritance is a main principle of OOP for structuring programs''}\\
						\textit{``Polymorphism is a main principle of OOP for structuring programs''}
				\end{itemize}
				
			\subsubsection*{Objects}
			Consider the following schema:
			\lstinputlisting{OOP1.oz}
				\begin{itemize}
					\item Does this schema correspond to an object?\\
						\textit{``No, because of A1, ..., and An''}
					\item Which concept, seen in the last videos, is used to avoid redundancy?\\
						\textit{``inheritance''}
				\end{itemize}
				
			\subsubsection*{From objects to OOP}
				\begin{itemize}
					\item What is the first step (given in the course) in the move to modern object-oriented language?\\
						\textit{``data abstraction''}
					\item What is the second step (given in the course) in the move to modern object-oriented language?\\
						\textit{``dispatch''}
					\item What is the third step (given in the course) in the move to modern object-oriented language?\\
						\textit{``instantiation''}
					\item What is the fourth step (given in the course) in the move to modern object-oriented language?\\
						\textit{``classes''}
					\item Exercice \textbf{Collection} : Ressource externe\\
						\lstinputlisting{OOP2.oz}
				\end{itemize}
				
		\subsection{Classes}
			\begin{itemize}
				\item Check the true statement(s):\\
				\textit{``Let Computer be a class. Computer is a value.''}\\
				\textit{``In Oz, class definition and object creation are separated.''}\\
				\textit{``A class is a record.''}\\
				\textit{``I can get the methods of Computer by using Computer.methods''}\\
				\textit{``The New function takes a class and returns an object, which is an instantiation of the input class.''}\\
				\textit{``S, in the New function (in the previous video), is a record built from a list.''}
				\item Exercice \textbf{Expressions} : Ressource externe\\
				\lstinputlisting{OOP3.oz}
				\item Exercice \textbf{Palindrome} : Ressource externe\\
				\lstinputlisting{OOP4.oz}
			\end{itemize}
		
		\subsection{Polymorphism}
			\begin{itemize}
				\item Check the correct statement(s):\\
					\textit{``A polymorphic program can be incorrect (some program properties may be not satisfied).''}
			\end{itemize}
			
		\subsection{Inheritance}
			\subsubsection*{Inheritance}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Inheritance is about extension or modification of classes and the avoidance of duplicate code.''}\\
						\textit{``Composition is when a object refers to another object through its attributes.''}
				\end{itemize}
			
			\subsubsection*{Example of the substitution principle}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``In AccountWithFee, the following line in transfer is useless but solves the problem: VerboseAccount,transfer(Amt)''}\\
						\textit{``In static link, using SuperClass,M, the class is known at the compilation time.''}
				\end{itemize}
				
		\subsection{Summary of object-oriented programming}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Through large-scale distributed programming, we can observe the current limits of data abstraction languages.''}
			\end{itemize}
	\section{Java, multiple inheritance and exception}			
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Java, multiple inheritance and exception%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Introduction to Java}
			\subsubsection*{Introduction to Java}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``C++ is closer to the processor architecture than Java.''}\\
					\textit{``Scala has a better typing system and better concurrency support than Java.''}\\
						\textit{``We will translate Java programs to OZ in order to present the semantics of Java.''}
				\end{itemize}
			\subsubsection*{Characteristics of Java}
				\begin{itemize}
					\item Check the true statement:\\
						\textit{``Java is an "almost" pure OOP.''}
					\item Check the true statement(s):\\
						\textit{``There are two kinds of type in Java: primitive types and reference types.''}\\
						\textit{``Java supports concurrent execution.''}
				\end{itemize}
			\subsubsection*{java semantics}
				\begin{itemize}
					\item When the value is copied into the local cell, we say that the passing is by ...\\
						\textit{``value''}
					\item When the reference is copied into the local cell, we say that the passing is by ...\\
						\textit{``reference''}
				\end{itemize}
		\subsection{Classes and objects in Java}
			\subsubsection*{Classes in Java}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Abstract classes exist in Java.''}
				\end{itemize}
			\subsubsection*{Java objects as data abstractions}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``It is possible to pass the wrap and unwrap functions to another part of the program by wrapping (and then unwrapping) them.''}\\
						\textit{``In Java, two objects that are instances of the same class can see each otherâ€™s private attributes.''}\\
						\textit{``The fact that objects are able to look inside two abstractions at the same time is an ADT property.''}
					\item Exercice \textbf{FromJavaToOz} : Ressource externe\\
						\lstinputlisting{JMIE1.oz}
				\end{itemize}
		\subsection{Multiple inheritance and Java interfaces}
			\subsubsection*{Multiple inheritance and the class hierarchy}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``If the language allows it, a class may have multiple superclasses.''}\\
						\textit{``The diamond problem is a classic multiple inheritance problem.''}
				\end{itemize}
			\subsubsection*{Java interfaces}
				\begin{itemize}
					\item Check the true statement(s)\\
						\textit{``Only the method headers are present in the java interfaces.''}\\
						\textit{``Java allows multiple inheritance for interfaces.''}\\
						\textit{``Putting only headers (no code) in the java interfaces solves the multiple inheritance problems.''}
				\end{itemize}
		\subsection{Exceptions}
			\subsubsection*{Handling exceptional situations}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``As the name says, exceptions are used to handle rarely occuring errors in the program.''}\\
						\textit{``There are two new instructions: ``try'' and ``raise''.''}
				\end{itemize}
			\subsubsection*{Example of exceptions}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{`` ``try'' can be used without ``catch''.''}\\
						\textit{``The code is much less complicated when using exceptions instead of records (to handle the errors).''}
					\item Exercice \textbf{Exceptions} : Ressource externe\\
						\lstinputlisting{JMIE2.oz}
				\end{itemize}
			\subsubsection*{Exceptions in Java}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{`` ``try'' and ``catch'' can (technically) be used to handle a normal execution.''}\\
						\textit{``Using ``try'' and ``catch'' to handle a normal execution is a bad style usage.''}
				\end{itemize}
		\subsection{Final remarks}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``In Scala, absolutely all entities are objects.''}\\
					\textit{``In Smalltalk, absolutely all entities are objects.''}\\
					\textit{`` ``deterministic dataflow'' is very powerfull and easy to use.''}
			\end{itemize}
	\section{Deterministic dataflow introduction}			
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Deterministic dataflow introduction%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Motivation for concurrency}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``In a concurrent program, we can have information that passes from one activity to another and activities that wait for a specific action.''}
			\end{itemize}
		\subsection{Introduction to deterministic dataflow}
			\subsubsection*{Introduction to deterministic dataflow}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``local A in local B in B = \{A 5\} end end. Consider this short piece of code. A concurrent activity cannot unlock this piece of code. ''}
				\end{itemize}
			\subsubsection*{Threads}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Threads are concurrent activities.''}\\
						\textit{``The Browser contains threads and can update its display when an unbound variable is bound.''}
				\end{itemize}
		\subsection{Streams and agents}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``The transformer reads a stream and produces a new stream.''}
				\item Exercice \textbf{ProducerConsumerFilter} : Ressource externe\\
					\lstinputlisting{DDI1.oz}
				\item Exercice \textbf{TrackingInfo} : Ressource externe\\
					\lstinputlisting{DDI2.oz}
			\end{itemize}
		\subsection{Nondeterminism}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``The decision of the scheduler is nondeterministic.''}\\
					\textit{``local X in thread X=1 end thread X=2 end end: the choice to bind X to 1 or to 2 depends on the scheduler.''}
			\end{itemize}
		\subsection{Summary of deterministic dataflow}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Sequential programming is a bottleneck, because systems are naturally concurrent.''}\\
					\textit{``Client/Server programs can be written using concurrent programming.''}
			\end{itemize}
			
	\section{Deterministic dataflow techniques}			
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Deterministic dataflow techniques%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Declarative concurrent techniques}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Adding threads can allow to continue in a program that would block without them.''}\\
					\textit{``Adding threads in the ``concurrency for dummies'' only changes ``WHEN'' the stuff inside threads are calculated, not what is calculated.''}
			\end{itemize}
		\subsection{List comprehensions as concurrent agents}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``In a declarative for loop, each iteration is independent.''}\\
					\textit{``In the collect procedure, a cell contains the end of the output list.''}\\
					\textit{``ForCollect is defined by combining cells and higher-order programming''}
				\item Exercice \textbf{ForCollect} : Ressource externe\\
					\lstinputlisting{DDT1.oz}
			\end{itemize}
		\subsection{Multi-agent programming}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``The Sieve program creates agents which remove numbers to finally obtain only prime numbers in a list.''}
				\item Exercice \textbf{IDontWantPrimeNumbers} : Ressource externe\\
					\lstinputlisting{DDT2.oz}
			\end{itemize}
		\subsection{Semantics of concurrency}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``A new semantic stack is created for each thread.''}\\
					\textit{``Created threads share the same memory.''}\\
					\textit{``If two threads share the same memory, then problems may appear because they may ``step on each others' toes''. However, this is avoided with interleaving semantics.''}\\
					\textit{``In a concurrent program, the scheduler picks one of the possible executions.''}
			\end{itemize}
		\subsection{Digital logic simulation}
			\subsubsection*{Digital logic simulation}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``In our example, gates are represented as agents.''}\\
						\textit{``Gates are active entities, the boolean function is not enough.''}\\
						\textit{``We represent the signal as a stream.''}\\
						\textit{``To create a gate using GateMaker, we just have to provide the corresponding boolean function.To create a gate using GateMaker, we just have to provide the corresponding boolean function.''}
				\end{itemize}
			\subsubsection*{Combinational logic}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``There is no memory inside the full adder.The output is at the same time instant as the input.''}
					\item Exercice \textbf{NFullAdder} : Ressource externe\\
						\lstinputlisting{DDT3.oz}
				\end{itemize}
			\subsubsection*{Sequential logic}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``We have to add 0 as initial value to shift elements in the stream.''}\\
						\textit{``Unlike combinational logic, sequential logic has memory.''}\\
						\textit{``The clock can freeze an element in memory.''}
				\end{itemize}
		\subsection{Summary of deterministic dataflow}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Threads should be cheap to use.''}\\
					\textit{``Thanks to threads, we can calculate partial results without already be able to provide the final result.''}\\
					\textit{``Nondeterminism should be used only when it is needed.''}
			\end{itemize}
	\section{Multiagent dataflow programming (bonus lesson)}	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Multiagent dataflow programming (bonus lesson)%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Introduction}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Agents have an identity. Hence, we can send them messages.''}\\
					\textit{``A new concept will be introduced: the port.''}
			\end{itemize}
		\subsection{Ports}
			\subsubsection*{Ports (named streams)}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``A port is an association of a name with a stream.''}\\
						\textit{``If you want to receive an answer to your message sent to the port P, you can send a pair (your\_message, unbound\_variable) to P.''}
					\item Exercice \textbf{InformationExchanges} : Ressource externe\\
						\lstinputlisting{MDP1.oz}
				\end{itemize}
			\subsubsection*{Example of ports}
				\begin{itemize}
					\item What will be S in the browser window if these lines are fed?
					(consider the state of S at the end of the video)\\
					\{Send P pair(r \_)\}
					\{Send P notpair(r \_)\}\\
						\textit{``a|a|a|b|pair(r ok)|pair(r ok)|notpair(r \_)|\_<future>''}
				\end{itemize}
		\subsection{Stateless Agents out of Ports}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Stateless agents are agents that perform some actions when they receive a message. The action depends on the message.''}\\
					\textit{``Each agent has a thread. ''}
				\item You wil have to fill this part of the code:
					\lstinputlisting{MDP2.oz}
					The question is: how to add 21 and 21 using R? Put the answer in Ans.\\
					\textit{``\{Send R add(21 21 Ans)\}''}
			\end{itemize}
		\subsection{Message sending}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Wait can be used to wait to an answer, in order to be synchronous.''}\\
					\textit{``It is possible to build an asynchronous send based on a synchronous send.''}
			\end{itemize}
		\subsection{Agents with state}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``An agent with state moves from one state to another when it receives a message.''}\\
					\textit{``An initial state is necessary to execute the agent for the first time.''}\\
					\textit{``The FoldL function returns a state.''}\\
					\textit{``To have a uniform interface, the agent can return a procedure (that sends to the port) instead of returning the port.''}
			\end{itemize}
		\subsection{Multiagent programming}
			\subsubsection*{Protocols}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Protocols are rules for sending and receiving messages.''}\\
						\textit{``If an agent wants a message to be broadcasted, it sends the message to the broadcaster.''}
				\end{itemize}
			\subsubsection*{Contract nets}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Contract net is a protocol.''}\\
						\textit{``There is an agreement between lifts, we choose a lift and the others agree they are not chosen.''}\\
						\textit{``To obtain an agreement, there is a coordinator.''}
				\end{itemize}
			\subsubsection*{Example of lift control system}
				\begin{itemize}
					\item Play with the given code to check the true statement(s). Consider the initializations (of L1, L2, etc.) in the file Main.oz. \\
						\textit{``If we feed the following region, we can see that L2 does not wait that L1 stops at the floor 5 to move.''}
						\lstinputlisting{MDP3.oz}
				\end{itemize}
		\subsection{Active objects}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``In active objects, a thread reads messages to call the corresponding methods.''}\\
					\textit{``The object attributes represent the state of the active object.''}
			\end{itemize}
	\section{Paradigms of computer programming redux}	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%Paradigms of computer programming redux%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Paradigms of this course}
			\subsubsection*{Paradigms of this course}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``Cells and Threads are two elements we added to the functional paradigm, in order to obtain new paradigms.''}
					\item Check the true statement(s):\\
						\textit{``In OOP, a tree is an object and its children, which are also trees, are objects too.''}
					\item Exercice \textbf{TreeAsObjects} : Ressource externe\\
						\lstinputlisting{Para1.oz}
				\end{itemize}
			\subsubsection*{Kernel language}
				\begin{itemize}
					\item Check the true statement(s):\\
						\textit{``We can express shared-state concurrent programming with the material we have seen in this course.''}
				\end{itemize}
		\subsection{The paradigm jungle}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Paradigms have much in common because they share many concepts.''}\\
					\textit{``If we add cells to the First-order functional programming paradigm, we obtain the Imperative programming paradigm.''}\\
					\textit{``Monotonic dataflow programming paradigm is another name for the paradigm that we saw: Declarative dataflow programming paradigm''}
				\item Check the true statement(s):\\
					\textit{``If my language does not use exceptions and if the function F1 calls the function F2, which calls the function F3 (a function that returns an atom if an error is detected), then F2 MUST catch the atom returned by F3 when F1 is called.''}
				\item Exercice \textbf{WeNeedExceptions} : Ressource externe\\
					\lstinputlisting{Para2.oz}
			\end{itemize}
		\subsection{Invent a new paradigm}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``We need a new concept when a program becomes too complicated and when this complexity is not related to the problem we want to solve.''}\\
					\textit{``We can implement Ports with Cells and Cells with Ports.''}
			\end{itemize}
		\subsection{The paradigm paradox}
			\begin{itemize}
				\item Check true statement(s):\\
					\textit{``The way we should think is: here is the problem that I want to solve, which concepts do I need for that?''}\\
					\textit{``Object-oriented programming is not the best paradigm for Internet programming.''}
			\end{itemize}
		\subsection{Summary of the course}
			\begin{itemize}
				\item Check the true statement(s):\\
					\textit{``Programming language design is a science of nature, \textbf{like physics}.''}\\
					\textit{``Computer programs can model systems with high randomness.''}\\
					\textit{``Mechanical systems tend to have low complexity.''}\\
					\textit{``Statistical mechanics is able to understand systems of high randomness.''}
			\end{itemize}
\end{document}
