\input{../../../lib.tex}

\DeclareMathOperator{\pgcd}{PGCD}

\hypertitle[']{fr}{Informatique}{3}{FSAB}{1402}
{Philippe Verbist}
{Peter Van Roy}

\lstset{language={Oz},morekeywords={for,do}}

\newcommand{\st}{\mathrm{ST}}
\newcommand{\ce}{\mathrm{CE}}
\newcommand{\mozart}{Mozart}





\newpage
\part{Correction des exercices d'APE}
\section{Séance 3 : Programmation récursive avec des listes}

\subsection{Exo 1 : Le minimum syndical}
\lstinputlisting{3-1.oz}

\subsection{Exo 2 : Décomposition}
\lstinputlisting{3-2.oz}

\subsection{Exo 3 : Quelle est la plus longue?}
\lstinputlisting{3-3.oz}
Invariant?

\subsection{Exo 4 : Concaténer deux listes}
\lstinputlisting{3-4.oz}

\subsection{Exo 5 : Pattern matching}
\lstinputlisting{3-5.oz}

\subsection{Exo 6 : Sous-séquences dans des listes}
\lstinputlisting{3-6.oz}

\subsection{Exo 7 : Multiplions}
\lstinputlisting{3-7.oz}

\subsection{Exo 8 : Nombres factoriels}
\lstinputlisting{3-8.oz}

\subsection{Exo 9 : Ecriture des listes}
\lstinputlisting{3-9.oz}

\subsection{Exo 10 : Traiter une liste}
\lstinputlisting{3-10.oz}


\subsection{Exo sup 1 : Mettons les listes à plat}
\lstinputlisting{3-sup-1.oz}

\subsection{Exo sup 2 : Occurrences d'une sous-liste}
\lstinputlisting{3-sup-2.oz}

\subsection{Exo sup 3 : Représentation binaire d'entiers avec des listes}
\lstinputlisting{3-sup-3.oz}










\newpage
\section{Séance 4 : Higher-order programming \& Enregistrements}

\subsection{Exo 1 : Enregistrements}
\lstinputlisting{4-1.oz}

\subsection{Exo 2 : Listes, tuples, enregistrements}
\lstinputlisting{4-2.oz}

\subsection{Exo 3 : Zig zag folding}
\lstinputlisting{4-3.oz}

\subsection{Exo 4 : Fibonacci generator}
\lstinputlisting{4-4.oz}











\newpage
\section{Séance 5 : Arbres}

\subsection{Exo 1 : Promenade arboricole}
\lstinputlisting{5-1.oz}

\subsection{Exo 2 : Arbre et programmation d'ordre supérieur}
\lstinputlisting{5-2.oz}

\subsection{Exo 3 : Trier une liste avec des arbres}
\lstinputlisting{5-3(a).oz}

\subsection{Exo 4 : Construction d'un arbre équilibré}
\lstinputlisting{5-4(a).oz}






\newpage
\section{Séance 8 : Programmer avec l'état}

\subsection{Exo 1 : Accumulateurs et état}
\lstinputlisting{8-1.oz}

\subsection{Exo 2 : Une calculatrice}
\lstinputlisting{8-2.oz}

\subsection{Exo 3 : Encapsulation de l'état de la pile}
\lstinputlisting{8-3.oz}

\subsection{Exo 4 : Mélanger une liste}
\lstinputlisting{8-4.oz}

\subsection{Exo sup 1 : Cellules et listes}
\lstinputlisting{8-sup-1.oz}


\newpage
\section{Séance 8 bis: Programmation orientée objet}
\subsection{Exo 1 : Collections}
\lstinputlisting{8bis-1.oz}

\subsection{Exo 2 : Des objets pour représenter des expressions}
\lstinputlisting{8bis-2.oz}

\subsection{Exo 3 : Elu par cette crapule}
\lstinputlisting{8bis-3.oz}


\newpage
\section{Séance 9 : Programmation concurrente et systèmes multi-agents}
\subsection{Exo 1 : Expliquez...}
\lstinputlisting{9-1.oz}

Les fils d'exécution sont créés les uns après les autres (comme écrit dans le code source). Cependant, leur exécution ne suit par nécessairement cet ordre.
Ici, les \textit{threads} terminent dans l'ordre: 3 - 4 - 2 - 1. 


\subsection{Exo 2 : Analysez...}
\lstinputlisting{9-2(a).oz}
X = 1, Y = 2, Z = 2
\lstinputlisting{9-2(b).oz}
X = 2, Y = 2, Z = 2

\subsection{Exo 3 : Producteur/Consommateur}
\lstinputlisting{9-3.oz}
La première version prend environ deux fois moins de temps pour s'exécuter.


\subsection{Exo 4 : Filtres}
\lstinputlisting{9-4(a).oz}
\lstinputlisting{9-4(b).oz}

\subsection{Exo 5 : Tracking Information}
\lstinputlisting{9-5.oz}



\newpage
\section{Séance 10 : Complexité calculatoire}
\subsection{Exo 1: Vrai ou faux?}
\lstinputlisting{10-1.oz}



















\newpage
\part*{Correction d'examens}
\section*{Janvier 2011}
\subsection*{Question 1 : Programmation déclarative}
\lstinputlisting{2011-01-1.oz}

\subsection*{Question 2 : Sémantique}
\lstinputlisting{2011-01-2(a).oz}
Le code affiche 109\\
Langage noyau:
\lstinputlisting{2011-01-2(b).oz}
Environnements contextuels:
\begin{itemize}
\item de la fonction \lstinline|F|:$E_{c,F}$ = \lstinline|{C1->c1}| 
\item de la fonction anonyme:$E_{c,anon}$ = 
\lstinline|{A->a, C1->c1, C2->c2prim}|, où \lstinline|c2prim| est la variable en mémoire correspondant à la cellule créée à la ligne 10: \lstinline|{NewCell N8 C2}|

\end{itemize}

\subsection*{Question 3: définitions}

\paragraph{Complexité temporelle dans le meilleur cas}
Soit un problème P(N1, N2, Nn). L'analyse de la complexité temporelle de ce problème consiste à décrire le nombre d'opérations à l'exécution en fonction des paramètres N1 ... Nn.
L'analyse de la complexité temporelle dans le meilleur cas consiste à choisir N1, N2, ... Nn tels que la résolution du problème soit la plus rapide. On obtient ainsi une fonction $\Omega$ définie comme suit:
$$ f(n)=\Omega(g(n)) \Leftrightarrow \exists n_0 > 0, \exists k>0: \forall n>n_0, f(n) \geq k\cdot g(n) $$
où $f(n)$ est la complexité temporelle (la vraie!)
et $\Omega(g(n))$ est la complexité temporelle dans le meilleur cas.

\paragraph{Portée lexicale d'une occurrence d'un identificateur}
Partie d'un programme dans laquelle l'identificateur correspond à la même variable en mémoire.
\begin{lstlisting}
local A=5 in % {A->a1}
	local A=3 in %{A->a2}
		{Browse A}
	end
	{Browse A}
end
\end{lstlisting}
La portée de l'identificateur A défini à la ligne 1 englobe les lignes suivantes: 1, 5-6
La portée de l'identificateur A défini à la ligne 2 englobe les lignes suivantes: 2-4



\paragraph{Environnement contextuel d'une procédure}
L'environnement est une fonction qui permet de faire la correspondance entre des identificateurs et des entités en mémoire. 
L'environnement contextuel d'une procédure est l'environnement qui englobe tous les identificateurs qui sont utilisés dans une procédure mais qui ne sont pas définis dans la définition de celle-ci.

\begin{lstlisting}
local A=5 B=3 in
	proc {FunnyFun C ?Out}
		Out = A+B+C
	end
end
\end{lstlisting}

L'environnement contextuel de FunnyFun est \{A->a, B->b\}.

\paragraph{Non-déterminisme}
Le non-déterminisme apparait, par exemple, lorsqu'on utilise la concurrence avec les cellules. Il s'agit du fait qu'on laisse un certain "choix" à l'ordinateur, et que ce choix influence le résultat. Par exemple:
\begin{lstlisting}
local A = {NewCell 0} in
	thread A:=2 end
	thread A:=5 end
end
\end{lstlisting}

A la fin de l'exécution de ce code, on ne sait pas si la valeur dans la cellule A sera 2 ou 5.


\paragraph{Correspondance des formes (pattern matching)} Le pattern matching consiste en une succession de clauses.
Une clause est exécutée, si la forme de l'élément dans l'instruction \lstinline|case| correspond à ce qui est compris dans la clause.
La forme correspond si l'étiquette (label) et les arguments correspondent. Si c'est le cas, les identificateurs de la forme sont affectés aux parties correspondantes. Les clauses sont testées dans l'ordre textuel.
La première à correspondre est exécutée et pas les autres.

Exemple:

\begin{lstlisting}
local A = [5 10] B in
	case A of nil then B = 0
	[]H|T then B=H
	[]M then B=matchEverything
	end
end
\end{lstlisting}

Dans cet exemple, B sera lié à 5. A noter que la clause []M permet de matcher n'importe quoi!

\paragraph{Cycle de vie d'un bloc mémoire}

Un bloc mémoire passe successivement par différentes étapes:\\
libre: le bloc n'est pas utilisé\\
actif: le bloc est utilisé par l'exécution d'un programme\\
inactif: lorsque le programme n'a plus besoin du bloc mémoire. Les blocs inactifs peuvent être récupérés par le garbage collector, et redeviennent alors libres.\\
Le passage de libre à actif s'appelle l'allocation et le passage inverse s'appelle la désallocation.








\end{document}
