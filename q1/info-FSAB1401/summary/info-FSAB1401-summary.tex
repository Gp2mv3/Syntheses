\documentclass[fr]{../../../eplsummary}

\usepackage{../../../eplcode}
\usepackage[SIunits]{../../../eplunits}

\hypertitle[']{Informatique}{1}{FSAB}{1401}
{Beno\^it Legat\and Antoine Paris}
{Olivier Bonaventure et Charles Pecheur}

\lstset{language={Java}}

\part{Instructions, expressions et variables}

\section{Instructions}
Un programme est composé principalement d'instructions qu'il exécute l'une à la
suite de l'autre.

Chaque instruction se termine par un \lstinline|;|, on les écrit tout le temps
une par ligne pour aider à la lecture du programme mais le compilateur
pourrait comprendre le programme s'ils n'étaient que sur une seule ligne.

\subsection{Blocs d'instruction}
Certaines structures de \java{} (comme le \lstinline|if|) demandent un bloc.
Un bloc, c'est simplement un regroupement d'instructions.
On le délimite avec des accolades
(\lstinline|{| et \lstinline|}|).
\begin{lstlisting}
{
  <instruction_1>;
  <instruction_2>;
  ...
  <instruction_n>;
}
\end{lstlisting}

\paragraph{Portée des variables}
Les variables déclarées dans un bloc ne sont pas accessibles à l'extérieur
du bloc.

\section{Expressions}
Un composé fondamental de ces instructions est l'expression.
Ces expressions sont composées d'opérations entre d'autres expressions.
Une valeur ou une variable sont tous les deux des expressions.
Chaque expression est évaluée lors de l'exécution du programme.

\section{Variables}
Dans un programme, on utilise des variables comme en mathématiques.
Par contre, en informatique, les variables peuvent changer de valeur.

Chaque variable a un type et en \java{}, on ne peut pas changer son type.

Pour créer une variable, il faut lui donner un type et ce type ne changera
plus par la suite.
\subsection{Types}
Il y a deux sortes de type en \java{}, les types primitifs et les classes.

Il y a 8 types primitifs mais les plus importants sont les
\begin{itemize}
  \item \lstinline|int|, ce sont des nombres entiers, ils valent par exemple
    \lstinline|0| ou \lstinline|-8| ou encore \lstinline|42|;
  \item \lstinline|double|, ce sont les nombres à virgule, il valent par exemple
    \lstinline|3.14| ou \lstinline|1.41|;
  \item \lstinline|char|, ce sont les charactères,
    il valent par exemple \lstinline|'a'|
    ou \lstinline|'A'| ou \lstinline|'0'| ou
    même un retour à la ligne \lstinline|'\n'|;
  \item \lstinline|boolean|, ils valent \lstinline|true| ou \lstinline|false|.
\end{itemize}
Les autres sont comme les \lstinline|int| ou les \lstinline|double|
mais utilisent plus
ou moins de mémoire. Cependant, à l'époque actuelle, la mémoire n'est plus
si limitée et ils sont moins utilisés.

Par contre il est important de remarquer que ces deux types ne savent
pas contenir des nombres d'une taille arbitraire, ils ont chacun leur limite
\begin{itemize}
  \item Un \lstinline|int| sait seulement contenir un entier appartenant à
    $[-2^{31}; 2^{31}[$. On retient que
    \[ 2^{31} = 2 \cdot \left(2^{10}\right)^3 = 2 \cdot (1024)^3
    \approx 2 \cdot (1000)^3 = \numprint{2e9}; \]
  \item Un \lstinline|double| retient un nombre à virgule flottante,
    c'est à dire
    qu'il le retient en écriture scientifique.
    Il retient ses décimales et la puissance de 10.
    Il peut donc être très grand mais n'est pas si précis que ça.

    Vous pouvez vous en apercevoir en vérifiant que l'expression
    \begin{lstlisting}
0.1 + 0.2 == 0.3
    \end{lstlisting}
    est évalué à \lstinline|false|.
    C'est du au fait que les décimales sont écrite en binaire dans la mémoire
    et que ces nombres ne sont pas si rond en binaire.

    En règle générale, on ne test jamais l'égalité entre deux \lstinline|double|
    mais plutôt la valeur absolue de leur différence.
\end{itemize}

\subsection{Manipulation de variables}
On peut utiliser les variables de 3 manières différentes, on peut les créer,
leur assigner une valeur et la lire dans une expression.
Dans les exemples de cette sous-section, on considèrera qu'on utilise des
\lstinline|int| mais c'est évidemment le même principe pour les autres types
primitifs.

\subsubsection{Création d'une variable}
Pour créer une variable, il faut lui choisir un nom qui n'est pas encore
utilisé, il ne peut pas commencer par un chiffre mais peut contenir chiffres,
lettres et underscores (\lstinline|_|).

Supposons qu'on crée un \lstinline|int| qu'on appelle \lstinline|foobar|.
\begin{lstlisting}
int foobar;
\end{lstlisting}
Lors de leur création,
les variables sont initialisées à \lstinline|0| ce qui pour
les \lstinline|boolean| signifie \lstinline|false|.

On peut aussi donner une valeur lors de l'initialisation de la variable
comme dans l'exemple suivant
\begin{lstlisting}
int foobar = 1;
\end{lstlisting}

\subsubsection{Assignation}
On peut modifier la valeur d'une variable à tout moment du programme en lui
assignant la valeur d'une expression. Il faut bien évidemment que la valeur
de l'expression soit du même type. La syntaxe est la suivante
\begin{lstlisting}
foobar = <expression>;
\end{lstlisting}

Il est important de remarquer que le \lstinline|=| de l'assignation n'est pas le
même qu'en mathématique, on peut par exemple faire
\begin{lstlisting}
foobar = foobar + 1;
\end{lstlisting}

Dans ce cas ci, il est important d'insister sur l'ordre à l'exécution.
On évalue d'abord le membre de droite qui n'est rien d'autre qu'une expression
puis on assigne cette valeur dans le membre de gauche.

\subsubsection{Casting}
Supposons que \lstinline|a| soit de type \lstinline|<type_a>| et \lstinline|b|
soit de type \lstinline|<type_b>| et
qu'on veuille assigner à \lstinline|a| la valeur de \lstinline|b|.

Si \lstinline|<type_a>| et \lstinline|<type_b>| ne sont pas les mêmes, on a deux
possibilités.
\begin{itemize}
  \item Soit on fait un \emph{cast explicite}, c'est à dire qu'on
    spécifie à \java{} qu'on veut transformer la valeur de \lstinline|b| pour
    qu'elle ait le type \lstinline|<type_a>|. La syntaxe est la suivante
    \begin{lstlisting}
(<type_a>) b
    \end{lstlisting}
    Évidemment, ça ne marche pas pour n'importe quel type.
    On peut caster n'importe quel type primitif dans n'importe quel type
    primitif mais on ne peut pas caster un type primitif dans un objet ni
    le contraire (sauf entre les types primitifs et leur classe wrapper comme
    \lstinline|int| et \lstinline|Integer|).
    Par contre, on peut caster un objet dans un autre si et seulement si,
    l'un hérite de l'autre ou le contraire;
  \item Soit on fait un \emph{cast implicite}, comme son nom l'indique,
    on ne dit rien à \java{} mais il effectue tout de même un cast.
    Entre type primitifs, en règle générale,
    \java{} fait un cast quand il ne perd pas de précision.
    Les casts se faisant implicitement sont donc
    \begin{itemize}
      \item \lstinline|char| à \lstinline|int|;
      \item \lstinline|int| à \lstinline|double|;
      \item \lstinline|int| à \lstinline|Integer| et vice versa;
      \item \lstinline|char| à \lstinline|Character| et vice versa;
      \item \lstinline|double| à \lstinline|Double| et vice versa;
      \item \lstinline|boolean| à \lstinline|Boolean| et vice versa;
      \item \lstinline|<class_1>| à \lstinline|<class_2>|
        si \lstinline|<class_1>| hérite de \lstinline|<class_2>|.
    \end{itemize}
    Sans parler des \lstinline|byte|, \lstinline|short| et \lstinline|float|.
    De plus, il y a une relation de transitivité entre les casts
    implicites, c'est à dire que si on sait caster implicitement
    \lstinline|<type_1>| dans \lstinline|<type_2>| et
    \lstinline|<type_2>| dans \lstinline|<type_3>|, on sait caster implicitement
    \lstinline|<type_1>| dans \lstinline|<type_3>|.
\end{itemize}

\paragraph{Encodage}
Le cast de \lstinline|char| en \lstinline|int| peut paraitre
étrange si on ne comprend pas comment
un caractère est socké dans un ordinateur.
Un ordinateur ne sait stocker que des nombres,
il a donc une tableau de traduction des nombres en caractère.

En castant un \lstinline|char| en \lstinline|int|, on voit le nombre
qui est réellement stocké dans l'ordinateur.
Ce tableau de traduction dépend de l'encodage.
Comme l'informatique a commencé au États-Unis,
le premier encodage, l'ASCII, ne traitait que les caractères de l'alphabet
latin non-accentués et les autres caractères du clavier qwerty.
Cet encodage n'utilisait que 128 caractères alors qu'on peut avoir
256 nombres différents sur un byte.

Il restait donc un peu de place et presque un encodage différent
pour chaque langue a été créé en donnant en utilisant ces places restantes
(c'est le cas du latin-1).
Ainsi tous les caractères pouvaient être stockés sur 1 byte
(sauf pour certaines langues).

Le problème de tous ces encodages c'est qu'on ne pouvait pas utiliser
2 alphabets différents dans un même texte et qu'il y avait
souvent des problèmes de compatibilité.

L'unicode a donc été créé avec l'UTF-8 qui permet d'écrire presque
tous les caractères possibles et imaginables.
Les caractères simples n'utilisent toujours qu'un seul byte et les caractères
plus complexes comme ceux de l'alphabet Klingon prennent plus de bytes.
Le fait que tous les caractères n'utilisent pas le même nombre de byte
permet de gagner beaucoup de place car
on utilise le plus souvent des caractères simples.

Heureusement, la plupart de ces encodages (dont l'UTF-8) utilisent
la même traduction que l'ascii pour les caractères simples,
c'est pour ça que quand vous avez des problèmes d'encodage, il n'y a que
les caractères spéciaux comme les caractères accentués qui rende bizarrement.

Si on veut voir la valeur d'un caractère représentant un chiffre,
il faut prendre en compte le fait que les chiffres se suivent dans la table
comme on peut voir dans la table~\ref{tab:ascii}.
\begin{table}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    Décimal & Symbol\\
    \hline
    $\vdots$ & $\vdots$\\
    \hline
    48 & 0\\
    \hline
    49 & 1\\
    \hline
    50 & 2\\
    \hline
    51 & 3\\
    \hline
    52 & 4\\
    \hline
    53 & 5\\
    \hline
    54 & 6\\
    \hline
    55 & 7\\
    \hline
    56 & 8\\
    \hline
    57 & 9\\
    \hline
    $\vdots$ & $\vdots$\\
    \hline
  \end{tabular}
  \caption{Tableau ascii pour les chiffres.}
  \label{tab:ascii}
\end{table}
Si \lstinline|c| vaut \lstinline|'1'| et qu'on fait \lstinline|int i = c|,
\lstinline|i| vaudra 49.
Pour avoir 1, il faut faire \lstinline|int i = c - '0'|.
On peut aussi faire \lstinline|int i = Character.digit(c, 10)|.

\paragraph{Casting et héritage}
\label{sec:cast_class}
On a vu qu'on pouvait caster des objets dans une classe parente.
Mais quand on fait cela, on ne sait évidemment plus appeler ses méthodes
spécifiques que la classe parente n'a pas.
Grâce au keyword \lstinline|instanceof|, on peut néanmoins recaster l'objet
dans la classe de départ en vérifiant que c'est bien une instance de cette
classe.
Par exemple, on peut implémenter la méthode \lstinline|equals| comme suit
\begin{lstlisting}
public class Foo {
  int data;
  public Foo (int data) {
    this.data = data;
  }
  public boolean equals (Object o) {
    if (o instanceof Foo) {
      Foo foo = (Foo) o;
      return this.data == foo.data;
    }
    return false;
  }
}
\end{lstlisting}
Ainsi, ça permet de donner comme argument à \lstinline|equals| un objet de
n'importe quel classe car toute classe hérite de \lstinline|Object|.

\subsubsection{Les constantes}
En informatique, on aime bien se donner des règles supplémentaires à respecter
qui sont vérifiées par le compilateur pour diminuer le plus possible les
chances que notre programme compile mais ne fonctionne pas.

Pour cela, il est possible de spécifier que des variables sont constantes.
Dès qu'on voudra modifier leur valeur, le code ne compilera pas.

Pour cela, à la création de la variable, on ajoute le keyword \lstinline|final|
de la manière suivante.
\begin{lstlisting}
final <type> <name>[ = <expression>];
\end{lstlisting}
Si on ne donne pas \lstinline| = <expression>|, on peut encore lui faire une
assignation.
Ça permet d'initialiser les variables dans le constructeur en fonction
de ses paramètres.

\paragraph{Assignation de la même valeur}
En fait, on a le droit d'assigner une valeur à une constante autant de
fois qu'on veut, tant que cette valeur est la même que celle de la constante
ou que la contante n'a pas encore été initialisée.

\paragraph{Convention}
Par convention, on écrit tout le temps les constantes en majuscule.

\subsubsection{Les raccourcis}
Certaines assignations sont très courrantes, elles possèdent donc un raccourcis.
\begin{lstlisting}
foo = foo + bar;
\end{lstlisting}
peut s'écrire
\begin{lstlisting}
foo += bar;
\end{lstlisting}
Il y a des raccourcis similaire pour les opérateurs
\lstinline|-|, \lstinline|*| et \lstinline|/|.

Encore plus raccourcis, au lieu d'écrire
\begin{lstlisting}
foo += 1;
\end{lstlisting}
on peut écrire
\begin{lstlisting}
foo++;
\end{lstlisting}
Il y a un raccourci pour l'opérateur \lstinline|-|.

\section{Les opérateurs}
Les expressions seraient bien pauvres si on ne pouvait pas les manipuler
entre elles.
Il existe les opérateurs suivants dont le résultat est du même type
que les deux variables sur lesquels ils sont appliqués
\begin{center}
  \begin{tabular}{|c|l|}
    \hline
    \lstinline|a + b| & Vaut la somme de \lstinline|a| et \lstinline|b|\\
    \hline
    \lstinline|a - b| & Vaut la soustraction de \lstinline|a| par \lstinline|b|\\
    \hline
    \lstinline|a * b| & Vaut la multiplication de \lstinline|a| et \lstinline|b|\\
    \hline
    \lstinline|a / b| & Vaut la division de \lstinline|a| par \lstinline|b|\\
    \hline
    \lstinline|a % b| & Vaut le reste de la division euclidienne
    de \lstinline|a| par \lstinline|b|\\
    \hline
  \end{tabular}
\end{center}
Il existe aussi des opérateurs dont le résultat est un \lstinline|boolean|
\begin{center}
  \begin{tabular}{|c|l|}
    \hline
    \lstinline|a == b| & Vaut \lstinline|true|
    si \lstinline|a| est égal à \lstinline|b|\\
    \hline
    \lstinline|a != b| & Vaut \lstinline|true|
    si \lstinline|a| est différent de \lstinline|b|\\
    \hline
    \lstinline|a < b| & Vaut \lstinline|true| si \lstinline|a| est plus petit
    strictement que \lstinline|b|\\
    \hline
    \lstinline|a <= b| & Vaut \lstinline|true| si \lstinline|a| est plus petit
    ou égal à \lstinline|b|\\
    \hline
    \lstinline|a > b| & Vaut \lstinline|true| si \lstinline|a| est plus grand
    strictement que \lstinline|b|\\
    \hline
    \lstinline|a >= b| & Vaut \lstinline|true| si \lstinline|a| est plus grand
    ou égal à \lstinline|b|\\
    \hline
  \end{tabular}
\end{center}

Tous ces opérateurs sont des opérateurs binaires car ils recquièrent deux
valeurs.
Il existe aussi un opérateur unaire et un opérateur ternaire
\begin{center}
  \begin{tabular}{|c|l|}
    \hline
    %\lstinline|!a| & Vaut \lstinline|true| si \lstinline|a|
    %vaut \lstinline|false| et
    %vaut \lstinline|false| sinon\\
    \hline
    %\lstinline|a ? b : c| & Vaut \lstinline|b| si \lstinline|a|
    %vaut \lstinline|true| et
    %vaut \lstinline|c| sinon\\
    \hline
  \end{tabular}
\end{center}

\part{Structures de contrôle}
Quand on exécute un programme, les instructions s'exécutent l'une après
l'autre, dans l'ordre dans lequel elles ont été écrites.

Seulement, il existe des moyens de passez outre cet ordre.

\paragraph{Les conditions}
Une condition est toute expression s'évaluant en \lstinline|boolean|.

\section{Bloc, instruction ou structure de contrôle ?}
\label{sec:bloci}
Ce qui est magique avec les stuctures de contrôle, c'est qu'elles permettent
de manipuler, non plus des variables, mais carrément des instructions !
Elles permettent de déterminer si certaines instructions vont être exécutées
en fonction de la valeur d'une condition.

Comme on veut parfois appliquer cela sur plusieurs instructions,
on dit que ces structures conditionnelles s'appliquent sur
des blocs d'instructions.
Seulement, on peut aussi donner une seule instruction où même directement
une structure de contrôle sans les mettre dans un bloc (sans accolade).

En fait, si on ne leur donne pas un bloc mais directement des instructions,
ces structures prennent la première instruction.

Attention néanmoins car la pratique de donner une instruction au lieu d'un
bloc à ces structures, bien qu'acceptée par \java{}, n'enchante pas
tous les programmeurs.
En effet, elle ajoute souvent de l'ambiguïté et rappelle donc pour beaucoup
du temps perdu à débugger.

Pour illustrer cela, remarquez que, contrairement aux apparences,
\begin{lstlisting}
if (a_number % another_number == 0)
  amount_of_divisors++;
  is_prime = false;
\end{lstlisting}
est équivalent à
\begin{lstlisting}
if (a_number % another_number == 0) {
  amount_of_divisors++;
}
is_prime = false;
\end{lstlisting}
et non à
\begin{lstlisting}
if (a_number % another_number == 0) {
  amount_of_divisors++;
  is_prime = false;
}
\end{lstlisting}

\section{Les structures conditionnelles}
Il est possible d'exécuter un bloc d'instruction seulement si une condition
est vraie.
\begin{lstlisting}
if (<condition>) <bloc>
\end{lstlisting}
Le bloc sera exécuté seulement si la condition vaut \lstinline|true|.

Il est possible de demander d'exécuter un autre bloc si la condition est fausse.
\begin{lstlisting}
if (<condition>) <bloc_1>
else <bloc_2>
\end{lstlisting}
Si la condition vaut \lstinline|true|, le premier bloc sera exécuté, sinon, le
second bloc sera exécuté.

\subsection{Quid des else if ?}
Rappelons-nous (voir Section~\ref{sec:bloci}) qu'à la place d'un bloc,
on peut donner une structure de contrôle.
On peut donc dire que
\begin{lstlisting}
if (<condition_1>) <bloc_1>
else if (<condition_2>) <bloc_2>
else <bloc_3>
\end{lstlisting}
est équivalent à
\begin{lstlisting}
if (<condition_1>) <bloc_1>
else {
  if (<condition_2>) <bloc_2>
  else <bloc_3>
}
\end{lstlisting}

Les \lstinline|else if| ne sont donc pas vraiment un nouveau concept lorsqu'on
connait les \lstinline|else| et les \lstinline|if|.

\section{Les boucles}
Une boucle exécute un bloc \emph{tant que} la condition est vraie.
Avant chaque exécution du bloc,
il vérifie si la condition vaut \lstinline|true|.
Si c'est le cas, le bloc est exécuté.
Sinon, le programme poursuit son court.

La syntaxe est fort semblable au \lstinline|if|.
\begin{lstlisting}
while (<condition>) <bloc>
\end{lstlisting}

\subsection{Les boucles for}
Lorsqu'on veut itérer une opération, souvent, on a un itérateur qu'on
initialise avant la boucle et qu'on incrémente après chaque boucle.
\begin{lstlisting}
<init>;
while (condition) {
  ...
  <inc>;
}
\end{lstlisting}

La boucle \lstinline|for| permet d'écrire ça de façon plus condensée
\begin{lstlisting}
for (<init>; <condition>; <inc>) {
  ...
}
\end{lstlisting}

\begin{itemize}
  \item \lstinline|<init>| peut être n'importe quelle
    instruction mais si elle crée
    des variables, ces dernières seront locales au \lstinline|for|;
  \item \lstinline|<inc>| peut être n'importe quelle instruction, ça peut même
    contenir plusieurs instructions séparées par des virgules mais cette
    pratique n'est pas appréciée par tout le monde.
\end{itemize}
Le fait que les variables déclarées dans \lstinline|<init>| ne soit pas accessibles en dehors de la boucle
est assez pratique car souvent,
on y déclare des variables dont on aura pas besoin après le \lstinline|for|.
C'est souvent des variables qui nous permettent de parcourir un tableau,
c'est pourquoi on les appelle des itérateurs.

\part{Les tableaux}
Le tableau de \java{} est une structure de donnée assez intéressante.
Elle permet de stocker un nombre fixe de variables de même type
ou héritant d'une même classe (Voir Section~\ref{sec:cast_class}).

\section{Création de tableaux}
Une variable ne contient jamais un tableau en lui même,
tout comme les objects, elle contient une référence vers un tableau.
À sa création, elle vaut \lstinline|null|.

Pour créer un tableau, un utilise le keyword \lstinline|new|.
Il crée un nouveau tableau et renvoit sa référence.

\subsection{Création de tableau à une dimension}
On utilise la syntaxe suivante
\footnote{Ici, les \\ devant les [, ] servent à dire que ce n'est
pas de crochets pour dire que c'est optionnel mais vraiment des
crochets qu'il faut mettre.}
\begin{lstlisting}
<type>\[\] <name> = new <type>\[<length>\];
\end{lstlisting}

Par exemple,
pour faire un tableau qu'on nomme \lstinline|tab| de 42 \lstinline|int|,
on écrit
\begin{lstlisting}
int[] tab = new int[42];
\end{lstlisting}

\subsection{Création de tableau à plusieurs dimension}
On fait un tableau à plus d'une dimension en faisant des tableaux de tableau.
Par exemple, si dans chaque case d'un tableau à 2 éléments, on met un
tableau de \lstinline|int| à 4 éléments, on a une matrice $2 \times 4$.
Ça s'écrit
\begin{lstlisting}
int[][] matrix = new int[2][4];
\end{lstlisting}

\section{Manipulation de tableau}
Lorsqu'on a créé un tableau, on peut changer ses valeurs (sauf si c'est un
tableau de constante bien entendu) ou juste y accéder.

Il faut cependant savoir qu'en informatique, on commence à compter à partir
de 0, donc la \lstinline|n|\ieme{} case est à l'indice \lstinline|n-1|.

Pour obtenir la 21\ieme{} case du tableau \lstinline|tab|, il faut donc faire
\begin{lstlisting}
tab[20]
\end{lstlisting}

Pour assigner à la 2\ieme{} colonne de la 1\iere{} ligne de \lstinline|matrix|
la valeur 42, il faut écrire
\begin{lstlisting}
matrix[0][1] = 42;
\end{lstlisting}

\subsection{Taille de tableau}
La taille d'un tableau est son nombre d'éléments.
Elle est fixe.
Pour obtenir la taille du tableau \lstinline|tab|, on fait
\begin{lstlisting}
tab.length
\end{lstlisting}
et ça vaudrait 2.

Si on voulait le nombre de colonnes d'une matrice, il suffit de demander
le nombre d'élément de n'importe quelle ligne (s'il y en a au moins une !).
\begin{lstlisting}
matrix[0].length
\end{lstlisting}
Mais dans la plupart des cas,
on peut juste redemander la longueur pour chaque ligne.

\subsection{Exemples}
Pour illustrer cela, voici comment faire une méthode qui fait la somme des
éléments d'un tableau de \lstinline|int| à deux dimension.
\begin{lstlisting}
public static int sumMatrix (int[][] matrix) {
  sum = 0;
  for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[i].length; j++) {
      sum += matrix[i][j];
    }
  }
  return sum;
}
\end{lstlisting}

Et voici une méthode qui fait la copie d'un tableau.
En effet, quand on fait une assignation d'un tableau avec la valeur d'un autre
tableau, on fait une copie de la référence mais le tableau reste le même !
\begin{lstlisting}
public static int[] arrayCopy (int[] array) {
  int[] copy = new int[array.length];
  for (int i = 0; i < array.length; i++) {
    copy[i] = array[i];
  }
  return copy;
}
\end{lstlisting}

\part{Les classes}
\section{La portée}
Les variables et les méthodes ont une certaine portée, c'est à dire
qu'on ne peut pas y accéder depuis n'importe où.

À chaque fois qu'on défini une méthode ou une variable de classe ou
d'instance, on doit lui attribuer une portée.

Il existe 3 portées différentes
\begin{itemize}
  \item \lstinline|public|: peut être accédé depuis n'importe quelle
    classe et n'importe quel object;
  \item \lstinline|protected|: peut être accédé depuis toute classe ou object
    de la classe en question ou d'une classe fille; % TODO def fille
  \item \lstinline|private|: peut être accédé uniquement depuis la classe
    en question et ses instances.
\end{itemize}

De plus, on ne peut pas accéder à une variable ou méthode d'instance
depuis une méthode de classe.

Pour spécifier la portée d'une variable ou d'une méthode, on rajoute le keyword
\lstinline|public|, \lstinline|protected| ou \lstinline|private| en fonction
de la portée au début de sa définition.

En anglais, portée se dit \emph{scope}.

\section{Variables et méthodes}
\label{sec:varmeth}
\subsection{Statique ou non-statique}
Dans une classe, on peut définir des variables et des méthodes.
Ces dernières peuvent être soit statiques, soit non-statiques.
\begin{description}
  \item[statiques] Ce sont les méthodes et variables de classe.
    Elles sont dans la classe uniquement pour des raisons de portée.
    Les variables statiques ne sont créées qu'une seule fois même si
    42 instances de la classe sont créées.
    C'est pourquoi les constantes sont souvent statiques.
  \item[non-statiques] Ce sont les méthodes et variables d'instance.
    De nouvelles variables sont créées à chaque création d'instance de
    la classe.
    Les variables d'instance référencées dans les méthodes d'instance
    sont celles spécifique de l'object en question.
    Les variables d'instances constituent le \emph{contexte} de l'objet.
    Lorsqu'on appelle des méthodes d'instances sur un objet, ces méthodes
    sont dans le contexte de cet objet, elle peuvent le lire et le modifier.
\end{description}

Pour spécifier si une variable ou une méthode est statique,
on ajoute le keyword \lstinline|static|
à la suite du keyword pour la portée.
Si le keyword n'est pas présent, elle est non-statique.

\subsubsection{Le secret des méthodes non-statiques}
La difficulté de comprendre ce concept vient du fait
qu'on est jamais obligé d'écrire une méthode en non-statique,
\emph{toute méthode non-statique peut être écrite en méthode
statique}.
D'ailleurs, on pourrait imaginer que \java{} transforme toutes
les méthodes non-statiques en méthodes statiques juste avant
la compilation pour se simplifier la vie,
les méthodes non-statiques ne
seraient alors que là pour faciliter la vie du programmeur.
Par exemple, prenons la classe suivante
\begin{lstlisting}
public class Soldier {
  private int HP;
  private int attack;
  public Soldier (int HP0, int attack) {
    HP = HP0;
    this.attack = attack;
  }
  public void getShot (int damage) {
    HP -= damage;
  }
  public boolean isAlive () {
    return HP > 0;
  }
  public void shoot (Soldier s) {
    if (isAlive()) {
      s.getShot(attack);
    }
  }
  public static void main (String[] args) {
    Soldier a = new Soldier(100, 10);
    Soldier b = new Soldier(100, 11);
    while (a.isAlive() && b.isAlive()) {
      a.shoot(b);
      if (b.isAlive()) {
        b.shoot(a);
      }
    }
  }
}
\end{lstlisting}
\java{} commencerait par ajouter des \lstinline{this} pour lever
toute ambiguité.
Puis changerait toutes les méthodes non-statiques en statiques
juste en rajoutant un argument et le keyword \lstinline{static}.
Ces méthodes pourraient toujours accéder aux variables instances même si elles
sont \lstinline{private} car elles sont dans la même classe.
\java{} changerait ensuite tous les appels en appelant les méthodes
sur la classe et non sur les objets et donnerait ces objets en argument.
\begin{lstlisting}
public class Soldier {
  private int HP;
  private int attack;
  public Soldier (int HP0, int attack) {
    this.HP = HP0;
    this.attack = attack;
  }
  public static void getShot (Soldier this, int damage) {
    this.HP -= damage;
  }
  public static boolean isAlive (Soldier this) {
    return this.HP > 0;
  }
  public static void shoot (Soldier this, Soldier s) {
    if (HP > 0) {
      Soldier.getShot(s, this.attack);
    }
  }
  public static void main (String[] args) {
    Soldier a = new Soldier(100, 10);
    Soldier b = new Soldier(100, 11);
    while (Soldier.isAlive(a) && Soldier.isAlive(b)) {
      Soldier.shoot(a, b);
      if (Soldier.isAlive(b)) {
        Soldier.shoot(b, a);
      }
    }
  }
}
\end{lstlisting}
Ici, \lstinline{Soldier.} devant les méthodes est facultatif
car on est dans la méthode \lstinline{Soldier}.

\subsection{Méthodes}
Une méthode est comme une fonction mathématique, on lui donne des
argument et elle renvoit une valeur en fonction de ces arguments.

Si c'est une méthode d'instance, son comportement dépendra aussi de son
contexte, c'est à dire de la valeur des variables d'instance de l'objet
sur lequel la méthode est appelée.

\subsubsection{Définition de méthode}
Pour définir une méthode, on doit spécifier le type de la valeur
qu'elle renvoit ainsi que le type de chacun des paramètres et le nom
avec lesquels on les référencera à l'intérieur de la méthode.
La syntaxe est la suivante
\begin{lstlisting}
<scope> <return_type> <name> (<type_1> <param_1>, ...) bloc
\end{lstlisting}
Cette ligne (sans le \lstinline|bloc|) est appelée
la \emph{signature} de la méthode.
\begin{itemize}
  \item \lstinline|<scope>| est la portée de la méthode. Il peut être
    suivit par d'autres keywords;
  \item \lstinline|<return_type>| est le type de la valeur retournée par
    la méthode.
    Si la méthode ne retourne rien,
    \lstinline|<return_type>| vaut \lstinline|void|;
  \item \lstinline|<name>| est le nom de la méthode;
  \item \lstinline|<type_i>| est le type du \lstinline|i|\ieme{} paramètre et
    \lstinline|<param_i>| est son nom.

    \lstinline|<type_i> <param_i>| est appelé le \emph{paramètre formel};
  \item \lstinline|bloc| est un bloc d'instruction doté
    d'un keyword supplémentaire:
    \lstinline|return|. Sa syntaxe est la suivante
    \begin{lstlisting}
    return <expression>;
    \end{lstlisting}
    \lstinline|return| termine la méthode immédiatement
    (même s'il restait des instructions à exécuter) et
    renvoie \lstinline|<expression>| comme valeur de retour de la méthode.
    \begin{itemize}
      \item
        Si \lstinline|<return_type>| vaut \lstinline|void|, on peut quand même
        arrêter l'exécution de la méthode avec l'instruction \lstinline|return;|;
      \item
        Si \lstinline|<return_type>| ne vaut pas void,
        le compilateur doit pouvoir s'assurer qu'il pourra toujours
        trouver quoi retourner sinon, le code ne compilera pas.
        Par exemple,
        si, un \lstinline|return| est dans une structure de contrôle
        et pas après, il doit alors y en avoir un dans chaque embranchement
        et le \lstinline|else| doit être présent.
        Par exemple,
        \begin{lstlisting}
public static double div (double a, double b) {
  if (b != 0) {
    return a / b;
  }
}
        \end{lstlisting}
        ne compilera pas.
    \end{itemize}
\end{itemize}

\subsubsection{Appel de méthode}
Pour appeler une méthode, il faut utiliser la syntaxe suivante
\footnote{[ et ] sont là pour indiquer que c'est optionnel.}
\begin{lstlisting}
[<locator>.]<name>(<arg_1>, ...)
\end{lstlisting}
Si la méthode retourne \lstinline|void|, cet appel est une \emph{instruction}.
Sinon, c'est une \emph{expression}
dont le type est le type de retour de la méthode appelée.
\begin{itemize}
  \item \lstinline|<locator>| dépend du cas dans lequel on est
    \begin{itemize}
      \item Si on veut accéder à une méthode de classe extérieure à la classe
        dans laquelle on est, il vaut le nom de cette classe.
        Si on est dans la classe en question,
        \lstinline|<locator>.| est optionnel;
      \item Si on veut accéder à une méthode d'instance, il vaut le nom
        de la variable référençant cet objet.
        Si on est dans l'objet en question, \lstinline|<locator>.| est optionnel
        sauf si la variable qu'on veut accéder est cachée par une variable
        locale du même nom.
        On utilise le keyword \lstinline|this| pour obtenir la référence vers
        l'objet dans lequel une méthode est exécutée.
        Par exemple, dans le code suivant, \lstinline|this| est obligatoire;
        \begin{lstlisting}
public class ImageBitmap {
  private int[][] map;
  public ImageBitmap (int[][] map) {
    this.map = map;
  }
}
        \end{lstlisting}
    \end{itemize}
  \item \lstinline|<name>| est le nom de la méthode;
  \item \lstinline|<arg_i>| est une \emph{expression} qui donne la valeur
    du \lstinline|i|\ieme{} argument de la méthode.
    Ça équivaut à faire une assignation
    \begin{lstlisting}
    <type_i> <param_i> = <arg_i>;
    \end{lstlisting}
    à la différence que le type auquel est évalué de l'expression
    \lstinline|<arg_i>| sert à déterminer quelle fonction est appelée.

    \lstinline|<arg_i>| est appelé le \emph{paramètre effectif}.
    \paragraph{Attention} Comme c'est une assignation,
    si \lstinline|<arg_i>| est une variable, \lstinline|<param_i>| sera une copie de
    cette variable !
    Dès lors, changer \lstinline|<param_i>| ne change pas la valeur de
    \lstinline|<arg_i>|.
    Néanmoins, si \lstinline|<arg_i>| est la référence vers
    un object, c'est la référence qui est copiée, pas l'objet !
    Donc si on modifie l'objet vers qui \lstinline|<param_i>| fait référence,
    l'objet vers qui \lstinline|<arg_i>| fait référence est aussi modifié car
    c'est le même.
\end{itemize}
\java{} va localiser la fonction à appeler en grâce au \lstinline|<locator>|,
au \lstinline|<name>| et au type des \lstinline|<arg_i>|
(dans l'ordre dans lequels ils sont !).

\subsection{Variables}
La syntaxe pour utiliser les variables dans une classe est la même
que celle des méthodes sauf qu'on ne donne pas d'arguments.
On la définit comme suit
\footnote{[ et ] sont là pour indiquer que c'est optionnel.}
\begin{lstlisting}
<scope> <return_type> <name>[ = <expression>];
\end{lstlisting}
où l'initialisation avec \lstinline|<expression>| est optionnelle.
Elle s'utilise dans une expression comme suit
\begin{lstlisting}
[<locator>.]<name>
\end{lstlisting}
Et on lui fait une assignation comme suit
\begin{lstlisting}
[<locator>.]<name> = <expression>;
\end{lstlisting}

\java{} distingue les variables des méthodes au fait qu'on ne mette pas
de parenthèses.
Par exemple,
\begin{lstlisting}
x.length
\end{lstlisting}
c'est la variable \lstinline|length| de l'objet \lstinline|x| et
\begin{lstlisting}
x.length()
\end{lstlisting}
c'est la méthode \lstinline|length|
qui ne prend pas d'argument de l'objet \lstinline|x|.

\paragraph{Objet ou instance}
``objet'' et ``instance'' sont presque des synonymes.
En fait, ils veulent dire la même chose mais on ne les utilise pas au
même moment.
On ne dit pas ``c'est un objet de la classe \lstinline|String|'' mais plutôt
``c'est une instance de la classe \lstinline|String|'' ou encore
``c'est un objet de type \lstinline|String|''.
Aussi, pour parler de variables ou de méthodes non-statiques,
on dit des ``variables d'instance'' et des ``méthodes d'instance'' et non
``d'objet''.

\section{Classes et objets}
\subsection{Définition de classes}
Une classe est en quelque sorte la définition d'une ``famille d'objet''
qu'on pourrait aussi appeler une ``classe d'objet'', d'où le nom.

En \java{}, il y a une bijection entre classes et fichiers sources.
Chaque classe \lstinline{<name>} doit
se trouver dans un fichier \lstinline{<name>.java}.
Dans ce dernier, la syntaxe est la suivante
\begin{lstlisting}
public class <name> {
  ...
}
\end{lstlisting}

Mettez toujours \lstinline{public} dans le cadre de ce cours,
les \lstinline{...} sont à remplacer par les définitions
de variables et de méthodes
dont la syntaxe a été vue à la section~\ref{sec:varmeth}.

\subsection{Création et manipulation d'objets}
\subsubsection{Références}
Il y a un concept clé à comprendre sur les objets.
Une variable ne contient jamais un objet,
elle contient une \emph{référence} vers un objet.
On ne manipule jamais d'objet,
on manipule des références vers des objets.

Une référence vaut soit \lstinline{null}, soit la référence vers
un objet.

Lorsqu'on crée une variable de type non-primitif
sans l'initialiser, sa valeur est \lstinline{null}.

\subsubsection{Création d'objets}
Pour crééer un objet, on utilise le keyword \lstinline{new}.
Sa syntaxe est la suivante
\begin{lstlisting}
new <class>(<arg_1>, ...)
\end{lstlisting}
C'est une expression qui renvoie une référence vers l'objet créé.
Le type de cette référence est donc bien évidemment \lstinline{<class>}.

Pour stocker cette référence,
il faut créer une variable de type \lstinline{<class>}
ou une classe parente.
Par exemple, dans
\begin{lstlisting}
ArrayList array = new ArrayList();
\end{lstlisting}
array vaut une référence vers un objet de type \lstinline|ArrayList|
qui vient d'être créé.

\subsubsection{Constructeur}
Un objet est un contexte pour ses méthodes d'instances.
Lorsque vous définissez une classe, vous donnez un sens à vos variables
d'instances.

Pour vos méthodes d'instance,
en plus du devoir de respecter la pre et la post, vous devez respecter ce
sens que vous donnez à vos variables d'instance.
Pour ce faire,
écrivez une méthode telle que, si la pre et la cohérence de vos variables
d'instance à l'entrée est respectée,
la post et la cohérence de vos variables d'instance
à la sorties est respectée aussi.

Ainsi, vos variables d'instances seront toujours cohérentes, non ?
Mais quand est-il de la cohérence de vos variable d'instance à la création
de votre objet ?
Rappelez vous que pour qu'un raisonnement par récurrence marche, il faut
une induction et une \emph{initialisation}.

Cette initialisation, c'est votre constructeur.
Vous pouvez créer différents constructeurs avec une signature différente,
pour créer différentes valeurs de départ cohérentes pour votre classe.

Ce constructeur est appelé par le keyword \lstinline|new|.
\java{} cherche le constructeur avec la signature correspondante aux
types des arguments d'entrées \lstinline|(<arg_1>, ...)|.

Un constructeur, ça ressemble à une méthode mais ce n'est pas une méthode.
\begin{itemize}
  \item Premièrement, il ne faut pas lui stipuler de valeur de retour;
  \item
    Deuxièmement, pour l'appeler, il y a deux façon,
    soit \lstinline|this(<arg_1>, ...)|, ça appelle le constructeur
    de la classe dans laquelle on est.
    Soit \lstinline|super(<arg_1>, ...)|, ça appelle le constructeur
    de la classe parente à celle dans laquelle on écrit
    (ce n'est pas spécialement la classe parente à celle de \lstinline|this|,
    voir la section~\ref{sec:this_super}).
    Ces appels ne peuvent que se trouver à la première ligne d'un constructeur.
    En fait, si il n'y a pas de ligne comme ça à la première ligne
    d'un constructeur, \java{} considère qu'on a mis \lstinline|super()|.
    Si la classe \lstinline|super| n'a pas de constructeur sans paramètre,
    \java{} ne compilera pas et vous devrez appeler
    le constructeur de \lstinline|super| avec des arguments.
\end{itemize}

Voici deux exemples:
\begin{enumerate}
  \item
    Une classe \lstinline|Number| contenant un nombre.
    \begin{lstlisting}
public class Number {
  private int value;
  public Number (int value) {
    this.value = value;
  }
  public Number () {
    this(42); // default value
  }
}
    \end{lstlisting}
    Ici, \lstinline|super| vaut \lstinline|Object| qui a un constructeur
    sans arguements.
  \item
    Une classe \lstinline{Human}
    \begin{lstlisting}
public class Human {
  private String name;
  public Human (String name) {
    this.name = name;
  }
}
    \end{lstlisting}
    et une classe \lstinline{Woman}.
    \begin{lstlisting}
public class Woman extends Human {
  public Woman (String name) {
    super(name);
  }
}
    \end{lstlisting}
\end{enumerate}

\subsubsection{Manipulation d'objets}
On s'interdit de rendre les variables d'instance publiques,
c'est le principe d'\emph{encapsulation}.
Dès lors,
on peut manipuler les objets qu'en appelant leur méthodes d'instances.

Lorsqu'on implémente une méthode d'instance, on peut non seulement accéder
à tous les éléments statiques à portée mais aussi aux variables
et méthodes d'instance.
En y fesant référence, on référence celles de l'objet dans lequel on est.

\paragraph{Attention}
Dans le code suivant
\begin{lstlisting}
String s = "42";
String t = s;
\end{lstlisting}
\lstinline|s| et \lstinline|t| référencent vers le même objet.
L'objet n'a pas été copié.
Seulement la référence a été copié.
C'est pareil pour le passage de variable à une fonction.

\subsubsection{Destruction d'objets}
Un élément de \java{} appelé le \emph{Garbage Collection} garde en mémoire,
pour chaque objet créé, le nombre de variables qui le référence.
Dès que ce nombre tombe à zéro, \java{} sait que plus personne ne pourra
toucher à cette objet et marque la place qu'il prenait dans la mémoire
comme libre.

\section{Héritage}
La programmation orientée objet n'aurait que peut d'intérêt sans l'héritage
et le polymorphisme (voir section~\ref{sec:polymorphism}).
L'héritage permet de n'écrire du code commun à deux classes qu'une seule fois.

Dire qu'une classe hérite d'une autre signifie que toutes les méthodes
et variables définies par l'autre et par ses classes parentes sont également
définies pour la classe fille.

On peut également les redéfinir.

\subsection{Polymorphisme}
\label{sec:polymorphism}
%Tout le concept de polymorphisme se cache en fait derrière le mot clef
%\lstinline|this|.
Quand on appelle une méthode sur un objet qu'on a casté dans sa classe
parente mais que sa classe redéfini la méthode.
Quelle implémentation de la méthode va être appelée ?

Le polymorphisme, c'est quand c'est la méthode de la classe fille qui est
appelée. C'est à dire que l'objet, même après avoir été casté, se souvient
de ce qu'il est vraiment.

Par exemple, supposons qu'on ait créé une classe
\lstinline|Animal| ainsi qu'une classe \lstinline|Dog| et \lstinline|Cat|.

Supposons qu'on ait une référence \lstinline|a|
de type \lstinline|Animal| mais qu'on mette dans \lstinline|a|
une référence vers un objet de type \lstinline|Dog|.
\begin{lstlisting}
Animal a = new Dog();
\end{lstlisting}
Que va faire \lstinline|a.shout()| ?

Grâce au polymorphisme, ça va faire \lstinline|Waf waf|.

\subsection{Liens statiques et dynamiques}
\label{sec:this_super}
À cause de l'héritage, quand vous implémentez une méthode dans une classe
vous ne savez jamais vraiment si elle va être appelée sur des objets
de cette classe ou d'une classe fille. % TODO class final ? :D

Dès lors, quand vous utilisez \lstinline|this| et \lstinline|super|,
à quelle classe faites-vous référence ?

Lorsque vous utilisez \lstinline|this|,
vous faites juste référence à l'objet dans lequel vous êtes,
c'est un lien dynamique car si le type de votre objet est une classe fille
et quelle a réimplémenté la méthode
qu'on essaie d'appeler avec \lstinline|this|,
c'est la réimplémentation qu'on appelle.
% FIXME: this dans un constructeur :/
% A:
% A(int)
% A() this(42) -> this of type B :/
% B()

\lstinline|super| par contre est un lien statique,
il fait référence à la classe parente à la classe dans laquelle on écrit.
On essaie d'éviter les liens statiques,
essayez de n'utiliser \lstinline|super| que dans la première ligne
d'un constructeur.

\subsection{Classes abstraites et interfaces}
Parfois,
on aimerait pas qu'on instantie une classe.
Par exemple, ça a du sens de faire \lstinline|new Dog()|
mais ça n'a aucun sens de faire \lstinline|new Animal()|.
Aussi, on aimerait bien dire que tous les classes filles
de \lstinline|Animal| doivent implémenter \lstinline|shout|
comme ça on peut implémenter la méthode \lstinline|makeNoise|
dans la classe \lstinline|Animal|.

\java{} permet de faire ça de manière élégante avec le concept
de classe abstraite.
L'idée, c'est de ne pas implémenter \lstinline|shout| et de dire
``Je ne l'implémente pas, et d'ailleurs, vous ne pouvez même pas créer
d'animaux car je n'ai pas implémenté toutes les méthodes''.
Voilà comment faire cela
\begin{lstlisting}
public abstract class Animal {
  public abstract void shout ();
  public void makeNoise () {
    for (int i = 0; i < 42; i++) {
      shout();
    }
  }
}
\end{lstlisting}

Maintenant, toutes les classes qui héritent de \lstinline|Animal| ont
deux choix: implémenter \lstinline|shout| ou être abstraite.

\subsubsection{L'héritage multiple}
L'héritage, avant tout, c'est une relation ``est''.
Mais que faire quand on veut faire deux relation ``est'' ?
Par exemple, un chien est un animal mais c'est aussi un carnivore !
Du coup, j'aimerais pouvoir écrire une classe \lstinline|Carnivore|
pour pouvoir utiliser les bienfaits du polymorphisme sur les animaux
carnivores.

Pour faire celà, l'héritage multiple a été inventé.
L'héritage multiple, c'est tout simplement hériter de 2 classes.
Seulement, en \java{}, on \emph{ne peut pas} faire d'héritage multiple.
Pourquoi ? Imaginez que \lstinline|Carnivore| et \lstinline|Animal|
implément la méthode \lstinline|walk| et que \lstinline|Dog| ne la
réimplémente pas. Que faire quand on appelle \lstinline|walk| sur un
\lstinline|Dog| ?

\subsubsection{Interfaces}
L'idée la plus simple pour régler le problème est de dire qu'
on a le droit d'hériter de plusieurs classe mais
une seule des classes qu'on hérite doit avoir implémenté des méthodes.
Les autres doivent n'avoir que des méthodes abstraites.
Comme ça, plus de soucis !

Pour ça, le \java{} a inventé les interfaces, c'est tout simplement
des classes complètement abstraites.
C'est à dire qu'elles n'implémentent aucune de leur méthodes.

On ne dit plus hériter dans ce cas-ci mais implémenter une interface.
La syntaxe est la suivante

\paragraph{Définition d'interfaces}
La syntaxe pour définir une interface \lstinline|<name_1>| est la suivante
\begin{lstlisting}
public interface <name_1> {
  ...
}
\end{lstlisting}

\paragraph{Implémentation d'interface} % separated by coma or space ?
La syntaxe pour dire que \lstinline|<name_2>|
implémente l'interface \lstinline|<name_1>| est la suivante
\begin{lstlisting}
public class <name_2> implements <name_1> {
}
\end{lstlisting}

La règle de l'héritage multiple en \java{} est alors:
``une classe peut hériter que d'une seule classe mais peut implémenter
autant d'interface qu'elle veut''.

\section{Exception}
Lorsque vous écrivez une méthodes,
des cas exceptionnels peuvent arriver.
Pour que votre programme soit robuste,
vous devez gérez ces cas.

\subsection{Exceptions contrôlées et non-contrôlées}
On peut différentier ces cas exceptionnels en deux cas
\begin{itemize}
  \item ceux dus à une erreur de la part du programmeur;
  \item ceux dus à une erreur de la part de l'utilisateur.
\end{itemize}

La manière de gérer ça proprement en \java{},
c'est avec les exceptions.
Chaque exception différente est une classe qui hérite de la classe
\lstinline{Exception}.

\begin{itemize}
  \item
    Les exceptions dues à une erreur de la part du programmeur héritent
    de \lstinline{RuntimeException} qui hérite lui de \lstinline{Exception},
    c'est les exceptions non-contrôlées (unchecked);
  \item
    Les exceptions dues à une erreur de la part de l'utilisateur n'héritent
    pas de \lstinline{RuntimeException} mais héritent bien de
    \lstinline{Exception}, c'est les exceptions contrôlées (checked).
\end{itemize}

La différence entre les deux types exceptions, c'est que si une méthode
lance une exception contrôlées ou qu'elle appelle une méthode qui en
lance une sans la catcher, il doit rajouter à la fin de sa signature
\lstinline|throws <name>| où \lstinline|<name>| est le nom de la classe
de l'exception.

\subsection{Lancer une expression}
Pour lancer une exception, il faut utiliser le keyword \lstinline{throw}.
La syntaxe est la suivante
\begin{lstlisting}
throw new <name>(<arg_1>, ...);
\end{lstlisting}
où \lstinline|<name>| est le nom de la classe de l'exception à lancer.
\lstinline|new <name>(<arg_1>, ...)| crée un objet en appelant le constructeur
ce \lstinline|<name>| avec les arguments \lstinline|(<arg_1>, ...)|.

Il arrête immédiatement l'exécution de la méthode, de la méthode qui
l'appelait et ainsi de suite jusqu'à une méthode qui catch l'exception.
Si aucune méthode ne la catch, l'exécution s'arrête avec une erreur.

\subsection{Catcher une exception}
Pour catcher une exception dont le nom de la classe est \lstinline|<name>|
lancée par un bloc d'instruction \lstinline|<bloc_1>|,
la syntaxe est la suivante
\begin{lstlisting}
try <bloc>
catch (<name_1> <var_1>) <bloc_1>
catch (<name_2> <var_2>) <bloc_2>
...
\end{lstlisting}
où \lstinline|<var_i>| est un nom de variable et \lstinline|<bloc_i>|
est un bloc d'instruction.

Si \lstinline|<bloc>| lance une exception de type \lstinline|<name_i>|,
\lstinline|<bloc_i>| est exécuté avec la variable \lstinline|<var_i>|
valant une référence vers l'exception lancée.

\subsection{Les assertions}
Les assertions en \java{} permettent de vérifier si les préconditions sont respectées en utilisant le mécanisme des
exceptions. Une assertion s'utilise de la manière suivante :

\begin{lstlisting}
assert <condition> : <message>;
\end{lstlisting}

Si la condition n'est pas respectée, le programme s'arrêtera et le message d'erreur \lstinline|message| s'affichera.

\section{Lecture et écriture dans un fichier texte}
\paragraph{Package nécessaire }
Toutes les méthodes utilisées dans cette section se trouvent dans le package \lstinline|java.io|, il est donc
indispensable de l'importer à l'aide de la ligne de code suivante :

\begin{lstlisting}
import java.io.*;
\end{lstlisting}

\paragraph{Gestion des exceptions } Lorsqu'on manipule des fichiers, il est important de traiter les différentes exceptions (notamment les \lstinline|IOException|) qui peuvent survenir. Le traitement de ces exceptions ne sera pas indiqué dans cette section.

\subsection{Lire un fichier texte}
Pour lire un fichier texte, nous aurons besoin de deux classes : \lstinline|BufferedReader| et \lstinline|FileReader|. L'ouverture du fichier se fait de la manière suivante :

\begin{lstlisting}
BufferedReader file = new BufferedReader(new FileReader("filename.txt"));
\end{lstlisting}

Il est ensuite possible de parcourir le texte ligne par ligne grâce à la méthode \lstinline|readLine()| de la classe \lstinline|BufferedReader|. Cette méthode ne prend pas de paramètre et retourne \lstinline|null| une fois à la fin du fichier :

\begin{lstlisting}
file.readLine();
\end{lstlisting}

Enfin, il est important de bien fermer le flux une fois toutes les manipulations terminées. Le flux se ferme avec la ligne de code suivante :

\begin{lstlisting}
file.close();
\end{lstlisting}

\subsection{Ecrire dans un fichier texte}
Pour écrire dans un fichier texte, nous aurons encore besoin de deux classes : \lstinline|PrintWriter| et \lstinline|FileWriter|. Comme pour la lecture, il faut avant tout ouvrir le fichier :

\begin{lstlisting}
PrintWriter file = new PrintWriter(new FileWriter("filename.txt"));
\end{lstlisting}

Il est ensuite possible d'écrire du texte ligne par ligne grâce à la méthode \lstinline|println()| de la classe \lstinline|PrintWriter|. Par exemple :

\begin{lstlisting}
file.println("Blablablablabla...");
\end{lstlisting}

Ici aussi, il ne faut pas oublier de fermer le fichier une fois toutes les manipulations terminées.

\section{Les collections}
\subsection{La classe \lstinline|ArrayList|}
La classe \lstinline|ArrayList| est une classe :

\begin{itemize}
\item Qui utilise un tableau comme composant ;
\item Dont la taille est extensible (contrairement aux tableaux classique de \java{}) ;
\item Qui offre des méthodes supplémentaires.
\end{itemize}

Un \lstinline|ArrayList| s'initialise de la façon suivante :

\begin{lstlisting}
ArrayList<E> name = new Arraylist<E>();
\end{lstlisting}

Où \lstinline|E| peut être n'importe quel type d'objet (on parle alors de type \textit{générique}).
On ne peut pas créer d'\lstinline|ArrayList| de types primitifs, pour créer un
\lstinline|ArrayList| contenant des entiers par exemple, il faudra utiliser la classe
\textit|wrapper| de \lstinline|int|, à savoir \lstinline|Integer|.

Un \lstinline|ArrayList| possède entre autre les méthodes suivantes :

\begin{itemize}
\item \lstinline|boolean add(E obj)| : ajoute \lstinline|obj| en fin de liste ;
\item \lstinline|void add(int index, E obj)| : ajoute \lstinline|obj| à la position \lstinline|index| ;
\item \lstinline|E get(int index)| : retourne une référence vers l'objet à la position \lstinline|index| ;
\item \lstinline|void set(int index, E obj)| : remplace l'élément à la position \lstinline|index|
par \lstinline|obj|;
\item \lstinline|E remove(int index)| : retire et retourne une référence vers l'élément situé
à la position \lstinline|index| ;
\item \lstinline|boolean contains(E obj)| : renvoie \lstinline|true| si \lstinline|obj| appartient
à la liste.
\end{itemize}

\paragraph{Attention}
Un élément d'un \lstinline|ArrayList| ne contient pas d'objet directement mais bien
la référence vers cet objet (comme d'habitude).

\paragraph{Remarque}
La classe \lstinline|ArrayList<E>| implémente l'interface \lstinline|List<E>| qui implémente
elle même l'interface \lstinline|Collection<E>|.

\subsection{Parcourir une collection : les itérateurs}
Il est possible de parcourir une collection de manière élégante grâce à des objets
de types \lstinline|Iterator<E>|. Pour utiliser un itérateur, il faut connaître
les deux méthodes suivantes :

\begin{itemize}
\item \lstinline{boolean hasNext()} : renvoie \lstinline|true| s'il y a encore des
éléments à parcourir dans la collection, \lstinline|false| sinon ;
\item \lstinline|E next()| : renvoie une référence vers l'élement suivant dans la liste.
Lance une \lstinline|NoSuchElementException| si \lstinline|hasNext() == false|.
\end{itemize}

Chaque collection a son itérateur. Pour obtenir une référence vers un itérateur, il existe
une méthode que toute collection implémente : il s'agit de la méthode \lstinline|iterator()|.

Voici un exemple complet d'utilisation d'un itérateur sur une liste contenant
des objets de types \lstinline|Clients|. Chaque \lstinline|Clients| possède un nom.

\begin{lstlisting}
Collection<Client> listeClients = ... ;
Iterator<Client> iterator = listeClients.iterator();
Client current;

while(iterator.hasNext())
{
  current = iterator.next();
  System.out.println(current.getName());
}
\end{lstlisting}

\annexe
\section{Installation}
\subsection{Sous GNU/Linux}
Vous avez deux choix, Oracle JDK ou OpenJDK.
Il ne sera pas discuté ici quel est la meilleure.

\subsubsection{OpenJDK}
OpenJDK se trouve dans votre gestionnaire de packets.
Par exemple, sur Ubuntu, c'est dans le Ubuntu Software Center.
Les packets nécessaires sont \lstinline|openjdk-7-jre| et
\lstinline|openjdk-7-jdk|.

\subsubsection{Oracle JDK}
Pour Ubuntu, suivez le guide suivant\\
\url{http://www.webupd8.org/2012/01/install-oracle-java-jdk-7-in-ubuntu-via.html}

Pour Debian, suivez le guide suivant\\
\url{http://www.webupd8.org/2012/06/how-to-install-oracle-java-7-in-debian.html}


\section{Écrire, compiler et exécuter}
Nous allons différencier la programmation par IDE et en console.
Les remarques sur l'écriture, la programmation et la compilation
sont dans la partie console mais elles valent aussi pour la
programmation à travers un IDE.

\subsection{IDE}
Un \textbf{IDE} (\textbf{I}ntegrated \textbf{D}evelopment \textbf{E}nvironment)
fourni un éditeur de texte et des boutons pour compiler et exécuter.
Tout ça avec une interface graphique.

Pour \java{}, on peut citer notamment
\begin{itemize}
  \item Eclipse;
  \item Netbeans;
  \item BlueJ.
\end{itemize}
Ils sont tous les trois libres donc gratuits.

\subsection{Console}
Programmer en console signifie utiliser
l'éditeur de texte et le compilateur séparément.
On appelle ça programmer à la console car on appelle souvent le compilateur
et on exécute le programme à travers l'invite de commande.

Supposons qu'on crée le projet \lstinline|Foobar| contenant la classe
\lstinline|Foo| et la classe \lstinline|Bar|,
la méthode \lstinline|main| étant dans la classe \lstinline|Foo|.

Une structure classique serait de placer
\lstinline|Foo.java| et \lstinline|Bar.java|
dans un dossier \lstinline|src/| et placer un fichier \lstinline|README|
à la racine du projet expliquant brièvement ce que fait le programme.

\subsubsection{Se déplacer dans la console}
Dans une console, on se situe toujours dans un dossier.
Lorqu'on ouvre une console, on se trouve dans le dossier personnel.
Pour savoir dans lequel on se trouve,
exécutez la commande suivante
(\textbf{P}rint \textbf{W}orking \textbf{D}irectory):
\begin{lstlisting}[language={sh}]
$ pwd
/home/jean
\end{lstlisting}

Pour voir les fichiers dans le dossier courant, exécutez la commande suivante:
%TODO: LiSt ou List Segments ?
\begin{lstlisting}[language={sh}, morekeywords={ls}]
$ ls
Desktop                    Music                Templates
Documents                  Pictures             Videos
Downloads                  Public
\end{lstlisting}

Pour se déplacer, il faut utiliser la commande
\lstinline|cd| (\textbf{C}hange \textbf{D}irectory).
\begin{lstlisting}[language={sh}, morekeywords={xx}]
$ cd Documents
$ pwd
/home/jean/Documents
$ cd ..
$ pwd
/home/jean
\end{lstlisting}

\subsubsection{Écrire}
Pour écrire \lstinline|Foo.java|, \lstinline|Bar.java| et \lstinline|README|,
il nous faut un éditeur de texte.

\begin{itemize}
  \item Sur Linux, les plus simples sont {\em Gedit} et {\em Kate};
  \item Sur Mac OS, {\em TextMate} est un excellent choix;
  \item Sur Windows, je conseille {\em Notepad++}.
\end{itemize}

Il y en a plein d'autre évidemment. Comment ne pas citer {\em Emacs} et
{\em Vim} qui, bien qu'étant très anciens, sont considérés par beaucoup
pour être les plus complets et les plus puissants.
Attention néanmoins, la {\em learning curve} de ces derniers est assez raide.

Si vous n'avez pas d'interface graphique et que vous ne voulez pas utiliser
un éditeur de texte aussi compliqué que {\em Emacs} ou {\em Vim}, considérez
{\em nano} ou {\em pico}.

Pour lancer un éditeur de texte depuis la console,
positionnez-vous dans le même dossier que le fichier à ouvrir
et exécutez la commande suivante:
\begin{lstlisting}[language={sh}, morekeywords={vim}]
$ vim Foo.java
\end{lstlisting}
Pour un éditeur de texte graphique,
il vaut mieux l'appeler ajouter un \lstinline|&| pour qu'il s'exécute en
background et que l'invite de commande ne se bloque pas:

\begin{lstlisting}[language={sh}, morekeywords={gedit}]
$ gedit Foo.java &
\end{lstlisting}

\subsubsection{Compiler}
Il faut compiler chaque classe en fichier \lstinline|.class|.
Pour cela, la commande à utiliser est \lstinline|javac|.
Avec un terminal ouvert et positionné dans le fichier \lstinline|src/|,
exécutez la commande suivante:
\begin{lstlisting}[language={sh}, morekeywords={javac}]
$ javac Foo.java Bar.java
\end{lstlisting}
Notez que l'ordre entre les fichiers \lstinline|.java| n'a aucune importance.

\subsubsection{Exécuter}
À nouveau,
ouvrez un terminal et positionnez le dans le fichier \lstinline|src/|.
Il faut dire à \java{} dans quelle classe se trouve la méthode \lstinline|main|.
Dans notre cas, c'est dans la classe \lstinline|Foo|.
Dès lors, exécutez la commande suivante:
\begin{lstlisting}[language={sh}, morekeywords={java}]
$ java Foo
\end{lstlisting}
Notez qu'on écrit pas d'extension à \lstinline|Foo|,
on écrit ni \lstinline|Foo.java| ni \lstinline|Foo.class|.

\end{document}
